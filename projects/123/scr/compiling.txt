def mirrorAnimation(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
        ids = int(nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"])

    else:
        ids = int(nodes["objects"][str(id)]["inputs"]["id"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["horizontal"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["horizontal"]["value"]["value"] is not None:
        horizontal = bool(nodes["objects"][str(id)]["inputs"]["horizontal"]["value"]["value"])

    else:
        horizontal = bool(nodes["objects"][str(id)]["inputs"]["horizontal"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["vertical"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["vertical"]["value"]["value"] is not None:
        vertical = bool(nodes["objects"][str(id)]["inputs"]["vertical"]["value"]["value"])

    else:
        vertical = bool(nodes["objects"][str(id)]["inputs"]["vertical"]["standard"])

    program.objects.getById(ids).animator.flipAnimation(horizontal, vertical)

    return queue

def runAnimation(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
        ids = int(nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"])

    else:
        ids = int(nodes["objects"][str(id)]["inputs"]["id"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["animation"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["animation"]["value"]["value"] is not None:
        animation = str(nodes["objects"][str(id)]["inputs"]["animation"]["value"]["value"])

    else:
        animation = str(nodes["objects"][str(id)]["inputs"]["animation"]["standard"])

    program.objects.getById(ids).animator.runAnimation(animation)

    return queue

def stopAnimation(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
        ids = int(nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"])

    else:
        ids = int(nodes["objects"][str(id)]["inputs"]["id"]["standard"])

    program.objects.getById(ids).animator.stopAnimation()

    return queue

def callFunction(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    if nodes["objects"][str(id)]["inputs"]["name"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"] is not None:
        name = str(nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"])

    else:
        name = str(nodes["objects"][str(id)]["inputs"]["name"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["params"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["params"]["value"]["value"] is not None:
        params = list(nodes["objects"][str(id)]["inputs"]["params"]["value"]["value"])

    else:
        params = list(nodes["objects"][str(id)]["inputs"]["params"]["standard"])

    for ids in compiler.functionsByName(name):
        nodes["objects"][str(ids)]["inputs"]["params"]["standard"] = params

        queue.append(ids)

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    return queue

HOLDERS_LIST = ["%math", "%local_var", "%global_var"]


def replace(s, old, new):
    pos = s.rfind(old)

    if pos == -1:
        return s

    return str(s[:pos]) + str(new) + str(s[pos + len(old):])


class Holders:
    @staticmethod
    def math(text, variables):
        try:
            ntext = text

            while ntext.startswith("\'"):
                ntext = ntext[1:]

            while ntext.endswith("\'"):
                ntext = ntext[:-1]

            return eval(ntext)

        except Exception as e:
            try:
                return eval(text)

            except Exception as e:
                return text

    @staticmethod
    def local_var(text, variables):
        try:
            return "\'" + variables["locals"][text]["value"] + "\'" if isinstance(variables["locals"][text]["value"], str) else variables["locals"][text]["value"]

        except:
            return "null"

    @staticmethod
    def global_var(text, variables):
        try:
            return "\'" + variables["globals"][text]["value"] + "\'" if isinstance(variables["globals"][text]["value"], str) else variables["globals"][text]["value"]

        except:
            return "null"


def decodeHolders(text: str, variables: dict):
    types = []

    for i, symbol in enumerate(text):
        if text[i] == "(":
            valueEndIndex = text.find(")", i, -1)

            name = text[text.rfind("%", 0, i):i]
            value = text[i:valueEndIndex + 1]

            if name not in HOLDERS_LIST:
                continue

            if value == -1:
                continue

            countOpenBracket = value.count("(")
            countEndBracket = value.count(")")

            while countOpenBracket - countEndBracket > 0:
                valueEndIndex += 1

                if text[valueEndIndex] not in (")", "("):
                    continue

                if text[valueEndIndex] == ")":
                    countEndBracket += 1

                else:
                    countOpenBracket += 1

                value = text[i:valueEndIndex + 1]

            types.append([text.rfind("%", 0, i), value.count("%"), name, value[1:-1]])

    types.sort(key=lambda x: x[1] * 1e9 + x[0])

    # for element in types:
    #     print(*element)

    # print(types)

    # print("-->", text)

    for i, element in enumerate(types):
        value = getattr(Holders, element[2][1:])(element[3], variables)

        text = replace(text, f"{element[2]}({element[3]})", value)

        for elem in types[i:]:
            elem[3] = elem[3].replace(f"{element[2]}({element[3]})", str(value))

        # print("-->", text)

    return text


def decodeHolder(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["text"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["text"]["value"]["value"] is not None:
        text = str(nodes["objects"][str(id)]["inputs"]["text"]["value"]["value"])

    else:
        text = str(nodes["objects"][str(id)]["inputs"]["text"]["standard"])

    answer = decodeHolders(text, variables)

    for ids, connector in nodes["objects"][str(id)]["outputs"]["answer"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer

    return queue


"""
if __name__ == "__main__":
    import time

    start = time.time()

    variables = {"locals": {"123": {"value": '65'}, "1": {"value": 2}}, "globals": {"1": {"value": True}}}
    text = "%math(%local_var(123) + %local_var(1))"

    print(decodeHolders(text, variables))

    print(time.time() - start)
"""

def exit_(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    program.exit()

    return queue

def functionEvent(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    if nodes["objects"][str(id)]["inputs"]["params"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["params"]["value"]["value"] is not None:
        params = list(nodes["objects"][str(id)]["inputs"]["params"]["value"]["value"])

    else:
        params = list(nodes["objects"][str(id)]["inputs"]["params"]["standard"])

    for ids, connector in nodes["objects"][str(id)]["outputs"]["params"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = params

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    return queue

import pygame


def getMousePos(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    x, y = pygame.mouse.get_pos()

    for ids, connector in nodes["objects"][str(id)]["outputs"]["x"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = x

    for ids, connector in nodes["objects"][str(id)]["outputs"]["y"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = y

    return queue

def getTimePassed(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    time_passed = program.dt

    for ids, connector in nodes["objects"][str(id)]["outputs"]["time_passed"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = time_passed

    return queue

def getVar(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["name"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"] is not None:
        name = str(nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"])

    else:
        name = str(nodes["objects"][str(id)]["inputs"]["name"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["global"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["global"]["value"]["value"] is not None:
        gl = nodes["objects"][str(id)]["inputs"]["global"]["value"]["value"]

    else:
        gl = nodes["objects"][str(id)]["inputs"]["global"]["standard"]

    if gl:
        answer = variables["globals"][name]["value"]

    else:
        answer = variables["locals"][path][name]["value"]

    for ids, connector in nodes["objects"][str(id)]["outputs"]["answer"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer

    return queue

def len_(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["element"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"] is not None:
        if type(nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"]) == str:
            element = eval(nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"])

        else:
            element = eval(str(nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"]))

    else:
        if type(nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"]) == str:
            element = eval(nodes["objects"][str(id)]["inputs"]["element"]["standard"])

        else:
            element = eval(str(nodes["objects"][str(id)]["inputs"]["element"]["standard"]))

    answer = len(element) if type(element) in (list, tuple, dict) else 1

    for ids, connector in nodes["objects"][str(id)]["outputs"]["answer"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer

    return queue

import functools
import typing
import random
import pygame
import re


if typing.TYPE_CHECKING:
    def decodeHolders(text, variables):
        pass

else:
    pass


class PythonFunctions:
    functions = ["decodeHolder", "exit", "getVar", "setVar", "objectsGroup", "random", "writeText", "displayText", "collision", "createObject", "getObjectIDByName", "getObjectPos", "getObjectVar", "jump", "moveObject", "removeObject", "setObjectPos", "setObjectVar", "getResultingVector", "runAnimation", "stopAnimation", "mirrorAnimation", "getMousePos"]

    @staticmethod
    def decodeHolder(text, program, variables, path):
        return decodeHolders(text, variables)

    @staticmethod
    def exit(program, variables, path):
        program.exit()

    @staticmethod
    def getVar(name, global_, program, variables, path):
        if global_:
            return variables["globals"][name]["value"]

        else:
            return variables["locals"][path][name]["value"]

    @staticmethod
    def setVar(name, global_, value, program, variables, path):
        if global_:
            variables["globals"][name]["value"] = value

        else:
            variables["locals"][path][name]["value"] = value

    @staticmethod
    def objectsGroup(group, program, variables, path):
        return program.objects.getByGroup(group)

    @staticmethod
    def random(a, b, program, variables, path):
        return a if a == b else random.randint(a, b)

    @staticmethod
    def writeText(text, program, variables, path):
        answer = ">>> " + str(text).rstrip() + "\n"

        program.print(answer)

        print(answer)

    @staticmethod
    def displayText(text, x, y, program, variables, path):
        program.afterDrawing.append(lambda: program.linkEngine.print_text(program.screen, x, y, str(text)))

    @staticmethod
    def collision(ids, group, append, program, variables, path):
        obj = program.objects.getById(ids)

        answer = obj.collisionGetID(0, 0, append, group) if obj is not None else [False, -1]

        return answer

    @staticmethod
    def createObject(name, x, y, program, variables, path):
        if not name.endswith(".obj"):
            name += ".obj"

        type = program.allObjects[name]["type"]
        variables = program.allObjects[name]["variables"]

        variables["pos"] = [x, y]

        obj = getattr(program.linkEngine.objects, type)(program, **variables)

        program.objects.add(obj)

        return obj.id

    @staticmethod
    def getObjectIDByName(name, program, variables, path):
        name = name + ".objc" if not name.endswith(".objc") else name

        answer = program.objectIDByName[program.scene][name] if name in program.objectIDByName[program.scene] else -1

        return answer

    @staticmethod
    def getObjectPos(ids, program, variables, path):
        return program.objects.getById(ids).pos.get()

    @staticmethod
    def getObjectVar(ids, name, program, variables, path):
        answer = variables["objects"][program.scene][program.objectNameByID[program.scene][str(ids)]][name]["value"]

    @staticmethod
    def jump(ids, program, variables, path):
        obj = program.objects.getById(int(ids))

        obj.moveByType("jump")

    @staticmethod
    def moveObject(ids, angle, power, program, variables, path):
        obj = program.objects.getById(int(ids))

        obj.moveByAngle(angle, power)

    @staticmethod
    def removeObject(ids, program, variables, path):
        program.objects.removeById(ids)

    @staticmethod
    def setObjectPos(ids, x, y, program, variables, path):
        obj = program.objects.getById(int(ids))

        obj.pos.x = x
        obj.pos.y = y

    @staticmethod
    def setObjectVar(ids, name, value, program, variables, path):
        variables["objects"][program.scene][program.objectNameByID[program.scene][str(ids)]][name]["value"] = value

    @staticmethod
    def getResultingVector(ids, program, variables, path):
        return program.objects.getById(ids).getVectorsPower().get()

    @staticmethod
    def runAnimation(ids, animation, program, variables, path):
        program.objects.getById(ids).animator.runAnimation(animation)

    @staticmethod
    def stopAnimation(ids, animation, program, variables, path):
        program.objects.getById(ids).animator.stopAnimation()

    @staticmethod
    def mirrorAnimation(ids, horizontal, vertical, program, variables, path):
        program.objects.getById(ids).animator.flipAnimation(horizontal, vertical)

    @staticmethod
    def getMousePos(program, variables, path):
        return pygame.mouse.get_pos()

    @staticmethod
    def setObjectParameter(ids, name, value, program, variables, path):
        program.objects.getById(ids).setParameter(name, value)

    @staticmethod
    def getObjectParameter(ids, name, program, variables, path):
        return program.objects.getById(ids).getParameter(name)

    @staticmethod
    def getTimePassed(ids, program, variables, path):
        return program.dt


class PythonCodeExecutor:
    program = None
    variables = None
    path = None

    contest = {}

    inited = False

    @classmethod
    def init(cls):
        for func in PythonFunctions.functions:
            cls.contest[func] = functools.partial(getattr(PythonFunctions, func), program=cls.program, variables=cls.variables, path=cls.path)

    @classmethod
    def add(cls, program):
        if not cls.inited:
            cls.init()

        exec(program, cls.contest)

    @classmethod
    def run(cls, program, args, kwargs):
        return cls.contest["run"](program, args=args, kwargs=kwargs)


@functools.lru_cache(None)
def pythonCheckHaveFunction(text):
    pattern = r'\bdef\s+run\s*\('

    match = re.search(pattern, text)

    return bool(match)


def python(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["text"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["text"]["value"]["value"] is not None:
        text = str(nodes["objects"][str(id)]["inputs"]["text"]["value"]["value"])

    else:
        text = (str(nodes["objects"][str(id)]["inputs"]["text"]["standard"]))

    if nodes["objects"][str(id)]["inputs"]["list"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"] is not None:
        list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"])

    else:
        list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["dict"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["dict"]["value"]["value"] is not None:
        dict_ = dict(nodes["objects"][str(id)]["inputs"]["dict"]["value"]["value"])

    else:
        dict_ = dict(nodes["objects"][str(id)]["inputs"]["dict"]["standard"])

    if PythonCodeExecutor.program is None:
        PythonCodeExecutor.variables = variables
        PythonCodeExecutor.program = program

        PythonCodeExecutor.path = path

    PythonCodeExecutor.add(text)

    if pythonCheckHaveFunction(text):
        listOutput = PythonCodeExecutor.run(program, list_, dict_)

    else:
        listOutput = []

    if listOutput is None:
        listOutput = []

    elif not isinstance(listOutput, list):
        listOutput = [listOutput]

    else:
        pass

    for ids, connector in nodes["objects"][str(id)]["outputs"]["answer"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = listOutput

    return queue

import random


def random_(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["a"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["a"]["value"]["value"] is not None:
        a = int(nodes["objects"][str(id)]["inputs"]["a"]["value"]["value"])

    else:
        a = int(nodes["objects"][str(id)]["inputs"]["a"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["b"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["b"]["value"]["value"] is not None:
        b = int(nodes["objects"][str(id)]["inputs"]["b"]["value"]["value"])

    else:
        b = int(nodes["objects"][str(id)]["inputs"]["b"]["standard"])

    answer = a if a == b else random.randint(a, b)

    for ids, connector in nodes["objects"][str(id)]["outputs"]["answer"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer

    return queue

def setVar(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["name"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"] is not None:
        name = str(nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"])

    else:
        name = str(nodes["objects"][str(id)]["inputs"]["name"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["global"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["global"]["value"]["value"] is not None:
        gl = nodes["objects"][str(id)]["inputs"]["global"]["value"]["value"]

    else:
        gl = nodes["objects"][str(id)]["inputs"]["global"]["standard"]

    try:
        if nodes["objects"][str(id)]["inputs"]["value"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["value"]["value"]["value"] is not None:
            value = eval(nodes["objects"][str(id)]["inputs"]["value"]["value"]["value"])

        else:
            value = eval(nodes["objects"][str(id)]["inputs"]["value"]["standard"])

    except BaseException:
        if nodes["objects"][str(id)]["inputs"]["value"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["value"]["value"]["value"] is not None:
            value = nodes["objects"][str(id)]["inputs"]["value"]["value"]["value"]

        else:
            value = nodes["objects"][str(id)]["inputs"]["value"]["standard"]

    if gl:
        type = variables["globals"][name]["type"]

    else:
        type = variables["locals"][path][name]["type"]

    if type == "number":
        value = float(value) if float(value) - int(value) != 0 else int(value)

    if gl:
        variables["globals"][name]["value"] = value

    else:
        variables["locals"][path][name]["value"] = value

    return queue

def everyFrame(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    return queue

def everyTick(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    return queue

def forDictElements(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    timer = []
    queue = []

    if nodes["objects"][str(id)]["inputs"]["dict"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["dict"]["value"]["value"] is not None:
        dict_ = dict(nodes["objects"][str(id)]["inputs"]["dict"]["value"]["value"])

    else:
        dict_ = dict(nodes["objects"][str(id)]["inputs"]["dict"]["standard"])

    for key, value in dict_.items():
        for ids, connector in nodes["objects"][str(id)]["outputs"]["key"]["value"].items():
            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = key

        for ids, connector in nodes["objects"][str(id)]["outputs"]["element"]["value"].items():
            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = value

        for name in nodes["objects"][str(id)]["outputs"]["iterator"]["value"].values():
            compiler.queue(name["id"])

    for name in nodes["objects"][str(id)]["outputs"]["after"]["value"].values():
        queue.append(name["id"])

    return {"queue": queue, "timer": timer}

def forListElements(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    timer = []
    queue = []

    if nodes["objects"][str(id)]["inputs"]["list"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"] is not None:
        list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"])

    else:
        list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["standard"])

    for i, element in enumerate(list_):
        for ids, connector in nodes["objects"][str(id)]["outputs"]["index"]["value"].items():
            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = i

        for ids, connector in nodes["objects"][str(id)]["outputs"]["element"]["value"].items():
            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = element

        for name in nodes["objects"][str(id)]["outputs"]["iterator"]["value"].values():
            compiler.queue(name["id"])

    for name in nodes["objects"][str(id)]["outputs"]["after"]["value"].values():
        queue.append(name["id"])

    return {"queue": queue, "timer": timer}

def forObjectsGroup(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    if nodes["objects"][str(id)]["inputs"]["group"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["group"]["value"]["value"] is not None:
        group = str(nodes["objects"][str(id)]["inputs"]["group"]["value"]["value"])

    else:
        group = str(nodes["objects"][str(id)]["inputs"]["group"]["standard"])

    """
    for ids, connector in nodes["objects"][str(id)]["outputs"]["x"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = pos.x
    """

    objects = program.objects.getByGroup(group)
    n = len(objects)

    for i, obj in enumerate(objects):
        for ids, connector in nodes["objects"][str(id)]["outputs"]["id"]["value"].items():
            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = obj.id

        for name in nodes["objects"][str(id)]["outputs"]["iterator"]["value"].values():
            compiler.queue(name["id"])

    for name in nodes["objects"][str(id)]["outputs"]["after"]["value"].values():
        queue.append(name["id"])

    return queue

def for_(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    timer = []
    queue = []

    if nodes["objects"][str(id)]["inputs"]["n"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["n"]["value"]["value"] is not None:
        n = int(float(nodes["objects"][str(id)]["inputs"]["n"]["value"]["value"]))

    else:
        n = int(float(nodes["objects"][str(id)]["inputs"]["n"]["standard"]))

    if nodes["objects"][str(id)]["inputs"]["x"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["x"]["value"]["value"] is not None:
        x = int(float(nodes["objects"][str(id)]["inputs"]["x"]["value"]["value"]))

    else:
        x = int(float(nodes["objects"][str(id)]["inputs"]["x"]["standard"]))

    """
    for ids, connector in nodes["objects"][str(id)]["outputs"]["x"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = pos.x
    """

    if nodes["objects"][str(id)]["inputs"]["n"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["n"]["value"]["value"] is not None:
        nodes["objects"][str(id)]["inputs"]["n"]["value"]["value"] -= 1

    if x == 0:
        for i in range(n):
            for ids, connector in nodes["objects"][str(id)]["outputs"]["index"]["value"].items():
                nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = i

            for name in nodes["objects"][str(id)]["outputs"]["iterator"]["value"].values():
                compiler.queue(name["id"])

    else:
        for name in nodes["objects"][str(id)]["outputs"]["iterator"]["value"].values():
            queue.append(name["id"])

        for ids, connector in nodes["objects"][str(id)]["outputs"]["index"]["value"].items():
            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = 0

        timer.append({"id": id, "count": n - 1, "timer": x, "tmax": x, "connector": "iterator", "iter": 0})

    return {"queue": queue, "timer": timer}

def keyboardClick(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    return queue

def keyboardPress(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    return queue

def mouseLeftClick(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    return queue

def mouseRightClick(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    return queue

def onStartGame(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    return queue

def ifCollision(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
        ids = int(nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"])

    else:
        ids = int(nodes["objects"][str(id)]["inputs"]["id"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["group"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["group"]["value"]["value"] is not None:
        group = nodes["objects"][str(id)]["inputs"]["group"]["value"]["value"]

    else:
        group = nodes["objects"][str(id)]["inputs"]["group"]["standard"]

    if nodes["objects"][str(id)]["inputs"]["append"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["append"]["value"]["value"] is not None:
        append = (nodes["objects"][str(id)]["inputs"]["append"]["value"]["value"] == True)

    else:
        append = (nodes["objects"][str(id)]["inputs"]["append"]["standard"] == True)

    obj = program.objects.getById(ids)

    answer = obj.collisionGetID(0, 0, append, group) if obj is not None else [False, -1]

    if answer[0]:
        for name in nodes["objects"][str(id)]["outputs"]["path_true"]["value"].values():
            queue.append(name["id"])

        for ids, connector in nodes["objects"][str(id)]["outputs"]["id_in_group"]["value"].items():
            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer[1].id

    else:
        for name in nodes["objects"][str(id)]["outputs"]["path_false"]["value"].values():
            queue.append(name["id"])

        for ids, connector in nodes["objects"][str(id)]["outputs"]["id_in_group"]["value"].items():
            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = -1

    return queue

OPERATIONS = ["0. ==", "1. !=", "2. <=", "3. >=", "4. <", "5. >"]


def if_(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    if nodes["objects"][str(id)]["inputs"]["a"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["a"]["value"]["value"] is not None:
        a = nodes["objects"][str(id)]["inputs"]["a"]["value"]["value"]

    else:
        a = nodes["objects"][str(id)]["inputs"]["a"]["standard"]

    if nodes["objects"][str(id)]["inputs"]["b"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["b"]["value"]["value"] is not None:
        b = nodes["objects"][str(id)]["inputs"]["b"]["value"]["value"]

    else:
        b = nodes["objects"][str(id)]["inputs"]["b"]["standard"]

    if nodes["objects"][str(id)]["inputs"]["operation"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["operation"]["value"]["value"] is not None:
        operation = int(nodes["objects"][str(id)]["inputs"]["operation"]["value"]["value"])

    else:
        operation = int(nodes["objects"][str(id)]["inputs"]["operation"]["standard"])

    if eval(f"{a} {OPERATIONS[operation][3:]} {b}"):
        for name in nodes["objects"][str(id)]["outputs"]["path_true"]["value"].values():
            queue.append(name["id"])

    else:
        for name in nodes["objects"][str(id)]["outputs"]["path_false"]["value"].values():
            queue.append(name["id"])

    return queue

import math


def divide(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["a"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["a"]["value"]["value"] is not None:
        a = float(nodes["objects"][str(id)]["inputs"]["a"]["value"]["value"])

    else:
        a = float(nodes["objects"][str(id)]["inputs"]["a"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["b"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["b"]["value"]["value"] is not None:
        b = float(nodes["objects"][str(id)]["inputs"]["b"]["value"]["value"])

    else:
        b = float(nodes["objects"][str(id)]["inputs"]["b"]["standard"])

    answer = int(a // b) if math.trunc(round(a / b, 10)) == math.ceil(round(a / b, 10)) else round(a / b, 10)

    for ids, connector in nodes["objects"][str(id)]["outputs"]["answer"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer

    return queue

import math


def minus(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["a"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["a"]["value"]["value"] is not None:
        a = float(nodes["objects"][str(id)]["inputs"]["a"]["value"]["value"])

    else:
        a = float(nodes["objects"][str(id)]["inputs"]["a"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["b"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["b"]["value"]["value"] is not None:
        b = float(nodes["objects"][str(id)]["inputs"]["b"]["value"]["value"])

    else:
        b = float(nodes["objects"][str(id)]["inputs"]["b"]["standard"])

    answer = int(a - b) if math.trunc(round(a - b, 10)) == math.ceil(round(a - b, 10)) else round(a - b, 10)

    for ids, connector in nodes["objects"][str(id)]["outputs"]["answer"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer

    return queue

import math


def multiply(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["a"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["a"]["value"]["value"] is not None:
        a = float(nodes["objects"][str(id)]["inputs"]["a"]["value"]["value"])

    else:
        a = float(nodes["objects"][str(id)]["inputs"]["a"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["b"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["b"]["value"]["value"] is not None:
        b = float(nodes["objects"][str(id)]["inputs"]["b"]["value"]["value"])

    else:
        b = float(nodes["objects"][str(id)]["inputs"]["b"]["standard"])

    answer = int(a * b) if math.trunc(round(a * b, 10)) == math.ceil(round(a * b, 10)) else round(a * b, 10)

    for ids, connector in nodes["objects"][str(id)]["outputs"]["answer"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer

    return queue

import math


def plus(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["a"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["a"]["value"]["value"] is not None:
        a = float(nodes["objects"][str(id)]["inputs"]["a"]["value"]["value"])

    else:
        a = float(nodes["objects"][str(id)]["inputs"]["a"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["b"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["b"]["value"]["value"] is not None:
        b = float(nodes["objects"][str(id)]["inputs"]["b"]["value"]["value"])

    else:
        b = float(nodes["objects"][str(id)]["inputs"]["b"]["standard"])

    answer = int(a + b) if math.trunc(round(a + b, 10)) == math.ceil(round(a + b, 10)) else round(a + b, 10)

    for ids, connector in nodes["objects"][str(id)]["outputs"]["answer"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer

    return queue

def createObject(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["name"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"] is not None:
        name = str(nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"])

    else:
        name = str(nodes["objects"][str(id)]["inputs"]["name"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["x"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["x"]["value"]["value"] is not None:
        x = float(nodes["objects"][str(id)]["inputs"]["x"]["value"]["value"])

    else:
        x = float(nodes["objects"][str(id)]["inputs"]["x"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["y"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["y"]["value"]["value"] is not None:
        y = float(nodes["objects"][str(id)]["inputs"]["y"]["value"]["value"])

    else:
        y = float(nodes["objects"][str(id)]["inputs"]["y"]["standard"])

    if not name.endswith(".obj"):
        name += ".obj"

    type = program.allObjects[name]["type"]
    variables = program.allObjects[name]["variables"]

    variables["pos"] = [x, y]

    obj = getattr(program.linkEngine.objects, type)(program, **variables)

    # print(obj.pos, obj.hitbox, len(program.objects.objects), variables)

    program.objects.add(obj)

    for ids, connector in nodes["objects"][str(id)]["outputs"]["id"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = obj.id

    return queue

def getObjectIDByName(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["name"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"] is not None:
        name = str(nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"])

    else:
        name = str(nodes["objects"][str(id)]["inputs"]["name"]["standard"])

    answer = program.objectIDByName[program.scene][name] if name in program.objectIDByName[program.scene] else -1

    for ids, connector in nodes["objects"][str(id)]["outputs"]["id"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer

    return queue

OBJECT_PARAMETERS = ["hitbox", "group", "mass", "layer", "invisible", "speed", "gravity", "jumpPower", "slidingStep", "message", "fontSize", "fontColor", "alignment"]


def getObjectParameter(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
        ids = int(nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"])

    else:
        ids = int(nodes["objects"][str(id)]["inputs"]["id"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["name"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"] is not None:
        operation = int(nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"])

    else:
        operation = int(nodes["objects"][str(id)]["inputs"]["name"]["standard"])

    answer = program.objects.getById(ids).getParameter(OBJECT_PARAMETERS[operation])

    for ids, connector in nodes["objects"][str(id)]["outputs"]["value"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer

    return queue

def getObjectPos(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
        ids = int(nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"])

    else:
        ids = int(nodes["objects"][str(id)]["inputs"]["id"]["standard"])

    pos = program.objects.getById(ids).pos

    for ids, connector in nodes["objects"][str(id)]["outputs"]["x"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = pos.x

    for ids, connector in nodes["objects"][str(id)]["outputs"]["y"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = pos.y

    return queue

def getObjectVar(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["name"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"] is not None:
        name = str(nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"])

    else:
        name = str(nodes["objects"][str(id)]["inputs"]["name"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
        ids = nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"]

    else:
        ids = nodes["objects"][str(id)]["inputs"]["id"]["standard"]

    answer = variables["objects"][program.scene][program.objectNameByID[program.scene][str(ids)]][name]["value"]

    for ids, connector in nodes["objects"][str(id)]["outputs"]["answer"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer

    return queue

def getResultingVector(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
        ids = int(nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"])

    else:
        ids = int(nodes["objects"][str(id)]["inputs"]["id"]["standard"])

    pos = program.objects.getById(ids).getVectorsPower()

    for ids, connector in nodes["objects"][str(id)]["outputs"]["x"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = pos.x

    for ids, connector in nodes["objects"][str(id)]["outputs"]["y"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = pos.y

    return queue

def jump(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
        ids = str(nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"])

    else:
        ids = str(nodes["objects"][str(id)]["inputs"]["id"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["power"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["power"]["value"]["value"] is not None:
        power = float(nodes["objects"][str(id)]["inputs"]["power"]["value"]["value"])

    else:
        power = float(nodes["objects"][str(id)]["inputs"]["power"]["standard"])

    obj = program.objects.getById(int(ids))

    obj.vectors["__fall__"].power = -power

    return queue

def moveObject(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
        ids = str(nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"])

    else:
        ids = str(nodes["objects"][str(id)]["inputs"]["id"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["angle"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["angle"]["value"]["value"] is not None:
        angle = float(nodes["objects"][str(id)]["inputs"]["angle"]["value"]["value"])

    else:
        angle = float(nodes["objects"][str(id)]["inputs"]["angle"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["power"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["power"]["value"]["value"] is not None:
        power = float(nodes["objects"][str(id)]["inputs"]["power"]["value"]["value"])

    else:
        power = float(nodes["objects"][str(id)]["inputs"]["power"]["standard"])

    obj = program.objects.getById(int(ids))

    obj.moveByAngle(angle, power, specifical=id)

    return queue

def removeObject(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
        ids = int(nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"])

    else:
        ids = int(nodes["objects"][str(id)]["inputs"]["id"]["standard"])

    program.objects.removeById(ids)

    return queue

import typing

OBJECT_PARAMETERS = ["hitbox", "group", "mass", "layer", "invisible", "speed", "gravity", "jumpPower", "slidingStep", "message", "fontSize", "fontColor", "alignment"]
OBJECT_PARAMETERS_TYPES = ["list", "text", "int", "int", "logic", "float", "float", "float", "float", "text", "int", "text", "list"]


def setObjectParameter(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    def decode(operation, text: str) -> typing.Any:
        if OBJECT_PARAMETERS_TYPES[operation] == "list":
            return eval(text)

        if OBJECT_PARAMETERS_TYPES[operation] == "text":
            return text

        if OBJECT_PARAMETERS_TYPES[operation] == "int":
            return int(text)

        if OBJECT_PARAMETERS_TYPES[operation] == "float":
            return float(text)

        if OBJECT_PARAMETERS_TYPES[operation] == "logic":
            return True if text in ("True", "true", "1", "+") else False

    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
        ids = int(nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"])

    else:
        ids = int(nodes["objects"][str(id)]["inputs"]["id"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["name"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"] is not None:
        operation = int(nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"])

    else:
        operation = int(nodes["objects"][str(id)]["inputs"]["name"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["value"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["value"]["value"]["value"] is not None:
        value = decode(operation, nodes["objects"][str(id)]["inputs"]["value"]["value"]["value"])

    else:
        value = decode(operation, nodes["objects"][str(id)]["inputs"]["value"]["standard"])

    print(OBJECT_PARAMETERS[operation], value)

    program.objects.getById(ids).setParameter(OBJECT_PARAMETERS[operation], value)

    return queue

def setObjectPos(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
        ids = str(nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"])

    else:
        ids = str(nodes["objects"][str(id)]["inputs"]["id"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["x"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["x"]["value"]["value"] is not None:
        x = float(nodes["objects"][str(id)]["inputs"]["x"]["value"]["value"])

    else:
        x = float(nodes["objects"][str(id)]["inputs"]["x"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["y"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["y"]["value"]["value"] is not None:
        y = float(nodes["objects"][str(id)]["inputs"]["y"]["value"]["value"])

    else:
        y = float(nodes["objects"][str(id)]["inputs"]["y"]["standard"])

    obj = program.objects.getById(int(ids))

    obj.pos.x = x
    obj.pos.y = y

    return queue

def setObjectVar(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["name"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"] is not None:
        name = str(nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"])

    else:
        name = str(nodes["objects"][str(id)]["inputs"]["name"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
        ids = nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"]

    else:
        ids = nodes["objects"][str(id)]["inputs"]["id"]["standard"]

    if nodes["objects"][str(id)]["inputs"]["value"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["value"]["value"]["value"] is not None:
        value = nodes["objects"][str(id)]["inputs"]["value"]["value"]["value"]

    else:
        value = nodes["objects"][str(id)]["inputs"]["value"]["standard"]

    type = variables["objects"][program.scene][program.objectNameByID[program.scene][str(ids)]][name]["type"]

    if type == "number":
        value = float(value)

    variables["objects"][program.scene][program.objectNameByID[program.scene][str(ids)]][name]["value"] = value

    return queue

def addDictElement(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["dict"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["dict"]["value"]["value"] is not None:
        dict_ = dict(nodes["objects"][str(id)]["inputs"]["dict"]["value"]["value"])

    else:
        dict_ = dict(nodes["objects"][str(id)]["inputs"]["dict"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["key"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["key"]["value"]["value"] is not None:
        key = str(nodes["objects"][str(id)]["inputs"]["key"]["value"]["value"])

    else:
        key = str(nodes["objects"][str(id)]["inputs"]["key"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["element"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"] is not None:
        element = eval(nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"])

    else:
        element = eval(nodes["objects"][str(id)]["inputs"]["element"]["standard"])

    dict_[key] = element

    for ids, connector in nodes["objects"][str(id)]["outputs"]["dict"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = dict_

    return queue

def addListElement(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["list"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"] is not None:
        list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"])

    else:
        list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["element"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"] is not None:
        if type(nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"]) == str:
            element = eval(nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"])

        else:
            element = eval(str(nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"]))

    else:
        if type(nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"]) == str:
            element = eval(nodes["objects"][str(id)]["inputs"]["element"]["standard"])

        else:
            element = eval(str(nodes["objects"][str(id)]["inputs"]["element"]["standard"]))

    list_.append(element)

    for ids, connector in nodes["objects"][str(id)]["outputs"]["list"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = list_

    return queue

def deleteByIndex(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["list"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"] is not None:
        list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"])

    else:
        list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["index"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["index"]["value"]["value"] is not None:
        index = int(nodes["objects"][str(id)]["inputs"]["index"]["value"]["value"])

    else:
        index = int(nodes["objects"][str(id)]["inputs"]["index"]["standard"])

    list_.pop(index)

    for ids, connector in nodes["objects"][str(id)]["outputs"]["list"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = list_

    return queue

def getByIndex(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["list"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"] is not None:
        list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"])

    else:
        list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["index"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["index"]["value"]["value"] is not None:
        index = int(nodes["objects"][str(id)]["inputs"]["index"]["value"]["value"])

    else:
        index = int(nodes["objects"][str(id)]["inputs"]["index"]["standard"])

    answer = list_[index]

    for ids, connector in nodes["objects"][str(id)]["outputs"]["element"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer

    return queue

def getByKey(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["dict"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["dict"]["value"]["value"] is not None:
        dict_ = dict(nodes["objects"][str(id)]["inputs"]["dict"]["value"]["value"])

    else:
        dict_ = dict(nodes["objects"][str(id)]["inputs"]["dict"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["key"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["key"]["value"]["value"] is not None:
        key = str(nodes["objects"][str(id)]["inputs"]["key"]["value"]["value"])

    else:
        key = str(nodes["objects"][str(id)]["inputs"]["key"]["standard"])

    answer = dict_[key]

    for ids, connector in nodes["objects"][str(id)]["outputs"]["element"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer

    return queue

def getIndexOfElement(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["list"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"] is not None:
        list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"])

    else:
        list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["element"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"] is not None:
        element = str(nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"])

    else:
        element = str(nodes["objects"][str(id)]["inputs"]["element"]["standard"])

    answer = -1

    for index, elem in enumerate(list_):
        if str(elem) == str(element):
            answer = index

            break

    for ids, connector in nodes["objects"][str(id)]["outputs"]["index"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer

    return queue

def getKeyOfElement(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["dict"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["dict"]["value"]["value"] is not None:
        dict_ = dict(nodes["objects"][str(id)]["inputs"]["dict"]["value"]["value"])

    else:
        dict_ = dict(nodes["objects"][str(id)]["inputs"]["dict"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["element"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"] is not None:
        element = str(nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"])

    else:
        element = str(nodes["objects"][str(id)]["inputs"]["element"]["standard"])

    answer = "NULL"

    for key, value in dict_.items():
        if str(value) == str(element):
            answer = key

            break

    for ids, connector in nodes["objects"][str(id)]["outputs"]["key"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer

    return queue

def removeByKey(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["dict"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["dict"]["value"]["value"] is not None:
        dict_ = dict(nodes["objects"][str(id)]["inputs"]["dict"]["value"]["value"])

    else:
        dict_ = dict(nodes["objects"][str(id)]["inputs"]["dict"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["key"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["key"]["value"]["value"] is not None:
        key = str(nodes["objects"][str(id)]["inputs"]["key"]["value"]["value"])

    else:
        key = str(nodes["objects"][str(id)]["inputs"]["key"]["standard"])

    if key in dict_:
        dict_.pop(key)

    for ids, connector in nodes["objects"][str(id)]["outputs"]["dict"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = dict_

    return queue

def sliceList(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["list"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"] is not None:
        list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"])

    else:
        list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["start"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["start"]["value"]["value"] is not None:
        start = int(nodes["objects"][str(id)]["inputs"]["start"]["value"]["value"])

    else:
        start = int(nodes["objects"][str(id)]["inputs"]["start"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["end"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["end"]["value"]["value"] is not None:
        end = int(nodes["objects"][str(id)]["inputs"]["end"]["value"]["value"])

    else:
        end = int(nodes["objects"][str(id)]["inputs"]["end"]["standard"])

    answer = list_[start:(None if end == -1 else end + 1)]

    for ids, connector in nodes["objects"][str(id)]["outputs"]["list"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer

    return queue

def connectText(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["text1"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["text1"]["value"]["value"] is not None:
        text1 = str(nodes["objects"][str(id)]["inputs"]["text1"]["value"]["value"])

    else:
        text1 = str(nodes["objects"][str(id)]["inputs"]["text1"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["text2"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["text2"]["value"]["value"] is not None:
        text2 = str(nodes["objects"][str(id)]["inputs"]["text2"]["value"]["value"])

    else:
        text2 = str(nodes["objects"][str(id)]["inputs"]["text2"]["standard"])

    answer = text1 + text2

    for ids, connector in nodes["objects"][str(id)]["outputs"]["text"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer

    return queue

def displayText(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["text"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["text"]["value"]["value"] is not None:
        text = str(nodes["objects"][str(id)]["inputs"]["text"]["value"]["value"])

    else:
        text = str(nodes["objects"][str(id)]["inputs"]["text"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["x"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["x"]["value"]["value"] is not None:
        x = int(nodes["objects"][str(id)]["inputs"]["x"]["value"]["value"])

    else:
        x = int(nodes["objects"][str(id)]["inputs"]["x"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["y"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["y"]["value"]["value"] is not None:
        y = int(nodes["objects"][str(id)]["inputs"]["y"]["value"]["value"])

    else:
        y = int(nodes["objects"][str(id)]["inputs"]["y"]["standard"])

    program.afterDrawing.append(lambda: program.linkEngine.print_text(program.screen, x, y, text))

    return queue

def sliceText(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["text"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["text"]["value"]["value"] is not None:
        text = str(nodes["objects"][str(id)]["inputs"]["text"]["value"]["value"])

    else:
        text = str(nodes["objects"][str(id)]["inputs"]["text"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["start"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["start"]["value"]["value"] is not None:
        start = int(nodes["objects"][str(id)]["inputs"]["start"]["value"]["value"])

    else:
        start = int(nodes["objects"][str(id)]["inputs"]["start"]["standard"])

    if nodes["objects"][str(id)]["inputs"]["end"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["end"]["value"]["value"] is not None:
        end = int(nodes["objects"][str(id)]["inputs"]["end"]["value"]["value"])

    else:
        end = int(nodes["objects"][str(id)]["inputs"]["end"]["standard"])

    answer = text[start:(None if end == -1 else end + 1)]

    for ids, connector in nodes["objects"][str(id)]["outputs"]["text"]["value"].items():
        nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer

    return queue

def writeText(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
    queue = []

    for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
        queue.append(name["id"])

    if nodes["objects"][str(id)]["inputs"]["text"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["text"]["value"]["value"] is not None:
        text = str(nodes["objects"][str(id)]["inputs"]["text"]["value"]["value"])

    else:
        text = str(nodes["objects"][str(id)]["inputs"]["text"]["standard"])

    line = True

    answer = ">>> " + text.rstrip() + "\n" if line else ">>> " + text.rstrip()

    program.print(answer)

    print(answer)

    return queue

