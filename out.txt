
##### engine\application.py #####
1     from engine.classes.getUsingObjects import GetUsingObjects
2     
3     from PIL import Image
4     
5     from engine.variables import *
6     
7     import engine
8     import pygame
9     import typing
10     import ctypes
11    import sys
12    import os
13    
14    os.environ["SDL_VIDEO_CENTERED"] = "1"
15    
16    try:
17        ctypes.windll.shcore.SetProcessDpiAwareness(True)
18    
19    except AttributeError:
20        pass
21    
22    pygame.init()
23    
24    
25    class Application:
26        def __init__(
27            self, usingWidth: int = 700, usingHeight: int = 700, displayWidth: int = 700, displayHeight: int = 700,
28            fps: int = 60, tps: int = 20, name: str = "GE3 project", icon: str = "", flags: typing.Dict[str, typing.Any] = None,
29            variables: typing.Dict[str, typing.Any] = None, visiable: bool = True, debug: bool = False,
30            autoUpdateScreen: bool = True, collision: str = "", forcedViewObject: bool = False
31        ) -> None:
32            if flags is None:
33                flags = {}
34    
35            if variables is None:
36                variables = {}
37    
38            self.particles = engine.ParticleGroup(self)
39            self.objects = engine.ObjectGroup(self)
40    
41            self.objects.collisions = engine.Collision(collision)
42    
43            self.camera = engine.camera.StaticCamera(self, 0, 0)
44    
45            self.functions = None
46    
47            self.debug = debug
48    
49            self.autoUpdateScreen = autoUpdateScreen
50            self.forcedViewObject = forcedViewObject
51    
52            self.usingWidth = usingWidth
53            self.usingHeight = usingHeight
54    
55            self.displayWidth = displayWidth
56            self.displayHeight = displayHeight
57    
58            self.fps = fps
59            self.tps = tps
60    
61            self.mouse = pygame.mouse.get_pos()
62            self.click = [0, 0, 0, 0, 0]
63    
64            self.name = name
65            self.icon = icon
66    
67            self.cash = {
68                "collisions": {},
69                "object_sorted_by_distance": []
70            }
71    
72            self.focus = None
73    
74            self.variables = variables
75            self.flags = flags
76    
77            self.fpsc = 0
78    
79            self.events = {
80                "PRESS": {}
81            }
82    
83            self.doCollisionsUpdate = False
84    
85            self.surface = None
86    
87            self.screen = None
88            self.clock = None
89    
90            self.play = True
91    
92            self.visiable = visiable
93    
94            self.lastDrawing = []
95            self.afterDrawing = []
96    
97            self.capacity = 0
98    
99            self.init()
100    
101       def init(self) -> None:
102           if self.visiable:
103               self.surface = pygame.display.set_mode((self.displayWidth, self.displayHeight))
104   
105           else:
106               self.surface = pygame.display.set_mode((self.displayWidth, self.displayHeight), pygame.HIDDEN)
107   
108           self.screen = pygame.Surface((self.usingWidth, self.usingHeight))
109           self.clock = pygame.time.Clock()
110   
111       def setName(self, name: str) -> None:
112           self.name = name
113   
114       def setIcon(self, icon: str) -> None:
115           self.icon = icon
116   
117       def updateCaption(self) -> None:
118           pygame.display.set_caption(self.name, self.icon)
119   
120       def updateCustonCaption(self, text: str) -> None:
121           pygame.display.set_caption(text)
122   
123       def setDebug(self, debug: bool) -> None:
124           self.debug = debug
125   
126       def setFps(self, fps: int) -> None:
127           self.fps = fps
128   
129       def setTps(self, tps: int) -> None:
130           self.tps = tps
131   
132       def setSize(self, width: int = None, height: int = None) -> None:
133           self.setDisplaySize(width, height)
134           self.setUsingSize(width, height)
135   
136           self.init()
137   
138       def setUsingSize(self, width: int = None, height: int = None) -> None:
139           self.usingWidth = width if width is not None else self.usingWidth
140           self.usingHeight = height if height is not None else self.usingHeight
141   
142           self.init()
143   
144       def setDisplaySize(self, width: int = None, height: int = None) -> None:
145           self.displayWidth = width if width is not None else self.displayWidth
146           self.displayHeight = height if height is not None else self.displayHeight
147   
148           self.init()
149   
150       def setCamera(self, cameraClass: VCamera) -> None:
151           self.camera = cameraClass
152   
153       def setFunctionClass(self, functionClass) -> None:
154           self.functions = functionClass
155   
156       def setKeyEvent(self, event: typing.List[str], func: typing.Callable) -> None:
157           # setKeyEvent(["KEYDOWN", "r"], self.place)
158   
159           try:
160               event[0] = getattr(pygame, event[0])
161               event[1] = getattr(pygame, "K_" + event[1])
162   
163           except AttributeError:
164               event[0] = event[0]
165   
166               try:
167                   event[1] = getattr(pygame, "K_" + event[1])
168   
169               except AttributeError:
170                   event[1] = getattr(pygame, "K_" + event[1].upper())
171   
172           if event[0] not in self.events:
173               self.events[event[0]] = {}
174   
175           if event[1] not in self.events[event[0]]:
176               self.events[event[0]][event[1]] = []
177   
178           self.events[event[0]][event[1]].append(func)
179   
180       def setMouseEvent(self, mouse: int, func: typing.Callable) -> None:
181           if f"MOUSE_{mouse}" not in self.events:
182               self.events[f"MOUSE_{mouse}"] = []
183   
184           self.events[f"MOUSE_{mouse}"].append(func)
185   
186       def getScreenImage(self):
187           return Image.frombytes("RGBA", self.screen.get_size(), pygame.image.tostring(self.screen, "RGBA"))
188   
189       def render(self) -> None:
190           self.particles.draw()
191           self.objects.draw()
192   
193       def update(self) -> None:
194           self.doCollisionsUpdate = True
195   
196           self.mouse = pygame.mouse.get_pos()
197   
198           self.camera.update()
199   
200           self.particles.update()
201           self.objects.update()
202   
203           self.click = [0] * 5
204   
205           # if self.debug:
206           #     pygame.display.set_caption(str(round(self.clock.get_fps())))
207   
208           if self.doCollisionsUpdate:
209               engine.classes.getUsingObjects.GetUsingObjects.getUsingObjectsSquare(self, self.objects)
210   
211       def logic(self) -> None:
212           for event in pygame.event.get():
213               if event.type == pygame.QUIT:
214                   self.play = False
215   
216               if event.type in self.events:
217                   if event.key in self.events[event.type]:
218                       for func in self.events[event.type][event.key]:
219                           func()
220   
221                   else:
222                       pass
223   
224               if event.type == pygame.MOUSEBUTTONUP:
225                   self.click[event.button - 1] = True
226   
227           keys = pygame.key.get_pressed()
228   
229           for key, value in self.events.get("PRESS").items():
230               if keys[key]:
231                   for element in value:
232                       element()
233   
234           for i, element in enumerate(self.click):
235               if element and f"MOUSE_{i}" in self.events:
236                   for event in self.events[f"MOUSE_{i}"]:
237                       event()
238   
239       def frame(
240           self, image: bool = False, screenFillColor: typing.Any = None,
241           lastDrawing: typing.List[typing.Union[typing.List[typing.Any], typing.Callable]] = None,
242           afterDrawing: typing.List[typing.Union[typing.List[typing.Any], typing.Callable]] = None
243       ) -> typing.Union[Image.Image, None]:
244           if lastDrawing is None:
245               lastDrawing = self.lastDrawing
246   
247           if afterDrawing is None:
248               afterDrawing = self.afterDrawing
249   
250           self.logic()
251   
252           self.update()
253   
254           self.screen.fill((0, 0, 0) if screenFillColor is None else screenFillColor)
255   
256           for element in lastDrawing:
257               if type(element) == list:
258                   getattr(pygame.draw, element[0])(*element[1])
259   
260               else:
261                   element()
262   
263           self.render()
264   
265           for element in afterDrawing:
266               if type(element) == list:
267                   getattr(pygame.draw, element[0])(*element[1])
268   
269               else:
270                   element()
271   
272           if self.displayWidth == self.usingWidth and self.displayHeight == self.usingHeight:
273               self.surface.blit(self.screen, (0, 0))
274   
275           else:
276               self.surface.blit(pygame.transform.scale(self.screen, (self.displayWidth, self.displayHeight)), (0, 0))
277   
278           if self.autoUpdateScreen:
279               pygame.display.update()
280   
281           self.fpsc += 1
282   
283           self.capacity = self.clock.tick(self.fps)
284   
285           self.lastDrawing = []
286           self.afterDrawing = []
287   
288           if image:
289               return self.getScreenImage()
290   
291           return
292   
293       def start(self) -> None:
294           pygame.display.set_caption(self.name, self.icon)
295   
296           while self.play:
297               self.frame()
298   
299           pygame.quit()
300   
301           sys.exit()
302   
303       def exit(self) -> None:
304           self.play = False
305   
##### engine\classes\animation.py #####
1     from engine.classes.sprite import Sprite
2     
3     from engine.functions.loads import loadAnimationFile
4     
5     from engine.vector.float import Vec2f
6     
7     from engine.variables import *
8     
9     import typing
10     import pygame
11    
12    RIGHT = "1 0"
13    LEFT = "-1 0"
14    UP = "0 -1"
15    DOWN = "0 1"
16    
17    RIGHT_UP = "1 -1"
18    RIGHT_DOWN = "1 1"
19    LEFT_UP = "-1 -1"
20    LEFT_DOWN = "-1 1"
21    
22    NULL = "0 0"
23    
24    
25    class Animation:
26        def __init__(self, game, path: str, animations: typing.Dict[str, typing.List[str]], canWasMirrored: bool = True) -> None:
27            self.game = game
28    
29            self.focus, self.settings = loadAnimationFile(path)
30            self.animations = animations
31    
32            self.width = 0
33            self.height = 0
34    
35            self.pos = Vec2f(0, 0)
36    
37            self.canWasMirrored = canWasMirrored
38            self.wasMirrored = False
39    
40            self.init()
41    
42        def init(self) -> None:
43            for key, value in self.animations.items():
44                for i, element in enumerate(value):
45                    self.animations[key][i] = Sprite(self.game, element)
46    
47                    self.width = max(self.width, self.animations[key][i].width)
48                    self.height = max(self.height, self.animations[key][i].height)
49    
50        def get(self, obj: "VObject") -> pygame.sprite.Sprite:
51            pos = obj.getVectorsPower()
52    
53            direction = [
54                0 if pos.x == 0 else (1 if pos.x > 0 else -1),
55                0 if pos.y == 0 else (1 if pos.y > 0 else -1)
56            ]
57    
58            if abs(pos.x) > FLOAT_PRECISION and self.canWasMirrored:
59                if pos.x > FLOAT_PRECISION:
60                    self.wasMirrored = False
61    
62                if pos.x < FLOAT_PRECISION:
63                    self.wasMirrored = True
64    
65            else:
66                pass
67    
68            direction = " ".join(list(map(str, direction)))
69    
70            for element in self.settings:
71                if eval(element[0]):
72                    animation = element[1].replace("animation(", "").replace(")", "")
73                    break
74    
75            else:
76                animation = "idle"
77    
78            return pygame.transform.flip(
79                self.animations[animation][(self.game.fpsc // (self.game.fps // len(self.animations[animation]))) % len(self.animations[animation])].get(),
80                self.wasMirrored if obj.id == self.game.focus or self.focus else False, False
81            )
82    
##### engine\classes\animator.py #####
1     from engine.classes.sprite import Sprite
2     from engine.variables import *
3     import typing
4     
5     
6     class Animator:
7         def __init__(self, game, obj: "VObject", data: typing.Dict[str, typing.Any]) -> None:
8             self.game = game
9             self.obj = obj
10     
11            self.groups = {}
12    
13            self.horizontal = False
14            self.vertical = False
15    
16            self.standardSprite = None
17            self.standardGroup = None
18    
19            self.data = data
20    
21            self.animation = None
22    
23        def init(self):
24            self.standardSprite = self.obj.sprite.copy() if self.obj.sprite is not None else None
25            self.standardGroup = None
26    
27            for name, group in self.data["groups"].items():
28                self.groups[name] = {
29                    "settings": group["settings"],
30                    "sprites": group["sprites"],
31    
32                    "nowSprite": 0,
33                    "fpsc": 0
34                }
35                self.groups[name]["settings"]["fpsPerFrame"] = int(self.groups[name]["settings"]["fpsPerFrame"])
36    
37                if group["settings"]["standard"]:
38                    self.standardGroup = name
39    
40            self.animation = self.standardGroup
41    
42            self.updateSpriteAnimation()
43    
44        def updateSpriteAnimation(self):
45            if self.animation is None:
46                return
47    
48            group = self.groups[self.animation]
49    
50            data = group["sprites"][group["nowSprite"]]
51    
52            self.obj.sprite = Sprite(self.game, self.obj, data, *self.obj.sprite.pos.get(), *self.obj.sprite.size.get())
53    
54            self.obj.sprite.flip(self.horizontal, self.vertical)
55    
56        def setAnimation(self, value):
57            if self.animation == value:
58                return
59    
60            self.animation = value
61    
62            if self.animation is not None:
63                self.groups[self.animation]["nowSprite"] = 0
64                self.groups[self.animation]["fpsc"] = 0
65    
66                self.updateSpriteAnimation()
67    
68            else:
69                self.obj.sprite = self.standardSprite.copy() if self.standardSprite is not None else None
70    
71                if self.obj.sprite is not None:
72                    self.obj.sprite.flip(self.horizontal, self.vertical)
73    
74        def runAnimation(self, animation):
75            self.setAnimation(animation)
76    
77        def flipAnimation(self, horizontal, vertical):
78            self.horizontal = horizontal
79            self.vertical = vertical
80    
81        def stopAnimation(self):
82            self.setAnimation(self.standardGroup)
83    
84        def update(self) -> None:
85            if self.animation is None:
86                if self.obj.sprite != self.standardSprite:
87                    self.obj.sprite = self.standardSprite.copy() if self.standardSprite is not None else None
88    
89                    if self.obj.sprite is not None:
90                        self.obj.sprite.flip(self.horizontal, self.vertical)
91    
92                return
93    
94            group = self.groups[self.animation]
95            group["fpsc"] += 1
96    
97            if group["fpsc"] >= group["settings"]["fpsPerFrame"]:
98                max_sprite = len(group["sprites"]) - 1
99    
100                if group["nowSprite"] < max_sprite:
101                   group["nowSprite"] += 1
102   
103               elif group["settings"]["repeat"]:
104                   group["nowSprite"] = 0
105   
106               else:
107                   pass
108   
109               self.updateSpriteAnimation()
110   
111               group["fpsc"] = 0
112   
##### engine\classes\camera.py #####
1     from engine.vector.float import Vec2f
2     
3     from engine.variables import *
4     
5     import math
6     
7     
8     class StaticCamera:
9         def __init__(self, game, x: float, y: float) -> None:
10             self.game = game
11    
12            self.pos = Vec2f(x, y)
13    
14        def __str__(self) -> None:
15            return f"StaticCamera(pos = {self.pos})"
16    
17        def update(self, x: float = None, y: float = None) -> None:
18            self.pos.x = x if x is not None else self.pos.x
19            self.pos.y = y if y is not None else self.pos.y
20    
21        def get(self) -> Vec2f:
22            return self.pos
23    
24        def x(self) -> float:
25            return -self.pos.x
26    
27        def y(self) -> float:
28            return self.pos.y
29    
30    
31    class FocusCamera(StaticCamera):
32        def __init__(self, game, obj: VObject) -> None:
33            StaticCamera.__init__(self, game, 0, 0)
34    
35            self.obj = obj
36    
37            self.update()
38    
39        def __str__(self):
40            return f"FocusCamera(object = {self.obj})"
41    
42        def setFocus(self, obj: VObject):
43            self.obj = obj
44    
45            self.update()
46    
47        def update(self, *args, **kwargs) -> None:
48            # print(self)
49    
50            super().update(
51                self.obj.pos.x + self.obj.hitbox.x + self.obj.hitbox.width // 2 - self.game.usingWidth // 2,
52                -(self.obj.pos.y + self.obj.hitbox.y + self.obj.hitbox.height // 2 - self.game.usingHeight // 2)
53            )
54    
55        def get(self) -> VObject:
56            return self.obj
57    
58    
59    class SmoothingCamera(FocusCamera):
60        pass
61    
##### engine\classes\collision.py #####
1     from engine.functions.loads import loadCollisionFile
2     
3     from engine.functions.cache import cache
4     
5     import pygame
6     
7     
8     class Collision:
9         @staticmethod
10         def rect(x1: float, y1: float, w1: float, h1: float, x2: float, y2: float, w2: float, h2: float) -> bool:
11            return pygame.Rect(x1, y1, w1, h1).colliderect(pygame.Rect(x2, y2, w2, h2))
12    
13        @cache
14        def get(self, group: str) -> dict:
15            out = {}
16    
17            if "Any" in self.collision:
18                for key, value in self.collision["Any"].items():
19                    out[key] = value
20    
21            if group in self.collision:
22                for key, value in self.collision[group].items():
23                    out[key] = value
24    
25            return out
26    
27        def __init__(self, path: str = "") -> None:
28            if path == "":
29                self.collision = {}
30    
31            else:
32                self.collision = loadCollisionFile(path)
33    
##### engine\classes\getUsingObjects.pyx #####
1     from engine.classes.collision import Collision
2     from engine.classes.objects import DynamicObject
3     from engine.variables import *
4     
5     import typing
6     
7     
8     if typing.TYPE_CHECKING:
9         from engine.classes.group import ObjectGroup
10     
11    else:
12        pass
13    
14    
15    cdef class GetUsingObjects:
16        @staticmethod
17        def getUsingObjectsBase(game, group) -> None:
18            dynamics = [obj for obj in group.objects if type(obj) == DynamicObject]
19    
20            for obj in dynamics:
21                GetUsingObjects.getUsingObjectsIteration(game, group.objects, obj)
22    
23        @staticmethod
24        def getUsingObjectsCircle(game, group) -> None:
25            def binaryLeft(objects, distance: float) -> int:
26                cdef int left = 0
27                cdef int right = len(objects) - 1
28                cdef int mid
29    
30                while left < right:
31                    mid = (left + right) // 2
32                    if objects[mid].distance < distance:
33                        left = mid + 1
34    
35                    else:
36                        right = mid
37    
38                return left if objects[left].distance >= distance else 0
39    
40            def binaryRight(objects, distance: float) -> int:
41                cdef int left = 0
42                cdef int right = len(objects) - 1
43                cdef int mid
44    
45                while left < right:
46                    mid = (left + right + 1) // 2
47                    if objects[mid].distance > distance:
48                        right = mid - 1
49    
50                    else:
51                        left = mid
52    
53                return right if objects[right].distance <= distance else len(objects) - 1
54    
55            cdef list dynamicsObjects = []
56    
57            for obj in group.objects:
58                if type(obj) == DynamicObject:
59                    dynamicsObjects.append(obj)
60    
61            game.cash["object_sorted_by_distance"] = sorted(group.objects, key=lambda obj: obj.distance)
62    
63            for obj in dynamicsObjects:
64                l = binaryLeft(game.cash["object_sorted_by_distance"], obj.distance - group.maxLenghtObject)
65                r = binaryRight(game.cash["object_sorted_by_distance"], obj.distance + group.maxLenghtObject) + 1
66    
67                GetUsingObjects.getUsingObjectsIteration(game, game.cash["object_sorted_by_distance"][l:r], obj)
68    
69        @staticmethod
70        def getUsingObjectsSquare(game, group) -> None:
71            def binaryLeft(objects, x: float) -> int:
72                cdef int left = 0
73                cdef int right = len(objects) - 1
74                cdef int mid
75    
76                while left < right:
77                    mid = (left + right) // 2
78                    if objects[mid].pos.x < x:
79                        left = mid + 1
80    
81                    else:
82                        right = mid
83    
84                return left if objects[left].pos.x >= x else 0
85    
86            def binaryRight(objects, x: float) -> int:
87                cdef int left = 0
88                cdef int right = len(objects) - 1
89                cdef int mid
90    
91                while left < right:
92                    mid = (left + right + 1) // 2
93                    if objects[mid].pos.x > x:
94                        right = mid - 1
95    
96                    else:
97                        left = mid
98    
99                return right if objects[right].pos.x <= x else len(objects) - 1
100    
101           cdef list dynamicsObjects = []
102   
103           for obj in group.objects:
104               if type(obj) == DynamicObject:
105                   dynamicsObjects.append(obj)
106   
107           game.cash["object_sorted_by_distance"] = sorted(group.objects, key=lambda obj: obj.pos.x)
108   
109           for obj in dynamicsObjects:
110               resulting = obj.getVectorsPower()
111   
112               l = binaryLeft(game.cash["object_sorted_by_distance"], obj.pos.x - resulting.x - group.maxLenghtObject)
113               r = binaryRight(game.cash["object_sorted_by_distance"], obj.pos.x + resulting.x + group.maxLenghtObject) + 1
114   
115               objectsBefore = game.cash["object_sorted_by_distance"][l:r]
116               objectsAfter = []
117   
118               for before in objectsBefore:
119                   if not (obj.pos.y + obj.hitbox.y + obj.hitbox.height + group.maxLenghtObject < before.pos.y + before.hitbox.y or before.pos.y + before.hitbox.y + before.hitbox.height + group.maxLenghtObject < obj.pos.y + obj.hitbox.y):
120                       objectsAfter.append(before)
121   
122               GetUsingObjects.getUsingObjectsIterationSquare(game, objectsAfter, obj)
123   
124       @staticmethod
125       def getUsingObjectsIteration(game, objects, obj) -> None:
126           game.cash["collisions"][obj.id] = []
127   
128           hitbox = obj.hitbox.copy()
129   
130           hitbox.x -= hitbox.width
131           hitbox.y -= hitbox.height
132   
133           hitbox.width *= 3
134           hitbox.height *= 3
135   
136           for j, second in enumerate(objects):
137               if obj.id == second.id:
138                   continue
139   
140               var = obj.collisions.get(second.group)
141   
142               if var is not None or True:
143                   if True or Collision.rect(second.pos.x + second.hitbox.x, second.pos.y + second.hitbox.y, second.hitbox.width, second.hitbox.height, obj.pos.x + hitbox.x, obj.pos.y + hitbox.y, hitbox.width, hitbox.height):
144                       game.cash["collisions"][obj.id].append({"object": second, "functions": var})
145   
146   
147       @staticmethod
148       def getUsingObjectsIterationSquare(game, objects, obj) -> None:
149           game.cash["collisions"][obj.id] = []
150   
151           for j, second in enumerate(objects):
152               if obj.id == second.id:
153                   continue
154   
155               game.cash["collisions"][obj.id].append({"object": second, "functions": obj.collisions.get(second.group)})
156   
157   
##### engine\classes\group.py #####
1     from engine.classes.objects import DynamicObject
2     
3     from engine.classes.collision import Collision
4     
5     from engine.classes.hitbox import SquareHitbox
6     
7     from engine.classes.sprite import Sprite
8     
9     from engine.functions.alpha import alphaRect
10     
11    from engine.variables import *
12    
13    import typing
14    import pygame
15    import types
16    import math
17    
18    
19    class ParticleGroup:
20        def __init__(self, game, particles: typing.List[VParticle] = None) -> None:
21            if particles is None:
22                particles = []
23    
24            self.game = game
25    
26            self.particles = particles
27    
28        def __len__(self) -> int:
29            return len(self.particles)
30    
31        def add(self, particle: VParticle) -> None:
32            self.particles.append(particle.copy())
33    
34        def remove(self, particle: VObject) -> None:
35            self.particles.remove(particle)
36    
37        def getById(self, id: int) -> VParticle:
38            for particle in self.particles:
39                if particle.id == id:
40                    return particle
41    
42            raise NameError(f"id {id} isn't found")
43    
44        def removeById(self, id: int) -> None:
45            for particle in self.particles:
46                if particle.id == id:
47                    self.particles.remove(particle)
48                    return 0
49    
50            raise IndexError(f"id {id} not found in group")
51    
52        def getByGroup(self, group: str) -> typing.List[VParticle]:
53            return [particle for particle in self.particles if particle.group == group]
54    
55        def update(self):
56            for particle in self.particles:
57                particle.update()
58    
59        def draw(self):
60            px = self.game.camera.x()
61            py = self.game.camera.y()
62    
63            for particle in self.particles:
64                if self.game.width + particle.sprite.width > particle.pos.x + px > -particle.sprite.width and self.game.height + particle.sprite.height > particle.pos.y + py > -particle.sprite.height:
65                    particle.draw(px, py)
66    
67    
68    class ObjectGroup:
69        def __init__(self, game, objects: typing.List[VObject] = None) -> None:
70            if objects is None:
71                objects = []
72    
73            self.game = game
74    
75            self.collisions = Collision()
76    
77            self.objects = []
78    
79            for obj in self.objects:
80                self.add(obj)
81    
82            self.objectById = {}
83            self.objectByGroup = {}
84    
85            self.maxLenghtObject = -INF
86            self.minLenghtObject = +INF
87    
88        def empty(self):
89            self.maxLenghtObject = -INF
90            self.minLenghtObject = +INF
91    
92            for obj in self.objects:
93                self.remove(obj)
94    
95        def add(self, obj: VObject) -> None:
96            self.updateMinLenghtObject(obj)
97            self.updateMaxLenghtObject(obj)
98    
99            if isinstance(obj, DynamicObject):
100                self.objects.insert(0, obj)
101   
102           else:
103               self.objects.append(obj)
104   
105           self.objectById[obj.id] = obj
106   
107           if obj.group not in self.objectByGroup:
108               self.objectByGroup[obj.group] = {}
109   
110           self.objectByGroup[obj.group][obj.id] = obj
111   
112       def remove(self, obj: VObject) -> None:
113           self.objects.remove(obj)
114   
115           if obj.id in self.objectById:
116               self.objectById.pop(obj.id)
117               self.objectByGroup[obj.group].pop(obj.id)
118   
119       def getById(self, id: int) -> VObject:
120           return self.objectById.get(id)
121   
122       def removeByGroup(self, group: str) -> None:
123           if group not in self.objectByGroup:
124               return
125   
126           objects = list(self.objectByGroup[group].values())
127   
128           for obj in objects:
129               self.remove(obj)
130   
131       def removeById(self, id: int) -> None:
132           if id not in self.objectById:
133               return
134   
135           self.remove(self.objectById[id])
136   
137       def getByGroup(self, group) -> typing.List[VObject]:
138           return [element for element in self.objectByGroup[group].values()]
139   
140       def updateMinLenghtObject(self, obj: VObject) -> None:
141           self.minLenghtObject = min(self.minLenghtObject, obj.hitbox.width + obj.hitbox.height)
142   
143       def updateMaxLenghtObject(self, obj: VObject) -> None:
144           self.maxLenghtObject = max(self.maxLenghtObject, obj.hitbox.width + obj.hitbox.height)
145   
146       def update(self) -> None:
147           right = [obj for obj in self.objects if not hasattr(obj, "getVectorsPower") or obj.getVectorsPower().x >= 0]
148           left = [obj for obj in self.objects if hasattr(obj, "getVectorsPower") and obj.getVectorsPower().x < 0]
149   
150           right.sort(key=lambda x: x.pos.y)
151           left.sort(key=lambda x: x.pos.y)
152   
153           for obj in right + left:
154               obj.update()
155   
156       def draw(self) -> None:
157           self.game.camera.update()
158   
159           px = self.game.camera.x()
160           py = self.game.camera.y()
161   
162           for obj in sorted(self.objects, key=lambda x: x.drawPriority):
163               sprite = None
164   
165               if obj.sprite is not None:
166                   if type(obj.sprite) == Sprite:
167                       sprite = obj.sprite.get()
168   
169                   elif type(obj.sprite) == list:
170                       alphaRect(self.game.screen, obj.sprite, SquareHitbox([obj.pos.x, obj.pos.y, obj.hitbox.width, obj.hitbox.height]))
171   
172                       continue
173   
174                   elif type(obj.sprite) == types.FunctionType:
175                       obj.sprite()
176   
177                       continue
178   
179                   else:
180                       sprite = obj.sprite.get(obj)
181   
182               if not obj.invisible or self.game.forcedViewObject:
183                   if obj.sprite is not None and sprite is not None and type(obj.sprite) != list:
184                       # obj.sprite.pos.x = 0
185                       # obj.sprite.pos.y = 0
186   
187                       # print(obj.sprite.pos)
188   
189                       if self.game.usingWidth + 200 > obj.pos.x + obj.sprite.pos.x + px > -200 and self.game.usingHeight + 200 > obj.pos.y + obj.sprite.pos.y + py > -200:
190                           self.game.screen.blit(sprite, (obj.pos.x + obj.sprite.pos.x + px, obj.pos.y + obj.sprite.pos.y + py))
191   
192               if self.game.debug or (obj.group.startswith("__") and obj.group.endswith("__") and not obj.group == "__debug_unvisiable__"):
193                   pygame.draw.rect(
194                       self.game.screen, (255, 0, 0) if "debug_color" not in obj.specials else obj.specials["debug_color"],
195                       (math.trunc(obj.pos.x) + obj.hitbox.x + px, math.trunc(obj.pos.y) + obj.hitbox.y + py, obj.hitbox.width, obj.hitbox.height), 1
196                   )
197   
##### engine\classes\hitbox.pyx #####
1     from engine.vector.float import Vec4f
2     from engine.vector.int import Vec4i
3     
4     import typing
5     
6     cdef class SquareHitbox:
7         cdef public int x, y, width, height
8     
9         def __init__(self, hitbox: Union[list, tuple, Vec4f, Vec4i]):
10             if isinstance(hitbox, (list, tuple)):
11                pass
12    
13            else:
14                hitbox = hitbox.get()
15    
16            self.x = int(hitbox[0])
17            self.y = int(hitbox[1])
18            self.width = int(hitbox[2])
19            self.height = int(hitbox[3])
20    
21        def __str__(self) -> str:
22            return f"SquareHitbox({self.x}, {self.y}, {self.width}, {self.height})"
23    
24        def __repr__(self) -> str:
25            return f"SquareHitbox({self.x}, {self.y}, {self.width}, {self.height})"
26    
27        def __getattr__(self, name):
28            if name == "x":
29                return int(self.x)
30    
31            elif name == "y":
32                return int(self.y)
33    
34            if name == "width":
35                return int(self.width)
36    
37            elif name == "height":
38                return int(self.height)
39    
40            else:
41                return super().__getattr__(name)
42    
43        def contains(self, obj: "SquareHitbox") -> bool:
44            return self.x <= obj.x < self.x + self.width and self.y <= obj.y < self.y + self.height
45    
46        def get(self) -> list:
47            return [int(self.x), int(self.y), int(self.width), int(self.height)]
48    
49        def copy(self) -> "SquareHitbox":
50            return SquareHitbox(self.get())
51    
##### engine\classes\objects.pyx #####
1     from libc.math cimport sqrt, sin, cos
2     
3     from engine.classes.collision import Collision
4     
5     from engine.classes.hitbox import SquareHitbox
6     
7     from engine.classes.sprite import Sprite
8     
9     from engine.vector.angle import AngleVector
10     
11    from engine.vector.float import Vec2f, Vec4f
12    from engine.vector.int import Vec2i, Vec4i
13    
14    from engine.variables import *
15    
16    import random
17    import typing
18    import math
19    
20    cdef class StaticObject:
21        cdef public object game
22        cdef public object procesionPos
23        cdef public object pos
24        cdef public object hitbox
25        cdef public int drawPriority
26        cdef public object sprite
27        cdef public float distance
28        cdef public int mass
29        cdef public int id
30        cdef public str group
31        cdef public dict variables
32        cdef public dict specials
33        cdef public object collisions
34        cdef public bint invisible
35        cdef public object animator
36    
37        def __init__(
38            self, game: object,
39            pos: typing.Union[typing.List[float], Vec2f, Vec2i],
40            hitbox: typing.Union[SquareHitbox, typing.List[float], Vec4f, Vec4i],
41            sprite: VSprite = None,
42            group: str = None,
43            mass: int = 1000,
44            layer: int = 0,
45            id: int = None,
46            invisible: bool = False,
47            animator: typing.Any = None,
48            variables: typing.Dict[str, typing.Any] = None,
49            specials: typing.Dict[str, typing.Any] = None,
50            *args, **kwargs
51        ) -> None:
52            if variables is not None:
53                self.variables = variables
54    
55            else:
56                self.variables = {}
57    
58            if specials is not None:
59                self.specials = specials
60    
61            else:
62                self.specials = {}
63    
64            self.game = game
65            self.collisions = self.game.objects.collisions.get(group)
66    
67            if id is None:
68                self.id = random.randint(1, 1000000000)
69    
70            else:
71                self.id = id
72    
73            self.group = group
74            self.procesionPos = Vec2f(0, 0)
75            self.pos = pos if type(pos) == Vec2f else Vec2f(*pos)
76            self.hitbox = hitbox if type(hitbox) == SquareHitbox else SquareHitbox(hitbox)
77            self.mass = mass
78            self.drawPriority = layer
79            self.invisible = invisible
80            self.sprite = sprite if type(sprite) != list else Sprite(self.game, self, *sprite)
81            self.distance = sqrt(self.pos.x ** 2 + self.pos.y ** 2)
82            self.animator = animator
83    
84        def __str__(self):
85            return f"StaticObject(id = {self.id} pos = {self.pos})"
86    
87        def __repr__(self):
88            return f"StaticObject(id = {self.id} pos = {self.pos})"
89    
90        def update(self, collisions: typing.List["VObject"] = None) -> None:
91            if self.animator is not None:
92                self.animator.update()
93    
94            self.collision(0, 0, True)
95    
96        def move(self, x: float = 0, y: float = 0):
97            y = 0 if abs(y) < FLOAT_PRECISION else y
98            x = 0 if abs(x) < FLOAT_PRECISION else x
99    
100            self.procesionPos.x += x
101           self.procesionPos.y += y
102   
103           x = int(self.procesionPos.x)
104           y = int(self.procesionPos.y)
105   
106           self.procesionPos.x -= x
107           self.procesionPos.y -= y
108   
109           if x == 0 and y == 0:
110               return 0
111   
112           self.game.doCollisionsUpdate = max(self.game.doCollisionsUpdate, x != 0 or y != 0)
113   
114           collisions = self.game.cash["collisions"][self.id] if self.id in self.game.cash["collisions"] else []
115   
116           step = math.ceil(abs(x) + abs(y))
117   
118           hitbox = self.getEditHitbox(x, y)
119   
120           useX = True
121           useY = True
122   
123           for _ in range(step):
124               for i, obj in enumerate(collisions):
125                   if obj["functions"] is not None and "collision" in obj["functions"]["types"]:
126                       if self.collision(x, 0):
127                           useX = False
128   
129                       if self.collision(0, y):
130                           useY = False
131   
132               else:
133                   self.pos.x += (abs(x) / step) * (1 if x >= 0 else -1) * useX
134                   self.pos.y += (abs(y) / step) * (1 if y >= 0 else -1) * useY
135   
136           self.pos.x = round(self.pos.x)
137           self.pos.y = round(self.pos.y)
138   
139           self.distance = sqrt(self.pos.x ** 2 + self.pos.y ** 2)
140   
141       def collision(self, x: float = 0, y: float = 0, allowFunctions: bool = False, append: bool = False) -> bool:
142           hitbox = self.getEditHitbox(x, y, append)
143   
144           if self.id not in self.game.cash["collisions"]:
145               return False
146   
147           flag = False
148   
149           for obj in self.game.cash["collisions"][self.id]:
150               if Collision.rect(self.pos.x + hitbox.x, self.pos.y + hitbox.y, hitbox.width, hitbox.height, obj["object"].pos.x + obj["object"].hitbox.x, obj["object"].pos.y + obj["object"].hitbox.y, obj["object"].hitbox.width, obj["object"].hitbox.height):
151                   if allowFunctions:
152                       if obj["functions"] is not None:
153                           for element in obj["functions"]["functions"]:
154                               getattr(self.game.functions, element.replace("function::", "").replace("()", ""))(self.game, self, obj)
155   
156                   if obj["functions"] is not None and "collision" in obj["functions"]["types"]:
157                       if isinstance(obj["object"], DynamicObject) and isinstance(self, DynamicObject):
158                           # после того как объект был найден проверять для этого же объект дальше, если ли ещё динамические объекты
159                           # и высчитывать общую массу и общий импульс
160   
161                           speedX = (self.mass * self.getVectorsPower().x + obj["object"].mass * obj["object"].getVectorsPower().x) / (self.mass + obj["object"].mass)
162                           speedY = (self.mass * self.getVectorsPower().y + obj["object"].mass * obj["object"].getVectorsPower().y) / (self.mass + obj["object"].mass)
163   
164                           if x > 0:
165                               self.moveByAngle(90, speedX - self.getVectorsPower().x)
166                               obj["object"].moveByAngle(90, speedX - obj["object"].getVectorsPower().x)
167   
168                           if x < 0:
169                               self.moveByAngle(90, speedX - self.getVectorsPower().x)
170                               obj["object"].moveByAngle(90, speedX - obj["object"].getVectorsPower().x)
171   
172                           if y > 0 and (obj["object"].pos.x + obj["object"].hitbox.x < self.pos.x + self.hitbox.x + self.hitbox.width) and (self.pos.x + self.hitbox.x < obj["object"].pos.x + obj["object"].hitbox.x + obj["object"].hitbox.width) and (self.pos.y + self.hitbox.y + self.hitbox.height <= obj["object"].pos.y + obj["object"].hitbox.y):
173                               self.moveByAngle(180, speedY - self.getVectorsPower().y)
174                               obj["object"].moveByAngle(180, speedY - obj["object"].getVectorsPower().y)
175   
176                           if y < 0:
177                               pass
178   
179                       if allowFunctions:
180                           flag = True
181   
182                       else:
183                           return True
184   
185           return flag
186   
187       def collisionGetID(self, x: float = 0, y: float = 0, append: bool = False, group: str = None) -> typing.Any:
188           hitbox = self.getEditHitbox(x, y, append)
189   
190           if self.id not in self.game.cash["collisions"]:
191               return [False, -1]
192   
193           for obj in self.game.cash["collisions"][self.id]:
194               if obj["object"].group == group or group is None:
195                   if Collision.rect(self.pos.x + hitbox.x, self.pos.y + hitbox.y, hitbox.width, hitbox.height, obj["object"].pos.x + obj["object"].hitbox.x, obj["object"].pos.y + obj["object"].hitbox.y, obj["object"].hitbox.width, obj["object"].hitbox.height):
196                       return [True, obj["object"]]
197   
198           return [False, -1]
199   
200       def getEditHitbox(self, x: float = 0, y: float = 0, append: bool = False) -> SquareHitbox:
201           hitbox = self.hitbox.copy()
202   
203           if append:
204               hitbox.x -= 1
205               hitbox.width += 2
206               hitbox.y -= 1
207               hitbox.height += 2
208   
209           if x > 0:
210               hitbox.x += 1
211   
212           elif x < 0:
213               hitbox.x -= 1
214   
215           if y < 0:
216               hitbox.y -= 1
217   
218           elif y > 0:
219               hitbox.y += 1
220   
221           return hitbox
222   
223   
224   cdef class DynamicObject(StaticObject):
225       cdef public dict vectors
226       cdef public float gravity
227       cdef public float jumpPower
228       cdef public float slidingStep
229       cdef public float speed
230       cdef public bint wasJump
231   
232       def __cinit__(self, *args, **kwargs):
233           self.wasJump = 0
234   
235       def __init__(
236           self, game: object,
237           pos: typing.Union[typing.List[float], Vec2f],
238           hitbox: typing.Union[SquareHitbox, typing.List[float], Vec4f],
239           sprite: VSprite = None,
240           group: str = None,
241           mass: int = 1000,
242           layer: int = 0,
243           speed: float = 5,
244           id: int = None,
245           invisible: bool = False,
246           animator: typing.Any = None,
247           gravity: float = 300,
248           jumpPower: float = 10,
249           slidingStep: float = INF,
250           variables: typing.Dict[str, typing.Any] = None,
251           specials: typing.Dict[str, typing.Any] = None,
252           *args, **kwargs
253       ) -> None:
254           StaticObject.__init__(self, game, pos, hitbox, sprite, group, mass, layer, id, invisible, animator, variables, specials)
255   
256           self.vectors = {
257               "__fall__": AngleVector(0, 0)
258           }
259   
260           self.gravity = gravity
261           self.jumpPower = jumpPower
262           self.slidingStep = slidingStep
263           self.speed = speed
264   
265       def __str__(self):
266           return f"DynamicObject(id = {self.id} pos = {self.pos})"
267   
268       def __repr__(self):
269           return f"DynamicObject(id = {self.id} pos = {self.pos})"
270   
271       def update(self, collisions: list = None):
272           if collisions is None:
273               collisions = []
274   
275           super().update(collisions)
276   
277           self.wasJump -= 1
278   
279           if self.collision(0, -1):
280               pass
281   
282           if self.collision(0, 1):
283               if self.wasJump <= 0:
284                   self.vectors["__fall__"].power = 0
285   
286           else:
287               self.vectors["__fall__"].power += self.gravity / 1000
288   
289           pos = Vec2f()
290           rem = []
291   
292           for name, vector in self.vectors.items():
293               x = vector.power * sin(math.radians(vector.angle))
294               y = vector.power * cos(math.radians(vector.angle))
295   
296               pos.x += x
297               pos.y += y
298   
299               vector.power -= vector.decreaseSpeed
300   
301               # x = max(0, abs(x) - self.slidingStep) * (1 if x >= 0 else -1)
302               # y = max(0, abs(y) - self.gravity / 1000) * (1 if y >= 0 else -1)
303   
304               # vector.power = sqrt(x ** 2 + y ** 2)
305               # vector.angle = math.atan2(y, x)
306   
307               if vector.power <= FLOAT_PRECISION and name != "__fall__":
308                   rem.append(name)
309   
310           for name in rem:
311               self.vectors.pop(name)
312   
313           self.move(pos.x, pos.y)
314   
315       def moveByAngle(self, angle: float, speed: float = None, slidingStep: float = None, name: str = "vector", specifical: int = None):
316           id = random.randint(1, 1000000000) if specifical is None else int(specifical)
317   
318           self.vectors[f"{name} ({id})"] = AngleVector(180 - angle, self.speed if speed is None else speed, self.slidingStep if slidingStep is None else slidingStep)
319   
320       def moveByType(self, move: str, power: float = None) -> None:
321           if move == "jump":
322               self.vectors["__fall__"].power = -self.jumpPower if power is None else power
323   
324               self.wasJump = 5
325   
326           else:
327               raise NameError(f"move type {move} is not defined")
328   
329       def getVectorsPower(self) -> Vec2i:
330           pos = Vec2f(0, 0)
331   
332           for name, vector in self.vectors.items():
333               if name.startswith("__") and name.endswith("__"):
334                   continue
335   
336               pos.x += vector.power * sin(math.radians(vector.angle))
337               pos.y += vector.power * cos(math.radians(vector.angle))
338   
339           if pos.y <= FLOAT_PRECISION:
340               pos.x += self.vectors["__fall__"].power * sin(math.radians(self.vectors["__fall__"].angle))
341               pos.y += self.vectors["__fall__"].power * cos(math.radians(self.vectors["__fall__"].angle))
342   
343           pos.x = 0 if abs(pos.x) < FLOAT_PRECISION else pos.x
344           pos.y = 0 if abs(pos.y) < FLOAT_PRECISION else pos.y
345   
346           return pos
347   
##### engine\classes\particles.py #####
1     from engine.classes.sprite import Sprite
2     
3     from engine.vector.float import Vec2f
4     
5     from engine.variables import *
6     from math import *
7     
8     import random
9     import typing
10     
11    
12    class ParticleFunction:
13        """
14        x:      lambda variables, pos, step: x + px (x + add to x (int))
15        y:      lambda variables, pos, step: y + py (y + add to y (int))
16    
17        death:  lambda variables, pos, step: flag (do kill (True or False))
18        resize: lambda variables, pos, step: flag, width, height (do resize (True or False), new image width (int), new image height (int))
19        """
20    
21        def __init__(self, game, functions: typing.Dict[str, typing.Callable] = None, variables: typing.Dict[str, typing.Any] = None) -> None:
22            if functions is None:
23                self.functions = {}
24    
25            else:
26                self.functions = functions
27    
28            if variables is None:
29                self.variables = {}
30    
31            else:
32                self.variables = variables
33    
34            self.game = game
35    
36            if "x" not in self.functions:
37                self.functions["x"] = lambda variables, pos, step: pos.x
38    
39            if "y" not in self.functions:
40                self.functions["y"] = lambda variables, pos, step: pos.y
41    
42            if "death" not in self.functions:
43                self.functions["death"] = lambda variables, pos, step: False
44    
45            if "resize" not in self.functions:
46                self.functions["resize"] = lambda variables, pos, step: (False, 0, 0)
47    
48        def update(self, particle: VParticle) -> None:
49            particle.pos.x = self.functions["x"](self.variables, particle.pos, particle.step)
50            particle.pos.y = self.functions["y"](self.variables, particle.pos, particle.step)
51    
52            if self.functions["death"](self.variables, particle.pos, particle.step):
53                self.game.particles.pop(particle)
54    
55            var = self.functions["resize"](self.variables, particle.pos, particle.step)
56    
57            if var[0]:
58                particle.sprite.resize(var[1], var[2])
59    
60    
61    class ImageParticle:
62        def __init__(
63                self, game, pos: typing.Union[Vec2f, typing.List[float]],
64                sprite: VSprite, function: ParticleFunction, group: str = None
65        ) -> None:
66            self.game = game
67    
68            self.id = random.randint(1, 1000000000)
69    
70            self.pos = pos if type(pos) == Vec2f else Vec2f(*pos)
71    
72            self.function = function
73            self.sprite = sprite
74    
75            self.group = group
76    
77            self.step = 1
78    
79        def copy(self) -> "ImageParticle":
80            return ImageParticle(self.game, Vec2f(*self.pos), self.sprite.copy(), self.function, self.group)
81    
82        def update(self) -> None:
83            self.function.update(self)
84    
85            self.step += 1
86    
87        def draw(self, px: float = 0, py: float = 0) -> None:
88            self.game.screen.blit(self.sprite.get(), (self.pos.x + px, self.pos.y + py))
89    
##### engine\classes\sprite.py #####
1     from engine.vector.float import Vec2f
2     from engine.vector.int import Vec2i
3     
4     import typing
5     import pygame
6     
7     
8     class Sprite:
9         cache = {}
10     
11        def __init__(self, game, obj, *args) -> None:
12            """
13            :param args: path: str,
14                         pos: typing.Union[typing.List[int], typing.Tuple[int], Vec2f] = Vec2f(0, 0),
15                         size: typing.Union[typing.List[int], typing.Tuple[int], Vec2i] = None
16    
17            :param agrs: path: str, x_offset: int, y_offset: int, width: int, height: int
18            """
19    
20            self.game = game
21            self.obj = obj
22    
23            if 0 < len(args) <= 3:
24                path = args[0]
25                pos  = args[1] if len(args) > 1 else Vec2i(0, 0)
26                size = args[2] if len(args) > 2 else None
27    
28            elif len(args) == 5:
29                path = args[0]
30                pos  = Vec2f(args[1], args[2])
31                size = Vec2i(args[3], args[4])
32    
33            else:
34                raise ValueError("invalid number of arguments")
35    
36            try:
37                if type(path) == str:
38                    if path not in self.cache:
39                        self.cache[path] = pygame.image.load(path).convert_alpha()
40    
41                    self.image = self.cache[path]
42    
43                else:
44                    self.image = path
45    
46            except FileNotFoundError:
47                self.image = None
48    
49            self.size = size if type(size) == Vec2i else (Vec2i(*size) if size is not None else None)
50            self.pos = pos if type(pos) == Vec2i else Vec2i(*pos)
51    
52            # print(self.pos)
53    
54            if self.image is not None and self.size is not None:
55                self.width = size.x
56                self.height = size.y
57    
58            else:
59                self.width = -1
60                self.height = -1
61    
62            if self.size is not None and self.image is not None:
63                self.image = pygame.transform.scale(self.image, (
64                    self.width if self.width > 0 else self.image.get_width(),
65                    self.height if self.height > 0 else self.image.get_height()
66                ))
67    
68        def copy(self) -> "Sprite":
69            return Sprite(self.game, self.obj, self.image, self.pos, self.size)
70    
71        def resize(self, width: int, height: int) -> None:
72            self.width, self.height = width, height
73    
74            self.image = pygame.transform.scale(self.image, (self.width, self.height))
75    
76        def flip(self, horizontal: bool = False, vertical: bool = False) -> None:
77            self.image = pygame.transform.flip(self.image, horizontal, vertical)
78    
79        def get(self) -> pygame.Surface:
80            return self.image
81    
##### engine\classes\texture.py #####
1     from engine.classes.sprite import Sprite
2     
3     from engine.vector.int import Vec2i
4     
5     from PIL import Image
6     
7     import typing
8     import pygame
9     import math
10     
11    
12    class Texture:
13        def __init__(
14                self, game, path: str,
15                size: typing.Union[typing.List[int], typing.Tuple[int], Vec2i] = None
16        ) -> None:
17            self.game = game
18    
19            self.image = Image.open(path).convert("RGBA")
20    
21            self.size = size if type(size) == Vec2i else (Vec2i(*size) if size is not None else None)
22    
23            if self.size is not None:
24                self.image = self.image.resize((self.size.x, self.size.y))
25    
26            self.width = self.image.width
27            self.height = self.image.height
28    
29        def sprite(self, width: int, height: int) -> Sprite:
30            surface = pygame.Surface((width, height))
31    
32            image = pygame.image.frombytes(
33                self.image.tobytes(), self.image.size, "RGBA"
34            )
35    
36            for i in range(math.ceil(width / self.width)):
37                for j in range(math.ceil(height / self.height)):
38                    surface.blit(image, (i * self.width, j * self.height))
39    
40            return Sprite(self.game, surface)
41    
42        def get(self) -> pygame.sprite.Sprite:
43            return self.image
44    
##### engine\functions\alpha.py #####
1     from engine.classes.hitbox import SquareHitbox
2     from engine.vector.int import Vec4i, Vec3i
3     
4     import typing
5     import pygame
6     
7     
8     def alphaRect(screen, color: typing.Union[Vec4i, Vec3i, typing.List[int]], rect: SquareHitbox, border: int = 0):
9         if type(color) == list and len(color) == 3:
10             color = Vec3i(*color)
11    
12        if type(color) == list and len(color) == 4:
13            color = Vec4i(*color)
14    
15        surface = pygame.Surface((rect.width, rect.height), pygame.SRCALPHA)
16        pygame.draw.rect(surface, color.get(), (0, 0, rect.width, rect.height), border)
17    
18        screen.blit(surface, (rect.x, rect.y))
19    
##### engine\functions\cache.py #####
1     import functools
2     
3     
4     def cache(func):
5         cache = {}
6     
7         @functools.wraps(func)
8         def wrapper(*args, **kwargs):
9             key = args + tuple(kwargs.items())
10             if key not in cache:
11                cache[key] = func(*args, **kwargs)
12    
13            return cache[key]
14    
15        return wrapper
16    
17    
##### engine\functions\loads.py #####
1     import json
2     import ast
3     
4     
5     def loadAnimationFile(path: str) -> dict:
6         out = []
7     
8         using_focus = False
9     
10         with open(path, "r") as file:
11            for line in file.read().split("\n"):
12                if line == "@ focus = True":
13                    using_focus = True
14    
15                    continue
16    
17                if line == "@ focus = False":
18                    using_focus = False
19    
20                    continue
21    
22                if len(line.split()) == 0:
23                    continue
24    
25                var = line.split(" -> ")
26    
27                animation = var[1]
28                condition = var[0]
29    
30                out.append([condition, animation])
31    
32        return using_focus, out
33    
34    
35    def loadSettingFile(game, path: str) -> None:
36        if path == "":
37            return 0
38    
39        with open(path, "r") as file:
40            settings = file.read().split("\n")
41    
42        i = 0
43        while i < len(settings):
44            if settings[i] == "":
45                pass
46    
47            elif settings[i].startswith("project::debug = "):
48                setattr(game, "debug", ast.literal_eval(settings[i].replace("project::debug = ", "")))
49    
50            elif settings[i].startswith("project::width = "):
51                setattr(game, "width", int(settings[i].replace("project::width = ", "")))
52    
53            elif settings[i].startswith("project::height = "):
54                setattr(game, "height", int(settings[i].replace("project::height = ", "")))
55    
56            elif settings[i].startswith("project::fps = "):
57                setattr(game, "fps", int(settings[i].replace("project::fps = ", "")))
58    
59            elif settings[i].startswith("project::name = "):
60                setattr(game, "name", str(settings[i].replace("project::name = ", "")).replace("\"", "").replace("\"", ""))
61    
62            elif settings[i].startswith("project::icon = "):
63                setattr(game, "icon", str(settings[i].replace("project::icon = ", "")).replace("\"", "").replace("\"", ""))
64    
65            elif settings[i].startswith("project::flags = "):
66                end = i
67    
68                var = settings[i].replace("project::flags = ", "")
69    
70                while settings[end].find("}") == -1:
71                    end += 1
72    
73                    var += settings[end]
74    
75                for key, value in json.loads(var):
76                    game.variables[key] = value
77    
78            elif settings[i].startswith("project::variables = "):
79                end = i
80    
81                var = settings[i].replace("project::variables = ", "")
82    
83                while settings[end].find("}") == -1:
84                    end += 1
85    
86                    var += settings[end]
87    
88                for key, value in json.loads(var):
89                    game.variables[key] = value
90    
91            else:
92                pass
93    
94            i += 1
95    
96    
97    def loadCollisionFile(path: str) -> dict:
98        out = {}
99    
100        with open(path, "r") as file:
101           text = (file.read() + "\n").split("\n")
102   
103           for line in text:
104               if len(line.split()) == 0:
105                   continue
106   
107               if line.startswith("$") and line.endswith("$"):
108                   continue
109   
110               first, separator, second, _, *collisions = line.split()
111   
112               collisions = " ".join(collisions)
113               collisions = collisions.replace("{", "").replace("}", "")
114               collisions = collisions.split(", ")
115   
116               if first not in out:
117                   out[first] = {}
118   
119               if second not in out:
120                   out[second] = {}
121   
122               if first not in out[second] and separator in ["<-", "<->"]:
123                   out[second][first] = {"types": [], "functions": []}
124   
125               if second not in out[first] and separator in ["->", "<->"]:
126                   out[first][second] = {"types": [], "functions": []}
127   
128               if separator == "->":
129                   var = []
130   
131                   for element in collisions:
132                       if not element.startswith("function::"):
133                           out[first][second]["types"].append(element)
134   
135                       else:
136                           var.append(element)
137   
138                   out[first][second]["functions"] = var
139   
140               elif separator == "<-":
141                   var = []
142   
143                   for element in collisions:
144                       if not element.startswith("function::"):
145                           out[second][first]["types"].append(element)
146   
147                       else:
148                           var.append(element)
149   
150                   out[second][first]["functions"] = var
151   
152               elif separator == "<->":
153                   var = []
154   
155                   for element in collisions:
156                       if not element.startswith("function::"):
157                           out[second][first]["types"].append(element)
158                           out[first][second]["types"].append(element)
159   
160                       else:
161                           var.append(element)
162   
163                   out[second][first]["functions"] = var
164                   out[first][second]["functions"] = var
165   
166               else:
167                   raise NameError(f"not found separator {separator}")
168   
169       return out
170   
##### engine\special\console.py #####
1     from PyQt5.QtWidgets import QApplication, QWidget, QVBoxLayout, QTextEdit, QLineEdit
2     from PyQt5.Qt import QFont
3     from prettytable import PrettyTable
4     
5     import sys
6     import csv
7     
8     
9     class Table:
10         def __init__(self):
11            self.file = "../../profile/out.csv"
12    
13            self.data = []
14            self.now = []
15    
16            self.line = []
17    
18            self.variables = {}
19    
20            self.load()
21    
22            self.clear()
23    
24        def cls(self):
25            for i in range(50):
26                print()
27    
28        def open(self, file):
29            self.file = file
30    
31            self.load()
32    
33        def get_var(self, var):
34            return self.variables[var]
35    
36        def set_var(self, name, value):
37            self.variables[name] = value
38    
39        def add_var(self, name, value):
40            self.variables[name] += value
41    
42        def log_var(self):
43            for item, value in self.variables.items():
44                print(f"{item}: {value} ({type(value)})")
45    
46        def command(self):
47            text = ""
48    
49            while not text.endswith("END"):
50                text += "\n" + input()
51    
52            text = text.replace("END", "")
53    
54            exec(text)
55    
56        def load(self):
57            if self.file is not None:
58                with open(self.file, "r", encoding="utf-8") as file:
59                    reader = csv.reader(file)
60                    for i, row in enumerate(reader):
61    
62                        if i != 0 and len(row) > 3 and row[3].find("e") != -1:
63                            row[3] = "0"
64    
65                        if i != 0 and len(row) > 4 and row[4].find("e") != -1:
66                            row[4] = "0"
67    
68                        try:
69                            row[1] = int(row[1])
70                            row[2] = int(row[2])
71    
72                            row[3] = float(row[3])
73                            row[4] = float(row[4])
74    
75                        except BaseException:
76                            pass
77    
78                        if i == 0:
79                            out = [row[0], "Type", "Effectivity"]
80                            out += row[1:]
81    
82                        else:
83                            out = [row[0], "", 0]
84                            out += row[1:]
85    
86                            if out[0].find("pygame") != -1:
87                                out[1] = "Pygame"
88    
89                            elif out[0].startswith("{") or out[0].startswith("<"):
90                                out[1] = "Python"
91    
92                            elif out[0].find("engine") != -1:
93                                out[1] = "Game Engine 3"
94    
95                            else:
96                                out[1] = "Application"
97    
98                            out[2] = round(1 / (out[5] * 10000), 5) if out[5] > 0.000001 else 10e9
99    
100                        if out[1] != "Python":
101                           self.data.append(out)
102   
103               self.line = list(self.data[0])
104   
105               self.data.pop(0)
106   
107               self.clear()
108   
109       def write(self):
110           table = PrettyTable(self.line)
111   
112           for element in self.now:
113               out = list(element)
114   
115               out[2] = "INF" if out[2] == 10e9 else str(out[2])
116   
117               while len(out) > len(self.line):
118                   out[-2] = out[-2] + " " + out[-1]
119                   out.pop(-1)
120   
121               while len(out) < len(self.line):
122                   out.append("")
123   
124               table.add_row(out)
125   
126           return table.get_string()
127   
128       def clear(self):
129           self.now = list(self.data)
130   
131       def func(self, function):
132           out = []
133   
134           for element in self.now:
135               if function(element):
136                   out.append(element)
137   
138           self.now = list(out)
139   
140       def sort(self, function):
141           self.now.sort(key=function)
142   
143   
144   class Console(QWidget):
145       def __init__(self):
146           super().__init__()
147           self.initUI()
148   
149           self.table = Table()
150   
151           self.console.setFont(QFont("courier", 11))
152           self.command_line.setFont(QFont("courier", 11))
153   
154           self.console.setLineWrapMode(QTextEdit.NoWrap)
155           self.console.setText(self.table.write())
156   
157       def initUI(self):
158           self.command_line = QLineEdit()
159           self.console = QTextEdit()
160   
161           self.layout = QVBoxLayout()
162           self.layout.addWidget(self.console)
163           self.layout.addWidget(self.command_line)
164   
165           self.setLayout(self.layout)
166   
167           self.command_line.returnPressed.connect(self.on_return_pressed)
168   
169       def on_return_pressed(self):
170           command = self.command_line.text()
171           self.command_line.clear()
172   
173           if command.startswith("data.sort"):
174               try:
175                   exec(f"self.table.sort({command.replace('data.sort(', '').replace(')', '')})")
176   
177               except Exception as exc:
178                   print(exc)
179   
180               self.console.setText(self.table.write())
181   
182           if command.startswith("data.function"):
183               try:
184                   exec(f"self.table.sort({command.replace('data.function(', '').replace(')', '')})")
185   
186               except Exception as exc:
187                   print(exc)
188   
189               self.console.setText(self.table.write())
190   
191   
192   def main():
193       app = QApplication(sys.argv)
194   
195       console = Console()
196       console.show()
197   
198       sys.exit(app.exec_())
199   
200   
201   if __name__ == '__main__':
202       main()
203   
##### engine\special\table.py #####
1     from prettytable import PrettyTable
2     
3     import csv
4     
5     
6     class Table:
7         def __init__(self):
8             self.file = None
9     
10             self.data = []
11            self.now = []
12    
13            self.line = []
14    
15            self.variables = {}
16    
17            self.clear()
18    
19        def cls(self):
20            for i in range(50):
21                print()
22    
23        def open(self, file):
24            self.file = file
25    
26            self.load()
27    
28        def get_var(self, var):
29            return self.variables[var]
30    
31        def set_var(self, name, value):
32            self.variables[name] = value
33    
34        def add_var(self, name, value):
35            self.variables[name] += value
36    
37        def log_var(self):
38            for item, value in self.variables.items():
39                print(f"{item}: {value} ({type(value)})")
40    
41        def command(self):
42            text = ""
43    
44            while not text.endswith("END"):
45                text += "\n" + input()
46    
47            text = text.replace("END", "")
48    
49            exec(text)
50    
51        def load(self):
52            if self.file is not None:
53                with open(self.file, "r", encoding="utf-8") as file:
54                    reader = csv.reader(file)
55                    for row in reader:
56                        self.data.append(row)
57    
58                self.line = list(self.data[0])
59    
60                self.data.pop(0)
61    
62                self.clear()
63    
64        def write(self):
65            table = PrettyTable(self.line)
66    
67            for element in self.now:
68                out = list(element)
69    
70                while len(out) > len(self.line):
71                    out[-2] = out[-2] + " " + out[-1]
72                    out.pop(-1)
73    
74                while len(out) < len(self.line):
75                    out.append("")
76    
77                table.add_row(out)
78    
79            print(table.get_string())
80    
81        def clear(self):
82            self.now = list(self.data)
83    
84        def func(self, function):
85            out = []
86    
87            for element in self.now:
88                if function(element):
89                    out.append(element)
90    
91            self.now = list(out)
92    
93        def sort(self, function):
94            self.now.sort(key=function)
95    
96    
97    if __name__ == "__main__":
98        data = Table()
99    
100        while True:
101           try:
102               exec(input(">>> "))
103   
104           except Exception as exc:
105               print(exc)
106   
##### engine\ui\button.py #####
1     from engine.ui.text import Label, center_print_text
2     
3     from engine.classes.texture import Texture
4     from engine.classes.sprite import Sprite
5     
6     from engine.classes.hitbox import SquareHitbox
7     
8     from engine.vector.float import Vec4f
9     from engine.vector.int import Vec3i, Vec4i
10     
11    from engine.functions.alpha import alphaRect
12    
13    import typing
14    import pygame
15    
16    
17    class Button:
18        def __init__(
19            self, game,
20    
21            rect: typing.Union[Vec4f, SquareHitbox, typing.List[float]],
22    
23            base: typing.Union[typing.List[typing.Union[Texture, Sprite]], Texture, Sprite, typing.List[int], Vec3i, Vec4i],
24            mouse: typing.Union[typing.List[typing.Union[Texture, Sprite]], Texture, Sprite, typing.List[int], Vec3i, Vec4i],
25            click: typing.Union[typing.List[typing.Union[Texture, Sprite]], Texture, Sprite, typing.List[int], Vec3i, Vec4i],
26    
27            frame: typing.Union[Sprite, typing.List[int], Vec3i, Vec4i] = None,
28    
29            text: Label = None,
30    
31            function: typing.Callable = None
32        ) -> None:
33            self.game = game
34    
35            self.rect = rect if type(rect) == SquareHitbox else SquareHitbox(rect)
36    
37            if (type(base) == list and type(base[0]) == int) or type(base) in (Vec3i, Vec4i):
38                self.base = Vec4i(*base)
39    
40            else:
41                self.base = base if type(base) == list else [base]
42    
43                for i, element in enumerate(self.base):
44                    if type(element) == Texture:
45                        self.base[i] = element.sprite(self.rect.width, self.rect.height)
46    
47            if (type(mouse) == list and type(mouse[0]) == int) or type(mouse) in (Vec3i, Vec4i):
48                self.mouse = Vec4i(*mouse)
49    
50            else:
51                self.mouse = mouse if type(mouse) == list else [mouse]
52    
53                for i, element in enumerate(self.mouse):
54                    if type(element) == Texture:
55                        self.mouse[i] = element.sprite(self.rect.width, self.rect.height)
56    
57            if (type(click) == list and type(click[0]) == int) or type(click) in (Vec3i, Vec4i):
58                self.click = Vec4i(*click)
59    
60            else:
61                self.click = click if type(click) == list else [click]
62    
63                for i, element in enumerate(self.click):
64                    if type(element) == Texture:
65                        self.click[i] = element.sprite(self.rect.width, self.rect.height)
66    
67            self.frame = (Vec4i(*frame) if type(frame) != Sprite else frame) if frame is not None else frame
68    
69            self.text = text if text is not None else Label(game, 0, 0, 0, 0, "")
70    
71            self.active = None
72    
73            self.function = function
74    
75        def update(self) -> None:
76            pass
77    
78        def draw(self, x: int = None, y: int = None) -> None:
79            if x is None:
80                x = self.rect.x
81    
82            if y is None:
83                y = self.rect.y
84    
85            if x < self.game.mouse[0] < x + self.rect.width:
86                if y < self.game.mouse[1] < y + self.rect.height:
87                    if self.game.click[0]:
88                        if self.function is not None:
89                            self.function()
90    
91                    elif pygame.mouse.get_pressed()[0]:
92                        self.active = self.click
93    
94                    else:
95                        self.active = self.mouse
96    
97                else:
98                    self.active = self.base
99    
100            else:
101               self.active = self.base
102   
103           pygame.draw.rect(self.game.screen, (255, 0, 0), [x, y, self.rect.width, self.rect.height])
104   
105           if type(self.active[0]) == Sprite:
106               for element in self.active:
107                   self.game.screen.blit(element.get(), (x, y))
108   
109           else:
110               alphaRect(self.game.screen, self.active, SquareHitbox([x, y, self.rect.width, self.rect.height]))
111   
112           if self.frame is not None:
113               alphaRect(self.game.screen, self.frame, self.rect, 1)
114   
115           if self.text is not None:
116               self.text.draw(x, y)
117   
##### engine\ui\layout.py #####
1     from engine.classes.hitbox import SquareHitbox
2     from engine.vector.int import Vec4i
3     
4     from engine.variables import *
5     
6     
7     class Layout:
8         def __init__(
9                 self, game, rect: typing.Union[Vec4i, SquareHitbox, typing.List[int]],
10                 objects: VGUIObject
11        ):
12            self.game = game
13    
14            self.rect = rect if type(rect) == SquareHitbox else SquareHitbox(rect)
15    
16            self.objects = objects
17    
18        def update(self):
19            for obj in self.objects:
20                obj.update()
21    
22        def draw(self, x: float = None, y: float = None):
23            if x is None:
24                x = self.rect.x
25    
26            if y is None:
27                y = self.rect.y
28    
29            for obj in self.objects:
30                obj.update()
31                obj.draw(x + obj.rect.x, y + obj.rect.y)
32    
##### engine\ui\lbutton.py #####
1     from engine.ui.text import Label, TextField
2     
3     from engine.classes.sprite import Sprite
4     
5     from engine.classes.hitbox import SquareHitbox
6     
7     from engine.vector.float import Vec4f
8     from engine.vector.int import Vec3i, Vec4i
9     
10     from engine.functions.alpha import alphaRect
11    
12    import typing
13    import pygame
14    
15    
16    class Button:
17        def __init__(
18                self, game,
19                base: typing.Union[Sprite, Vec3i, typing.List[int]],
20                mouse: typing.Union[Sprite, Vec3i, typing.List[int]],
21                click: typing.Union[Sprite, Vec3i, typing.List[int]],
22    
23                rect: typing.Union[Vec4f, SquareHitbox, typing.List[float]],
24    
25                text: typing.Union[typing.Callable, Label, TextField] = None,
26    
27                frame: typing.Union[Sprite, Vec3i, typing.List[int]] = None,
28    
29                function: typing.Callable = None
30        ) -> None:
31            self.game = game
32    
33            self.base = (Vec4i(*base) if len(base) == 4 else Vec4i(*base, 255)) if type(base) == tuple or type(base) == list else base
34            self.mouse = (Vec4i(*mouse) if len(mouse) == 4 else Vec4i(*mouse, 255)) if type(mouse) == tuple or type(mouse) == list else mouse
35            self.click = (Vec4i(*click) if len(click) == 4 else Vec4i(*click, 255)) if type(click) == tuple or type(click) == list else click
36    
37            self.frame = ((Vec4i(*frame) if len(frame) == 4 else Vec4i(*frame, 255)) if type(frame) == tuple or type(frame) == list else frame) if frame is not None else None
38    
39            self.active = None
40    
41            self.rect = rect if type(rect) == SquareHitbox else SquareHitbox(rect)
42    
43            self.text = text if text is not None else Label(game, 0, 0, 0, 0, "")
44    
45            self.function = function
46    
47        def update(self) -> None:
48            pass
49    
50        def draw(self, x: int = None, y: int = None) -> None:
51            if x is None:
52                x = self.rect.x
53    
54            if y is None:
55                y = self.rect.y
56    
57            if x < self.game.mouse[0] < x + self.rect.width:
58                if y < self.game.mouse[1] < y + self.rect.height:
59                    if self.game.click[0]:
60                        if self.function is not None:
61                            self.function()
62    
63                    elif pygame.mouse.get_pressed()[0]:
64                        self.active = self.click
65    
66                    else:
67                        self.active = self.mouse
68    
69                else:
70                    self.active = self.base
71    
72            else:
73                self.active = self.base
74    
75            if type(self.active) == Sprite:
76                self.game.screen.blit(self.active.get(), (x, y))
77    
78            else:
79                alphaRect(self.game.screen, self.active, SquareHitbox([x, y, self.rect.width, self.rect.height]))
80    
81            if self.frame is not None:
82                alphaRect(self.game.screen, self.frame, self.rect, 1)
83    
84            if type(self.text) == Label or type(self.text) == TextField:
85                self.text.draw(x, y)
86    
87            else:
88                self.text()
89    
##### engine\ui\surface.py #####
1     from engine.classes.hitbox import SquareHitbox
2     
3     from engine.vector.float import Vec4f
4     from engine.vector.int import Vec3i, Vec4i
5     
6     from engine.functions.alpha import alphaRect
7     
8     import typing
9     
10     
11    class Surface:
12        def __init__(
13            self, game,
14            rect: typing.Union[SquareHitbox, Vec4f, typing.List[int]],
15            color: typing.Union[Vec3i, Vec4i, typing.List[int]]
16        ):
17            self.game = game
18    
19            self.rect = rect if type(rect) == SquareHitbox else SquareHitbox(rect)
20            self.color = Vec4i(*color, 100) if type(color) == Vec3i else (Vec4i(*color) if type(color) == list else color)
21    
22        def draw(self):
23            alphaRect(self.game.screen, self.color, self.rect)
24    
##### engine\ui\text.py #####
1     from engine.classes.hitbox import SquareHitbox
2     from engine.vector.int import Vec4i
3     
4     from engine.functions.cache import cache
5     
6     from PIL.ImageFont import FreeTypeFont
7     from PIL import ImageFont
8     
9     import typing
10     import pygame
11    
12    BASE_FONT = "engine/fonts/arial.ttf"
13    BASE_FONT_COLOR = (255, 255, 255)
14    
15    
16    @cache
17    def get_font(font_type: str, font_size: int) -> pygame.font.Font:
18        return pygame.font.Font(font_type, font_size)
19    
20    
21    @cache
22    def get_ttf(font_type: str, font_size: int) -> FreeTypeFont:
23        return ImageFont.truetype(font_type, font_size)
24    
25    
26    def print_text(
27            screen, x: float, y: float, message: str, font_size: int = 20,
28            font_type: str = BASE_FONT, font_color: typing.Tuple[int] = (255, 255, 255), alpha: int = 255
29    ) -> None:
30        font = get_font(font_type, font_size)
31        text = font.render(message, True, font_color)
32        text.set_alpha(alpha)
33    
34        screen.blit(text, (x, y))
35    
36    def center_print_text(
37        screen, rect: SquareHitbox, message: str, font_size: int = 20,
38        font_type: str = BASE_FONT, font_color: typing.Tuple[int] = (0, 0, 0), alpha: int = 255
39    ) -> None:
40        ttf = get_ttf(font_type, font_size)
41    
42        tx = rect.width / 2 - ttf.getbbox(message)[2] / 2
43        ty = rect.height / 2 - ttf.getbbox(message + "AgАр")[3] / 2
44    
45        print_text(screen, rect.x + tx, rect.y + ty, message, font_size, font_type, font_color, alpha)
46    
47    
48    class Label:
49        def __init__(
50                self, game, rect: typing.Union[Vec4i, SquareHitbox, typing.List[float]], text: str, font_size: int = 20,
51                font_type: str = BASE_FONT, font_color: typing.Tuple[int] = BASE_FONT_COLOR, 
52                horizontal: str = "center", vertical: str = "center", alpha: int = 255,
53        ) -> None:
54            self.game = game
55    
56            self.rect = rect if type(rect) == SquareHitbox else SquareHitbox(rect)
57    
58            self.text = text
59    
60            self.alpha = alpha
61    
62            self.font_size = font_size
63            self.font_color = font_color
64            self.font_type = font_type
65    
66            self.horizontal = horizontal
67            self.vertical = vertical
68    
69            self.ttf = None
70    
71            self.tx = 0
72            self.ty = 0
73    
74            self.ttf = get_ttf(self.font_type, self.font_size)
75    
76            self.hstep = self.ttf.getbbox("Ag")[3]
77    
78        def update(self) -> None:
79            pass
80    
81        def draw(self, x: int = None, y: int = None) -> None:
82            if x is None:
83                x = self.rect.x
84    
85            if y is None:
86                y = self.rect.y
87    
88            if self.horizontal == "center":
89                self.tx = self.rect.width / 2 - self.ttf.getbbox(self.text)[2] / 2
90    
91            elif self.horizontal == "left":
92                self.tx = 4
93    
94            elif self.horizontal == "right":
95                self.tx = self.rect.width - self.ttf.getbbox(self.text)[2] - 4
96    
97            else:
98                raise NameError(f"type {self.horizontal} is not difined")
99            
100            if self.vertical == "center":
101               py = (self.rect.height - self.hstep) / 2
102   
103           elif self.vertical == "up":
104               py = 2
105   
106           elif self.vertical == "down":
107               py = self.rect.height - self.hstep - 2
108   
109           else:
110               raise NameError(f"horizontal {self.horizontal} is not difined")
111   
112           self.ty = self.rect.height / 2 - self.ttf.getbbox(self.text + "AgАр")[3] / 2
113   
114           print_text(self.game.screen, x + self.tx, y + py, self.text, self.font_size, self.font_type, self.font_color, self.alpha)
115   
116   
117   class TextField:
118       def __init__(
119               self, game, rect: typing.Union[Vec4i, SquareHitbox, typing.List[int]], text: str, font_size: int = 20,
120               font_type: str = BASE_FONT, font_color: typing.Tuple[int] = BASE_FONT_COLOR,
121               horizontal: str = "center", vertical: str = "center", alpha: int = 255
122       ) -> None:
123           self.game = game
124   
125           self.rect = rect if type(rect) == SquareHitbox else SquareHitbox(rect)
126   
127           self.ax = 0
128           self.ay = 0
129   
130           self.text = text
131   
132           self.font_size = font_size
133           self.font_type = font_type
134           self.font_color = font_color
135   
136           self.horizontal = horizontal
137           self.vertical = vertical
138   
139           self.alpha = alpha
140   
141           self.ttf = get_ttf(self.font_type, self.font_size)
142   
143           self.text = self.text.split()
144   
145           self.out = []
146   
147           self.hstep = self.ttf.getbbox("Ag")[3]
148           self.wstep = 0
149   
150           while self.ttf.getbbox((self.wstep + 1) * "_")[2] < self.rect.width:
151               self.wstep += 1
152   
153           self.init()
154   
155       def init(self) -> None:
156           l = 0
157           r = len(self.text) - 1
158   
159           if self.text[0] == "/t":
160               self.out = [" " * 3]
161   
162           else:
163               self.out = [self.text[0]]
164   
165           while l < r:
166               if len(self.out[len(self.out) - 1]) + len(self.text[l + 1]) + 1 < self.wstep:
167                   if self.text[l + 1] == "/n":
168                       self.out.append("")
169   
170                   elif self.text[l + 1] == "/t":
171                       self.out[len(self.out) - 1] += " " * 4
172   
173                   elif len(self.out[len(self.out) - 1]) == 0:
174                       self.out[len(self.out) - 1] += f"{self.text[l + 1]}"
175   
176                   else:
177                       self.out[len(self.out) - 1] += f" {self.text[l + 1]}"
178   
179                   l += 1
180   
181               else:
182                   self.out.append("")
183   
184           self.ay = self.rect.height / 2 - (self.ttf.getbbox("Ag")[3] / 2 * len(self.out))
185   
186           var = (len(self.out) - self.rect.height // self.hstep) * self.hstep
187   
188           return var if var > 0 else 0
189   
190       def update(self) -> None:
191           pass
192   
193       def draw(self, x: int = None, y: int = None, ax: int = 0, ay: int = 0) -> None:
194           self.init()
195   
196           if x is None:
197               x = self.rect.x + ax
198   
199           if y is None:
200               y = self.rect.y + ay
201   
202           if self.vertical == "center":
203               py = (self.rect.height - len(self.out) * self.hstep) / 2
204   
205           elif self.vertical == "up":
206               py = 2
207   
208           elif self.vertical == "down":
209               py = self.rect.height - len(self.out) * self.hstep - 2
210   
211           else:
212               raise NameError(f"horizontal {self.horizontal} is not difined")
213   
214           for i, element in enumerate(self.out):
215               if self.horizontal == "center":
216                   print_text(self.game.screen, x + (self.rect.width / 2 - self.ttf.getbbox(element)[2] / 2), y + i * self.hstep + py, element, self.font_size, self.font_type, self.font_color, self.alpha)
217   
218               elif self.horizontal == "left":
219                   print_text(self.game.screen, x + 4, y + i * self.hstep + py, element, self.font_size, self.font_type, self.font_color, self.alpha)
220   
221               elif self.horizontal == "right":
222                   print_text(self.game.screen, (x + self.rect.width) - self.ttf.getbbox(element)[2] - 4, y + i * self.hstep + py, element, self.font_size, self.font_type, self.font_color, self.alpha)
223   
224               else:
225                   raise NameError(f"horizontal {self.horizontal} is not difined")
226   
##### engine\variables.py #####
1     import typing
2     
3     VObject = typing.TypeVar("VObject")
4     VCamera = typing.TypeVar("VCamera")
5     VSprite = typing.TypeVar("VSprite")
6     
7     VParticle = typing.TypeVar("VParticle")
8     VGUIObject = typing.TypeVar("VGUIObject")
9     
10     INF = int(1e9)
11    FLOAT_PRECISION = 0.0001
12    
13    ARIAL = "engine/fonts/arial.ttf"
14    
##### engine\vector\angle.py #####
1     class AngleVector:
2         def __init__(self, angle: int, power: int, decreaseSpeed: int = 0) -> None:
3             self.angle = angle
4             self.power = power
5     
6             self.decreaseSpeed = decreaseSpeed
7     
8         def __str__(self) -> str:
9             return f"AngleVector(power = {self.power} angle = {self.angle})"
10     
11        def __repr__(self) -> str:
12            return f"AngleVector (power = {self.power} angle = {self.angle})"
13    
14        def rotate(self, angle: int) -> None:
15            self.angle = (self.angle + angle) % 360
16    
17        def update(self) -> None:
18            self.power -= self.decreaseSpeed
19    
##### engine\vector\float.pyx #####
1     cdef class Vec2f:
2         cdef public double x, y
3     
4         def __init__(self, double x=0, double y=0):
5             self.x = x
6             self.y = y
7     
8         def __str__(self):
9             return f"Vec2f({self.x}, {self.y})"
10     
11        def __repr__(self):
12            return f"Vec2f({self.x}, {self.y})"
13    
14        def __add__(self, double other):
15            self.x += other
16            self.y += other
17            return self
18    
19        def __sub__(self, double other):
20            self.x -= other
21            self.y -= other
22            return self
23    
24        def __mul__(self, double other):
25            self.x *= other
26            self.y *= other
27            return self
28    
29        def __truediv__(self, int other):
30            self.x /= other
31            self.y /= other
32            return self
33    
34        def __floordiv__(self, double other):
35            self.x //= other
36            self.y //= other
37            return self
38    
39        def __getitem__(self, int item):
40            if item == 0:
41                return self.x
42    
43            elif item == 1:
44                return self.y
45    
46            else:
47                raise IndexError("index out of range")
48    
49        def __len__(self):
50            return 2
51    
52        def get(self):
53            return (self.x, self.y)
54    
55    
56    cdef class Vec3f:
57        cdef public double x, y, z
58    
59        def __init__(self, double x=0, double y=0, double z=0):
60            self.x = x
61            self.y = y
62            self.z = z
63    
64        def __str__(self):
65            return f"Vec3f({self.x}, {self.y}, {self.z})"
66    
67        def __repr__(self):
68            return f"Vec3f({self.x}, {self.y}, {self.z})"
69    
70        def __add__(self, double other):
71            self.x += other
72            self.y += other
73            self.z += other
74            return self
75    
76        def __sub__(self, double other):
77            self.x -= other
78            self.y -= other
79            self.z -= other
80            return self
81    
82        def __mul__(self, double other):
83            self.x *= other
84            self.y *= other
85            self.z *= other
86            return self
87    
88        def __truediv__(self, int other):
89            self.x /= other
90            self.y /= other
91            self.z /= other
92            return self
93    
94        def __floordiv__(self, double other):
95            self.x //= other
96            self.y //= other
97            self.z //= other
98            return self
99    
100        def __getitem__(self, int item):
101           if item == 0:
102               return self.x
103   
104           elif item == 1:
105               return self.y
106   
107           elif item == 2:
108               return self.z
109   
110           else:
111               raise IndexError("index out of range")
112   
113       def __len__(self):
114           return 3
115   
116       def get(self):
117           return (self.x, self.y, self.z)
118   
119   
120   cdef class Vec4f:
121       cdef public double x, y, z, w
122   
123       def __init__(self, double x=0, double y=0, double z=0, double w=0):
124           self.x = x
125           self.y = y
126           self.z = z
127           self.w = w
128   
129       def __str__(self):
130           return f"Vec4f({self.x}, {self.y}, {self.z}, {self.w})"
131   
132       def __repr__(self):
133           return f"Vec4f({self.x}, {self.y}, {self.z}, {self.w})"
134   
135       def __add__(self, double other):
136           self.x += other
137           self.y += other
138           self.z += other
139           self.w += other
140           return self
141   
142       def __sub__(self, double other):
143           self.x -= other
144           self.y -= other
145           self.z -= other
146           self.w -= other
147           return self
148   
149       def __mul__(self, double other):
150           self.x *= other
151           self.y *= other
152           self.z *= other
153           self.w *= other
154           return self
155   
156       def __truediv__(self, double other):
157           self.x /= other
158           self.y /= other
159           self.z /= other
160           self.w /= other
161           return self
162   
163       def __floordiv__(self, double other):
164           self.x //= other
165           self.y //= other
166           self.z //= other
167           self.w //= other
168           return self
169   
170       def __getitem__(self, int item):
171           if item == 0:
172               return self.x
173   
174           elif item == 1:
175               return self.y
176   
177           elif item == 2:
178               return self.z
179   
180           elif item == 3:
181               return self.w
182   
183           else:
184               raise IndexError("index out of range")
185   
186       def __len__(self):
187           return 4
188   
189       def get(self):
190           return (self.x, self.y, self.z, self.w)
##### engine\vector\int.pyx #####
1     cdef class Vec2i:
2         cdef public int x, y
3     
4         def __init__(self, int x=0, int y=0):
5             self.x = x
6             self.y = y
7     
8         def __str__(self):
9             return f"Vec2i({int(self.x)}, {int(self.y)})"
10     
11        def __repr__(self):
12            return f"Vec2i({int(self.x)}, {int(self.y)})"
13    
14        def __getattr__(self, name):
15            if name == "x":
16                return int(self.x)
17    
18            elif name == "y":
19                return int(self.y)
20    
21            else:
22                return super().__getattr__(name)
23    
24        def __add__(self, int other):
25            self.x += other
26            self.y += other
27            return self
28    
29        def __sub__(self, int other):
30            self.x -= other
31            self.y -= other
32            return self
33    
34        def __mul__(self, int other):
35            self.x *= other
36            self.y *= other
37            return self
38    
39        def __truediv__(self, int other):
40            self.x //= other
41            self.y //= other
42            return self
43    
44        def __floordiv__(self, int other):
45            self.x //= other
46            self.y //= other
47            return self
48    
49        def __getitem__(self, int item):
50            if item == 0:
51                return int(self.x)
52    
53            elif item == 1:
54                return int(self.y)
55    
56            else:
57                raise IndexError("index out of range")
58    
59        def __len__(self):
60            return 2
61    
62        def get(self):
63            return int(self.x), int(self.y)
64    
65    
66    cdef class Vec3i:
67        cdef public int x, y, z
68    
69        def __init__(self, int x=0, int y=0, int z=0):
70            self.x = x
71            self.y = y
72            self.z = z
73    
74        def __str__(self):
75            return f"Vec3i({int(self.x)}, {int(self.y)}, {int(self.z)})"
76    
77        def __repr__(self):
78            return f"Vec3i({int(self.x)}, {int(self.y)}, {int(self.z)})"
79    
80        def __getattr__(self, name):
81            if name == "x":
82                return int(self.x)
83    
84            elif name == "y":
85                return int(self.y)
86    
87            elif name == "z":
88                return int(self.z)
89    
90            else:
91                return super().__getattr__(name)
92    
93        def __add__(self, int other):
94            self.x += other
95            self.y += other
96            self.z += other
97            return self
98    
99        def __sub__(self, int other):
100            self.x -= other
101           self.y -= other
102           self.z -= other
103           return self
104   
105       def __mul__(self, int other):
106           self.x *= other
107           self.y *= other
108           self.z *= other
109           return self
110   
111       def __truediv__(self, int other):
112           self.x //= other
113           self.y //= other
114           self.z //= other
115           return self
116   
117       def __floordiv__(self, int other):
118           self.x //= other
119           self.y //= other
120           self.z //= other
121           return self
122   
123       def __getitem__(self, int item):
124           if item == 0:
125               return int(self.x)
126   
127           elif item == 1:
128               return int(self.y)
129   
130           elif item == 2:
131               return int(self.z)
132   
133           else:
134               raise IndexError("index out of range")
135   
136       def __len__(self):
137           return 3
138   
139       def get(self):
140           return int(self.x), int(self.y), int(self.z)
141   
142   
143   cdef class Vec4i:
144       cdef public int x, y, z, w
145   
146       def __init__(self, int x=0, int y=0, int z=0, int w=0):
147           self.x = x
148           self.y = y
149           self.z = z
150           self.w = w
151   
152       def __str__(self):
153           return f"Vec4i({int(self.x)}, {int(self.y)}, {int(self.z)}, {int(self.w)})"
154   
155       def __repr__(self):
156           return f"Vec4i({int(self.x)}, {int(self.y)}, {int(self.z)}, {int(self.w)})"
157   
158       def __getattr__(self, name):
159           if name == "x":
160               return int(self.x)
161   
162           elif name == "y":
163               return int(self.y)
164   
165           elif name == "z":
166               return int(self.z)
167   
168           elif name == "w":
169               return int(self.w)
170   
171           else:
172               return super().__getattr__(name)
173   
174       def __add__(self, int other):
175           self.x += other
176           self.y += other
177           self.z += other
178           self.w += other
179           return self
180   
181       def __sub__(self, int other):
182           self.x -= other
183           self.y -= other
184           self.z -= other
185           self.w -= other
186           return self
187   
188       def __mul__(self, int other):
189           self.x *= other
190           self.y *= other
191           self.z *= other
192           self.w *= other
193           return self
194   
195       def __truediv__(self, int other):
196           self.x //= other
197           self.y //= other
198           self.z //= other
199           self.w //= other
200           return self
201   
202       def __floordiv__(self, int other):
203           self.x //= other
204           self.y //= other
205           self.z //= other
206           self.w //= other
207           return self
208   
209       def __getitem__(self, int item):
210           if item == 0:
211               return int(self.x)
212   
213           elif item == 1:
214               return int(self.y)
215   
216           elif item == 2:
217               return int(self.z)
218   
219           elif item == 3:
220               return int(self.w)
221   
222           else:
223               raise IndexError("index out of range")
224   
225       def __len__(self):
226           return 4
227   
228       def get(self):
229           return int(self.x), int(self.y), int(self.z), int(self.w)
230   
##### engine\__init__.py #####
1     from engine.vector.int import Vec2i, Vec3i, Vec4i
2     from engine.vector.float import Vec2f, Vec3f, Vec4f
3     from engine.vector.angle import AngleVector
4     from engine.variables import *
5     
6     from engine.classes.hitbox import SquareHitbox
7     
8     from engine.classes.collision import Collision
9     from engine.classes.group import ObjectGroup, ParticleGroup
10     
11    from engine.classes.animator import Animator
12    
13    from engine.classes.animation import Animation
14    from engine.classes.texture import Texture
15    from engine.classes.sprite import Sprite
16    
17    from engine.classes import objects
18    from engine.classes import camera
19    
20    from engine.functions.alpha import alphaRect
21    from engine.functions.cache import cache
22    
23    from engine.classes.particles import ImageParticle, ParticleFunction
24    
25    from engine.ui.surface import Surface
26    from engine.ui.text import Label, TextField, print_text
27    from engine.ui.layout import Layout
28    from engine.ui.button import Button
29    
30    from engine.application import Application
31    
##### scr\code\compiler.py #####
1     import importlib.util
2     
3     import threading
4     import pygame
5     import typing
6     import json
7     import os
8     
9     
10     class Compiler:
11        def __init__(self, project, path: str, nodes: typing.Dict[str, dict], settings: dict, debug: bool = True) -> None:
12            self.project = project
13    
14            self.program = None
15            self.counter = None
16    
17            self.path = path
18    
19            self.nodes = nodes
20    
21            self.tpsc = 0
22            self.tpsNow = 0
23    
24            self.information = {}
25            self.error = False
26    
27            self.settings = settings
28    
29            self.debug = debug
30    
31            self.nodesSortedByTypes = {}
32            self.nodesFunctionsSortedByName = {}
33    
34            self.timer = []
35    
36            try:
37                with open("scr/code/config.json", "r", encoding="utf-8") as file:
38                    self.config = json.load(file)
39    
40            except FileNotFoundError:
41                with open("code/config.json", "r", encoding="utf-8") as file:
42                    self.config = json.load(file)
43    
44            for name, node in self.config["nodes"].items():
45                self.nodesSortedByTypes[node["type"]] = {}
46    
47            for name, node in self.config["nodes"].items():
48                self.nodesSortedByTypes[node["type"]][node["name"]] = []
49    
50            for id, node in self.nodes["objects"].items():
51                self.nodesSortedByTypes[node["type"]][node["name"]].append(id)
52    
53                if node["type"] == "event" and node["name"] == "functionEvent":
54                    if node["inputs"]["name"]["standard"] not in self.nodesFunctionsSortedByName:
55                        self.nodesFunctionsSortedByName[node["inputs"]["name"]["standard"]] = []
56    
57                    self.nodesFunctionsSortedByName[node["inputs"]["name"]["standard"]].append(id)
58    
59            for id, node in self.nodes["objects"].items():
60                for ids, second in self.nodes["objects"].items():
61                    if id == ids:
62                        continue
63    
64                    for name, connector in second["inputs"].items():
65                        if connector["value"] is not None and connector["value"]["id"] == node["id"]:
66                            path = connector["value"]["name"]
67    
68                            if "value" not in node["outputs"][path]:
69                                node["outputs"][path]["value"] = {}
70    
71                            if connector["value"]["id"] == int(id):
72                                node["outputs"][path]["value"][ids] = {"id": int(ids), "name": name}
73    
74            for id, node in self.nodes["objects"].items():
75                for key, value in node["inputs"].items():
76                    if value["value"] is not None:
77                        value["value"]["value"] = None
78    
79            for id, node in self.nodes["objects"].items():
80                for key, value in node["outputs"].items():
81                    if "value" not in value:
82                        value["value"] = {}
83    
84            # print(self.nodesSortedByTypes)
85            # print(dumps(self.nodes, indent=4))
86    
87            self.init()
88    
89        def init(self):
90            text = ""
91    
92            try:
93                os.listdir("scr/code/program")
94    
95            except FileNotFoundError:
96                path = "code/program"
97    
98            else:
99                path = "scr/code/program"
100    
101           for dir in os.listdir(path):
102               for module in os.listdir(f"{path}/{dir}"):
103                   with open(f"{path}/{dir}/{module}", "r", encoding="utf-8") as f:
104                       text = text + f.read() + "\n"
105   
106           thr = threading.Thread(target=lambda: open("compiling.txt", "w", encoding="utf-8").write(text))
107           thr.start()
108   
109           name = "program"
110           spec = importlib.util.spec_from_loader(name, loader=None)
111   
112           self.program = importlib.util.module_from_spec(spec)
113   
114           exec(text, self.program.__dict__)
115   
116           self.event("onStartGame")
117   
118       def queue(self, id: int = None, queue: list = None) -> None:
119           if queue is None:
120               queue = []
121   
122           queue = queue + [id] if id is not None else queue
123   
124           while len(queue) > 0:
125               id = queue[0]
126   
127               if str(id) not in self.nodes["objects"]:
128                   queue.pop(0)
129   
130                   continue
131   
132               if self.debug:
133                   var = getattr(self.program, self.nodes["objects"][str(id)]["name"])(self.project, self, self.path, self.nodes, id, self.settings["variables"])
134   
135               else:
136                   try:
137                       var = getattr(self.program, self.nodes["objects"][str(id)]["name"])(self.project, self, self.path, self.nodes, id, self.settings["variables"])
138   
139                   except Exception as e:
140                       self.error = True
141   
142                       self.information = {
143                           "inputs": self.nodes["objects"][str(id)]["inputs"],
144                           "pos": [self.nodes["objects"][str(id)]["x"], self.nodes["objects"][str(id)]["y"]],
145                           "display": self.nodes["objects"][str(id)]["display"],
146                           "message": e,
147                           "id": id
148                       }
149   
150                       return
151   
152               if type(var) == list:
153                   for element in var:
154                       queue.append(element)
155   
156               elif type(var) == dict:
157                   for element in var["queue"]:
158                       queue.append(element)
159   
160                   for element in var["timer"]:
161                       self.timer.append(element)
162   
163               else:
164                   pass
165   
166               queue.pop(0)
167   
168       def get(self, event: str) -> list:
169           return self.nodesSortedByTypes["event"][event]
170   
171       def event(self, event: str) -> None:
172           for id in self.nodesSortedByTypes["event"][event]:
173               self.queue(id)
174   
175       def start(self, id):
176           self.queue(id)
177   
178       def update(self) -> None:
179           remove = []
180   
181           for i, element in enumerate(self.timer):
182               element["timer"] -= 1
183   
184               if element["timer"] == 0:
185                   element["timer"] = element["tmax"]
186   
187                   element["count"] -= 1
188   
189                   if "index" in self.nodes["objects"][str(element["id"])]["outputs"]:
190                       element["iter"] += 1
191   
192                       for ids, connector in self.nodes["objects"][str(element["id"])]["outputs"]["index"]["value"].items():
193                           self.nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = element["iter"]
194   
195                   self.queue(queue=[element["id"] for element in self.nodes["objects"][str(element["id"])]["outputs"][element["connector"]]["value"].values()])
196   
197               if element["count"] == 0:
198                   if "after" in self.nodes["objects"][str(element["id"])]["outputs"]:
199                       self.queue(queue=[element["id"] for element in self.nodes["objects"][str(element["id"])]["outputs"]["after"]["value"].values()])
200   
201                   remove.append(element)
202   
203           for element in remove:
204               self.timer.remove(element)
205   
206           for id in self.nodesSortedByTypes["event"]["everyFrame"]:
207               if self.project.fpsc % self.nodes["objects"][id]["inputs"]["N"]["standard"] == 0:
208                   self.start(id)
209   
210           self.project.updateCustonCaption(f"FPS = {round(self.project.clock.get_fps())} TPS = {self.tpsNow}")
211   
212       def tps(self, tps: int):
213           self.tpsc += 1
214   
215           self.tpsNow = tps
216   
217           for id in self.nodesSortedByTypes["event"]["everyTick"]:
218               if self.project.fpsc % self.nodes["objects"][id]["inputs"]["N"]["standard"] == 0:
219                   self.start(id)
220   
221       def functionsByName(self, name):
222           return self.nodesFunctionsSortedByName[name]
223   
##### scr\code\program\animation\mirrorAnimation.py #####
1     def mirrorAnimation(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
8             ids = int(nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"])
9     
10         else:
11            ids = int(nodes["objects"][str(id)]["inputs"]["id"]["standard"])
12    
13        if nodes["objects"][str(id)]["inputs"]["horizontal"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["horizontal"]["value"]["value"] is not None:
14            horizontal = bool(nodes["objects"][str(id)]["inputs"]["horizontal"]["value"]["value"])
15    
16        else:
17            horizontal = bool(nodes["objects"][str(id)]["inputs"]["horizontal"]["standard"])
18    
19        if nodes["objects"][str(id)]["inputs"]["vertical"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["vertical"]["value"]["value"] is not None:
20            vertical = bool(nodes["objects"][str(id)]["inputs"]["vertical"]["value"]["value"])
21    
22        else:
23            vertical = bool(nodes["objects"][str(id)]["inputs"]["vertical"]["standard"])
24    
25        program.objects.getById(ids).animator.flipAnimation(horizontal, vertical)
26    
27        return queue
28    
##### scr\code\program\animation\runAnimation.py #####
1     def runAnimation(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
8             ids = int(nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"])
9     
10         else:
11            ids = int(nodes["objects"][str(id)]["inputs"]["id"]["standard"])
12    
13        if nodes["objects"][str(id)]["inputs"]["animation"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["animation"]["value"]["value"] is not None:
14            animation = str(nodes["objects"][str(id)]["inputs"]["animation"]["value"]["value"])
15    
16        else:
17            animation = str(nodes["objects"][str(id)]["inputs"]["animation"]["standard"])
18    
19        program.objects.getById(ids).animator.runAnimation(animation)
20    
21        return queue
22    
##### scr\code\program\animation\stopAnimation.py #####
1     def stopAnimation(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
8             ids = int(nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"])
9     
10         else:
11            ids = int(nodes["objects"][str(id)]["inputs"]["id"]["standard"])
12    
13        program.objects.getById(ids).animator.stopAnimation()
14    
15        return queue
16    
##### scr\code\program\another\callFunction.py #####
1     def callFunction(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         if nodes["objects"][str(id)]["inputs"]["name"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"] is not None:
5             name = str(nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"])
6     
7         else:
8             name = str(nodes["objects"][str(id)]["inputs"]["name"]["standard"])
9     
10         if nodes["objects"][str(id)]["inputs"]["params"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["params"]["value"]["value"] is not None:
11            params = list(nodes["objects"][str(id)]["inputs"]["params"]["value"]["value"])
12    
13        else:
14            params = list(nodes["objects"][str(id)]["inputs"]["params"]["standard"])
15    
16        for ids in compiler.functionsByName(name):
17            nodes["objects"][str(ids)]["inputs"]["params"]["standard"] = params
18    
19            queue.append(ids)
20    
21        for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
22            queue.append(name["id"])
23    
24        return queue
25    
##### scr\code\program\another\decodeHolder.py #####
1     HOLDERS_LIST = ["%math", "%local_var", "%global_var"]
2     
3     
4     def replace(s, old, new):
5         pos = s.rfind(old)
6     
7         if pos == -1:
8             return s
9     
10         return str(s[:pos]) + str(new) + str(s[pos + len(old):])
11    
12    
13    class Holders:
14        @staticmethod
15        def math(text, variables):
16            try:
17                ntext = text
18    
19                while ntext.startswith("\'"):
20                    ntext = ntext[1:]
21    
22                while ntext.endswith("\'"):
23                    ntext = ntext[:-1]
24    
25                return eval(ntext)
26    
27            except Exception as e:
28                try:
29                    return eval(text)
30    
31                except Exception as e:
32                    return text
33    
34        @staticmethod
35        def local_var(text, variables):
36            try:
37                return "\'" + variables["locals"][text]["value"] + "\'" if isinstance(variables["locals"][text]["value"], str) else variables["locals"][text]["value"]
38    
39            except:
40                return "null"
41    
42        @staticmethod
43        def global_var(text, variables):
44            try:
45                return "\'" + variables["globals"][text]["value"] + "\'" if isinstance(variables["globals"][text]["value"], str) else variables["globals"][text]["value"]
46    
47            except:
48                return "null"
49    
50    
51    def decodeHolders(text: str, variables: dict):
52        types = []
53    
54        for i, symbol in enumerate(text):
55            if text[i] == "(":
56                valueEndIndex = text.find(")", i, -1)
57    
58                name = text[text.rfind("%", 0, i):i]
59                value = text[i:valueEndIndex + 1]
60    
61                if name not in HOLDERS_LIST:
62                    continue
63    
64                if value == -1:
65                    continue
66    
67                countOpenBracket = value.count("(")
68                countEndBracket = value.count(")")
69    
70                while countOpenBracket - countEndBracket > 0:
71                    valueEndIndex += 1
72    
73                    if text[valueEndIndex] not in (")", "("):
74                        continue
75    
76                    if text[valueEndIndex] == ")":
77                        countEndBracket += 1
78    
79                    else:
80                        countOpenBracket += 1
81    
82                    value = text[i:valueEndIndex + 1]
83    
84                types.append([text.rfind("%", 0, i), value.count("%"), name, value[1:-1]])
85    
86        types.sort(key=lambda x: x[1] * 1e9 + x[0])
87    
88        # for element in types:
89        #     print(*element)
90    
91        # print(types)
92    
93        # print("-->", text)
94    
95        for i, element in enumerate(types):
96            value = getattr(Holders, element[2][1:])(element[3], variables)
97    
98            text = replace(text, f"{element[2]}({element[3]})", value)
99    
100            for elem in types[i:]:
101               elem[3] = elem[3].replace(f"{element[2]}({element[3]})", str(value))
102   
103           # print("-->", text)
104   
105       return text
106   
107   
108   def decodeHolder(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
109       queue = []
110   
111       for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
112           queue.append(name["id"])
113   
114       if nodes["objects"][str(id)]["inputs"]["text"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["text"]["value"]["value"] is not None:
115           text = str(nodes["objects"][str(id)]["inputs"]["text"]["value"]["value"])
116   
117       else:
118           text = str(nodes["objects"][str(id)]["inputs"]["text"]["standard"])
119   
120       answer = decodeHolders(text, variables)
121   
122       for ids, connector in nodes["objects"][str(id)]["outputs"]["answer"]["value"].items():
123           nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer
124   
125       return queue
126   
127   
128   """
129   if __name__ == "__main__":
130       import time
131   
132       start = time.time()
133   
134       variables = {"locals": {"123": {"value": '65'}, "1": {"value": 2}}, "globals": {"1": {"value": True}}}
135       text = "%math(%local_var(123) + %local_var(1))"
136   
137       print(decodeHolders(text, variables))
138   
139       print(time.time() - start)
140   """
141   
##### scr\code\program\another\exit_.py #####
1     def exit_(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         program.exit()
8     
9         return queue
10     
##### scr\code\program\another\functionEvent.py #####
1     def functionEvent(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         if nodes["objects"][str(id)]["inputs"]["params"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["params"]["value"]["value"] is not None:
5             params = list(nodes["objects"][str(id)]["inputs"]["params"]["value"]["value"])
6     
7         else:
8             params = list(nodes["objects"][str(id)]["inputs"]["params"]["standard"])
9     
10         for ids, connector in nodes["objects"][str(id)]["outputs"]["params"]["value"].items():
11            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = params
12    
13        for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
14            queue.append(name["id"])
15    
16        return queue
17    
##### scr\code\program\another\getMousePos.py #####
1     import pygame
2     
3     
4     def getMousePos(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
5         queue = []
6     
7         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
8             queue.append(name["id"])
9     
10         x, y = pygame.mouse.get_pos()
11    
12        for ids, connector in nodes["objects"][str(id)]["outputs"]["x"]["value"].items():
13            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = x
14    
15        for ids, connector in nodes["objects"][str(id)]["outputs"]["y"]["value"].items():
16            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = y
17    
18        return queue
19    
##### scr\code\program\another\getVar.py #####
1     def getVar(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["name"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"] is not None:
8             name = str(nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"])
9     
10         else:
11            name = str(nodes["objects"][str(id)]["inputs"]["name"]["standard"])
12    
13        if nodes["objects"][str(id)]["inputs"]["global"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["global"]["value"]["value"] is not None:
14            gl = nodes["objects"][str(id)]["inputs"]["global"]["value"]["value"]
15    
16        else:
17            gl = nodes["objects"][str(id)]["inputs"]["global"]["standard"]
18    
19        if gl:
20            answer = variables["globals"][name]["value"]
21    
22        else:
23            answer = variables["locals"][path][name]["value"]
24    
25        for ids, connector in nodes["objects"][str(id)]["outputs"]["answer"]["value"].items():
26            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer
27    
28        return queue
29    
##### scr\code\program\another\len.py #####
1     def len_(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["element"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"] is not None:
8             if type(nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"]) == str:
9                 element = eval(nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"])
10     
11            else:
12                element = eval(str(nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"]))
13    
14        else:
15            if type(nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"]) == str:
16                element = eval(nodes["objects"][str(id)]["inputs"]["element"]["standard"])
17    
18            else:
19                element = eval(str(nodes["objects"][str(id)]["inputs"]["element"]["standard"]))
20    
21        answer = len(element) if type(element) in (list, tuple, dict) else 1
22    
23        for ids, connector in nodes["objects"][str(id)]["outputs"]["answer"]["value"].items():
24            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer
25    
26        return queue
27    
##### scr\code\program\another\python.py #####
1     import functools
2     import typing
3     import random
4     import pygame
5     import re
6     
7     
8     if typing.TYPE_CHECKING:
9         def decodeHolders(text, variables):
10             pass
11    
12    else:
13        pass
14    
15    
16    class PythonFunctions:
17        functions = ["decodeHolder", "exit", "getVar", "setVar", "objectsGroup", "random", "writeText", "displayText", "collision", "createObject", "getObjectIDByName", "getObjectPos", "getObjectVar", "jump", "moveObject", "removeObject", "setObjectPos", "setObjectVar", "getResultingVector", "runAnimation", "stopAnimation", "mirrorAnimation", "getMousePos"]
18    
19        @staticmethod
20        def decodeHolder(text, program, variables, path):
21            return decodeHolders(text, variables)
22    
23        @staticmethod
24        def exit(program, variables, path):
25            program.exit()
26    
27        @staticmethod
28        def getVar(name, global_, program, variables, path):
29            if global_:
30                return variables["globals"][name]["value"]
31    
32            else:
33                return variables["locals"][path][name]["value"]
34    
35        @staticmethod
36        def setVar(name, global_, value, program, variables, path):
37            if global_:
38                variables["globals"][name]["value"] = value
39    
40            else:
41                variables["locals"][path][name]["value"] = value
42    
43        @staticmethod
44        def objectsGroup(group, program, variables, path):
45            return program.objects.getByGroup(group)
46    
47        @staticmethod
48        def random(a, b, program, variables, path):
49            return a if a == b else random.randint(a, b)
50    
51        @staticmethod
52        def writeText(text, program, variables, path):
53            answer = ">>> " + str(text).rstrip() + "\n"
54    
55            program.print(answer)
56    
57            print(answer)
58    
59        @staticmethod
60        def displayText(text, x, y, program, variables, path):
61            program.afterDrawing.append(lambda: program.linkEngine.print_text(program.screen, x, y, str(text)))
62    
63        @staticmethod
64        def collision(ids, group, append, program, variables, path):
65            obj = program.objects.getById(ids)
66    
67            answer = obj.collisionGetID(0, 0, append, group) if obj is not None else [False, -1]
68    
69            return answer
70    
71        @staticmethod
72        def createObject(name, x, y, program, variables, path):
73            if not name.endswith(".obj"):
74                name += ".obj"
75    
76            type = program.allObjects[name]["type"]
77            variables = program.allObjects[name]["variables"]
78    
79            variables["pos"] = [x, y]
80    
81            obj = getattr(program.linkEngine.objects, type)(program, **variables)
82    
83            program.objects.add(obj)
84    
85            return obj.id
86    
87        @staticmethod
88        def getObjectIDByName(name, program, variables, path):
89            name = name + ".objc" if not name.endswith(".objc") else name
90    
91            answer = program.objectIDByName[program.scene][name] if name in program.objectIDByName[program.scene] else -1
92    
93            return answer
94    
95        @staticmethod
96        def getObjectPos(ids, program, variables, path):
97            return program.objects.getById(ids).pos.get()
98    
99        @staticmethod
100        def getObjectVar(ids, name, program, variables, path):
101           answer = variables["objects"][program.scene][program.objectNameByID[program.scene][str(ids)]][name]["value"]
102   
103       @staticmethod
104       def jump(ids, program, variables, path):
105           obj = program.objects.getById(int(ids))
106   
107           obj.moveByType("jump")
108   
109       @staticmethod
110       def moveObject(ids, angle, power, program, variables, path):
111           obj = program.objects.getById(int(ids))
112   
113           obj.moveByAngle(angle, power)
114   
115       @staticmethod
116       def removeObject(ids, program, variables, path):
117           program.objects.removeById(ids)
118   
119       @staticmethod
120       def setObjectPos(ids, x, y, program, variables, path):
121           obj = program.objects.getById(int(ids))
122   
123           obj.pos.x = x
124           obj.pos.y = y
125   
126       @staticmethod
127       def setObjectVar(ids, name, value, program, variables, path):
128           variables["objects"][program.scene][program.objectNameByID[program.scene][str(ids)]][name]["value"] = value
129   
130       @staticmethod
131       def getResultingVector(ids, program, variables, path):
132           return program.objects.getById(ids).getVectorsPower().get()
133   
134       @staticmethod
135       def runAnimation(ids, animation, program, variables, path):
136           program.objects.getById(ids).animator.runAnimation(animation)
137   
138       @staticmethod
139       def stopAnimation(ids, animation, program, variables, path):
140           program.objects.getById(ids).animator.stopAnimation()
141   
142       @staticmethod
143       def mirrorAnimation(ids, horizontal, vertical, program, variables, path):
144           program.objects.getById(ids).animator.flipAnimation(horizontal, vertical)
145   
146       @staticmethod
147       def getMousePos(program, variables, path):
148           return pygame.mouse.get_pos()
149   
150   
151   class PythonCodeExecutor:
152       program = None
153       variables = None
154       path = None
155   
156       contest = {}
157   
158       inited = False
159   
160       @classmethod
161       def init(cls):
162           for func in PythonFunctions.functions:
163               cls.contest[func] = functools.partial(getattr(PythonFunctions, func), program=cls.program, variables=cls.variables, path=cls.path)
164   
165       @classmethod
166       def add(cls, program):
167           if not cls.inited:
168               cls.init()
169   
170           exec(program, cls.contest)
171   
172       @classmethod
173       def run(cls, program, args, kwargs):
174           return cls.contest["run"](program, args=args, kwargs=kwargs)
175   
176   
177   @functools.lru_cache(None)
178   def pythonCheckHaveFunction(text):
179       pattern = r'\bdef\s+run\s*\('
180   
181       match = re.search(pattern, text)
182   
183       return bool(match)
184   
185   
186   def python(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
187       queue = []
188   
189       for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
190           queue.append(name["id"])
191   
192       if nodes["objects"][str(id)]["inputs"]["text"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["text"]["value"]["value"] is not None:
193           text = str(nodes["objects"][str(id)]["inputs"]["text"]["value"]["value"])
194   
195       else:
196           text = (str(nodes["objects"][str(id)]["inputs"]["text"]["standard"]))
197   
198       if nodes["objects"][str(id)]["inputs"]["list"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"] is not None:
199           list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"])
200   
201       else:
202           list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["standard"])
203   
204       if nodes["objects"][str(id)]["inputs"]["dict"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["dict"]["value"]["value"] is not None:
205           dict_ = dict(nodes["objects"][str(id)]["inputs"]["dict"]["value"]["value"])
206   
207       else:
208           dict_ = dict(nodes["objects"][str(id)]["inputs"]["dict"]["standard"])
209   
210       if PythonCodeExecutor.program is None:
211           PythonCodeExecutor.variables = variables
212           PythonCodeExecutor.program = program
213   
214           PythonCodeExecutor.path = path
215   
216       PythonCodeExecutor.add(text)
217   
218       if pythonCheckHaveFunction(text):
219           listOutput = PythonCodeExecutor.run(program, list_, dict_)
220   
221       else:
222           listOutput = []
223   
224       if listOutput is None:
225           listOutput = []
226   
227       elif not isinstance(listOutput, list):
228           listOutput = [listOutput]
229   
230       else:
231           pass
232   
233       for ids, connector in nodes["objects"][str(id)]["outputs"]["answer"]["value"].items():
234           nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = listOutput
235   
236       return queue
237   
##### scr\code\program\another\random_.py #####
1     import random
2     
3     
4     def random_(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
5         queue = []
6     
7         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
8             queue.append(name["id"])
9     
10         if nodes["objects"][str(id)]["inputs"]["a"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["a"]["value"]["value"] is not None:
11            a = int(nodes["objects"][str(id)]["inputs"]["a"]["value"]["value"])
12    
13        else:
14            a = int(nodes["objects"][str(id)]["inputs"]["a"]["standard"])
15    
16        if nodes["objects"][str(id)]["inputs"]["b"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["b"]["value"]["value"] is not None:
17            b = int(nodes["objects"][str(id)]["inputs"]["b"]["value"]["value"])
18    
19        else:
20            b = int(nodes["objects"][str(id)]["inputs"]["b"]["standard"])
21    
22        answer = a if a == b else random.randint(a, b)
23    
24        for ids, connector in nodes["objects"][str(id)]["outputs"]["answer"]["value"].items():
25            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer
26    
27        return queue
28    
##### scr\code\program\another\setVar.py #####
1     def setVar(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["name"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"] is not None:
8             name = str(nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"])
9     
10         else:
11            name = str(nodes["objects"][str(id)]["inputs"]["name"]["standard"])
12    
13        if nodes["objects"][str(id)]["inputs"]["global"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["global"]["value"]["value"] is not None:
14            gl = nodes["objects"][str(id)]["inputs"]["global"]["value"]["value"]
15    
16        else:
17            gl = nodes["objects"][str(id)]["inputs"]["global"]["standard"]
18    
19        try:
20            if nodes["objects"][str(id)]["inputs"]["value"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["value"]["value"]["value"] is not None:
21                value = eval(nodes["objects"][str(id)]["inputs"]["value"]["value"]["value"])
22    
23            else:
24                value = eval(nodes["objects"][str(id)]["inputs"]["value"]["standard"])
25    
26        except BaseException:
27            if nodes["objects"][str(id)]["inputs"]["value"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["value"]["value"]["value"] is not None:
28                value = nodes["objects"][str(id)]["inputs"]["value"]["value"]["value"]
29    
30            else:
31                value = nodes["objects"][str(id)]["inputs"]["value"]["standard"]
32    
33        if gl:
34            type = variables["globals"][name]["type"]
35    
36        else:
37            type = variables["locals"][path][name]["type"]
38    
39        if type == "number":
40            value = float(value) if float(value) - int(value) != 0 else int(value)
41    
42        if gl:
43            variables["globals"][name]["value"] = value
44    
45        else:
46            variables["locals"][path][name]["value"] = value
47    
48        return queue
49    
##### scr\code\program\event\everyFrame.py #####
1     def everyFrame(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         return queue
8     
##### scr\code\program\event\everyTick.py #####
1     def everyTick(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         return queue
8     
##### scr\code\program\event\forDictElements.py #####
1     def forDictElements(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         timer = []
3         queue = []
4     
5         if nodes["objects"][str(id)]["inputs"]["dict"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["dict"]["value"]["value"] is not None:
6             dict_ = dict(nodes["objects"][str(id)]["inputs"]["dict"]["value"]["value"])
7     
8         else:
9             dict_ = dict(nodes["objects"][str(id)]["inputs"]["dict"]["standard"])
10     
11        for key, value in dict_.items():
12            for ids, connector in nodes["objects"][str(id)]["outputs"]["key"]["value"].items():
13                nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = key
14    
15            for ids, connector in nodes["objects"][str(id)]["outputs"]["element"]["value"].items():
16                nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = value
17    
18            for name in nodes["objects"][str(id)]["outputs"]["iterator"]["value"].values():
19                compiler.queue(name["id"])
20    
21        for name in nodes["objects"][str(id)]["outputs"]["after"]["value"].values():
22            queue.append(name["id"])
23    
24        return {"queue": queue, "timer": timer}
25    
##### scr\code\program\event\forListElements.py #####
1     def forListElements(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         timer = []
3         queue = []
4     
5         if nodes["objects"][str(id)]["inputs"]["list"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"] is not None:
6             list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"])
7     
8         else:
9             list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["standard"])
10     
11        for i, element in enumerate(list_):
12            for ids, connector in nodes["objects"][str(id)]["outputs"]["index"]["value"].items():
13                nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = i
14    
15            for ids, connector in nodes["objects"][str(id)]["outputs"]["element"]["value"].items():
16                nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = element
17    
18            for name in nodes["objects"][str(id)]["outputs"]["iterator"]["value"].values():
19                compiler.queue(name["id"])
20    
21        for name in nodes["objects"][str(id)]["outputs"]["after"]["value"].values():
22            queue.append(name["id"])
23    
24        return {"queue": queue, "timer": timer}
25    
##### scr\code\program\event\forObjectsGroup.py #####
1     def forObjectsGroup(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         if nodes["objects"][str(id)]["inputs"]["group"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["group"]["value"]["value"] is not None:
5             group = str(nodes["objects"][str(id)]["inputs"]["group"]["value"]["value"])
6     
7         else:
8             group = str(nodes["objects"][str(id)]["inputs"]["group"]["standard"])
9     
10         """
11        for ids, connector in nodes["objects"][str(id)]["outputs"]["x"]["value"].items():
12            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = pos.x
13        """
14    
15        objects = program.objects.getByGroup(group)
16        n = len(objects)
17    
18        for i, obj in enumerate(objects):
19            for ids, connector in nodes["objects"][str(id)]["outputs"]["id"]["value"].items():
20                nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = obj.id
21    
22            for name in nodes["objects"][str(id)]["outputs"]["iterator"]["value"].values():
23                compiler.queue(name["id"])
24    
25        for name in nodes["objects"][str(id)]["outputs"]["after"]["value"].values():
26            queue.append(name["id"])
27    
28        return queue
29    
##### scr\code\program\event\for_.py #####
1     def for_(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         timer = []
3         queue = []
4     
5         if nodes["objects"][str(id)]["inputs"]["n"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["n"]["value"]["value"] is not None:
6             n = int(float(nodes["objects"][str(id)]["inputs"]["n"]["value"]["value"]))
7     
8         else:
9             n = int(float(nodes["objects"][str(id)]["inputs"]["n"]["standard"]))
10     
11        if nodes["objects"][str(id)]["inputs"]["x"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["x"]["value"]["value"] is not None:
12            x = int(float(nodes["objects"][str(id)]["inputs"]["x"]["value"]["value"]))
13    
14        else:
15            x = int(float(nodes["objects"][str(id)]["inputs"]["x"]["standard"]))
16    
17        """
18        for ids, connector in nodes["objects"][str(id)]["outputs"]["x"]["value"].items():
19            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = pos.x
20        """
21    
22        if nodes["objects"][str(id)]["inputs"]["n"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["n"]["value"]["value"] is not None:
23            nodes["objects"][str(id)]["inputs"]["n"]["value"]["value"] -= 1
24    
25        if x == 0:
26            for i in range(n):
27                for ids, connector in nodes["objects"][str(id)]["outputs"]["index"]["value"].items():
28                    nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = i
29    
30                for name in nodes["objects"][str(id)]["outputs"]["iterator"]["value"].values():
31                    compiler.queue(name["id"])
32    
33        else:
34            for name in nodes["objects"][str(id)]["outputs"]["iterator"]["value"].values():
35                queue.append(name["id"])
36    
37            for ids, connector in nodes["objects"][str(id)]["outputs"]["index"]["value"].items():
38                nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = 0
39    
40            timer.append({"id": id, "count": n - 1, "timer": x, "tmax": x, "connector": "iterator", "iter": 0})
41    
42        return {"queue": queue, "timer": timer}
43    
##### scr\code\program\event\keyboardClick.py #####
1     def keyboardClick(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         return queue
8     
##### scr\code\program\event\keyboardPress.py #####
1     def keyboardPress(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         return queue
8     
##### scr\code\program\event\mouseLeftClick.py #####
1     def mouseLeftClick(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         return queue
8     
##### scr\code\program\event\mouseRightClick.py #####
1     def mouseRightClick(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         return queue
8     
##### scr\code\program\event\onStartGame.py #####
1     def onStartGame(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         return queue
8     
##### scr\code\program\logic\ifCollision.py #####
1     def ifCollision(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
5             ids = int(nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"])
6     
7         else:
8             ids = int(nodes["objects"][str(id)]["inputs"]["id"]["standard"])
9     
10         if nodes["objects"][str(id)]["inputs"]["group"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["group"]["value"]["value"] is not None:
11            group = nodes["objects"][str(id)]["inputs"]["group"]["value"]["value"]
12    
13        else:
14            group = nodes["objects"][str(id)]["inputs"]["group"]["standard"]
15    
16        if nodes["objects"][str(id)]["inputs"]["append"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["append"]["value"]["value"] is not None:
17            append = (nodes["objects"][str(id)]["inputs"]["append"]["value"]["value"] == True)
18    
19        else:
20            append = (nodes["objects"][str(id)]["inputs"]["append"]["standard"] == True)
21    
22        obj = program.objects.getById(ids)
23    
24        answer = obj.collisionGetID(0, 0, append, group) if obj is not None else [False, -1]
25    
26        if answer[0]:
27            for name in nodes["objects"][str(id)]["outputs"]["path_true"]["value"].values():
28                queue.append(name["id"])
29    
30            for ids, connector in nodes["objects"][str(id)]["outputs"]["id_in_group"]["value"].items():
31                nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer[1].id
32    
33        else:
34            for name in nodes["objects"][str(id)]["outputs"]["path_false"]["value"].values():
35                queue.append(name["id"])
36    
37            for ids, connector in nodes["objects"][str(id)]["outputs"]["id_in_group"]["value"].items():
38                nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = -1
39    
40        return queue
41    
##### scr\code\program\logic\if_.py #####
1     OPERATIONS = ["0. ==", "1. !=", "2. <=", "3. >=", "4. <", "5. >"]
2     
3     
4     def if_(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
5         queue = []
6     
7         if nodes["objects"][str(id)]["inputs"]["a"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["a"]["value"]["value"] is not None:
8             a = nodes["objects"][str(id)]["inputs"]["a"]["value"]["value"]
9     
10         else:
11            a = nodes["objects"][str(id)]["inputs"]["a"]["standard"]
12    
13        if nodes["objects"][str(id)]["inputs"]["b"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["b"]["value"]["value"] is not None:
14            b = nodes["objects"][str(id)]["inputs"]["b"]["value"]["value"]
15    
16        else:
17            b = nodes["objects"][str(id)]["inputs"]["b"]["standard"]
18    
19        if nodes["objects"][str(id)]["inputs"]["operation"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["operation"]["value"]["value"] is not None:
20            operation = int(nodes["objects"][str(id)]["inputs"]["operation"]["value"]["value"])
21    
22        else:
23            operation = int(nodes["objects"][str(id)]["inputs"]["operation"]["standard"])
24    
25        if eval(f"{a} {OPERATIONS[operation][3:]} {b}"):
26            for name in nodes["objects"][str(id)]["outputs"]["path_true"]["value"].values():
27                queue.append(name["id"])
28    
29        else:
30            for name in nodes["objects"][str(id)]["outputs"]["path_false"]["value"].values():
31                queue.append(name["id"])
32    
33        return queue
34    
##### scr\code\program\numbers\divide.py #####
1     import math
2     
3     
4     def divide(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
5         queue = []
6     
7         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
8             queue.append(name["id"])
9     
10         if nodes["objects"][str(id)]["inputs"]["a"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["a"]["value"]["value"] is not None:
11            a = float(nodes["objects"][str(id)]["inputs"]["a"]["value"]["value"])
12    
13        else:
14            a = float(nodes["objects"][str(id)]["inputs"]["a"]["standard"])
15    
16        if nodes["objects"][str(id)]["inputs"]["b"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["b"]["value"]["value"] is not None:
17            b = float(nodes["objects"][str(id)]["inputs"]["b"]["value"]["value"])
18    
19        else:
20            b = float(nodes["objects"][str(id)]["inputs"]["b"]["standard"])
21    
22        answer = int(a // b) if math.trunc(round(a / b, 10)) == math.ceil(round(a / b, 10)) else round(a / b, 10)
23    
24        for ids, connector in nodes["objects"][str(id)]["outputs"]["answer"]["value"].items():
25            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer
26    
27        return queue
28    
##### scr\code\program\numbers\minus.py #####
1     import math
2     
3     
4     def minus(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
5         queue = []
6     
7         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
8             queue.append(name["id"])
9     
10         if nodes["objects"][str(id)]["inputs"]["a"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["a"]["value"]["value"] is not None:
11            a = float(nodes["objects"][str(id)]["inputs"]["a"]["value"]["value"])
12    
13        else:
14            a = float(nodes["objects"][str(id)]["inputs"]["a"]["standard"])
15    
16        if nodes["objects"][str(id)]["inputs"]["b"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["b"]["value"]["value"] is not None:
17            b = float(nodes["objects"][str(id)]["inputs"]["b"]["value"]["value"])
18    
19        else:
20            b = float(nodes["objects"][str(id)]["inputs"]["b"]["standard"])
21    
22        answer = int(a - b) if math.trunc(round(a - b, 10)) == math.ceil(round(a - b, 10)) else round(a - b, 10)
23    
24        for ids, connector in nodes["objects"][str(id)]["outputs"]["answer"]["value"].items():
25            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer
26    
27        return queue
28    
##### scr\code\program\numbers\multiply.py #####
1     import math
2     
3     
4     def multiply(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
5         queue = []
6     
7         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
8             queue.append(name["id"])
9     
10         if nodes["objects"][str(id)]["inputs"]["a"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["a"]["value"]["value"] is not None:
11            a = float(nodes["objects"][str(id)]["inputs"]["a"]["value"]["value"])
12    
13        else:
14            a = float(nodes["objects"][str(id)]["inputs"]["a"]["standard"])
15    
16        if nodes["objects"][str(id)]["inputs"]["b"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["b"]["value"]["value"] is not None:
17            b = float(nodes["objects"][str(id)]["inputs"]["b"]["value"]["value"])
18    
19        else:
20            b = float(nodes["objects"][str(id)]["inputs"]["b"]["standard"])
21    
22        answer = int(a * b) if math.trunc(round(a * b, 10)) == math.ceil(round(a * b, 10)) else round(a * b, 10)
23    
24        for ids, connector in nodes["objects"][str(id)]["outputs"]["answer"]["value"].items():
25            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer
26    
27        return queue
28    
##### scr\code\program\numbers\plus.py #####
1     import math
2     
3     
4     def plus(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
5         queue = []
6     
7         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
8             queue.append(name["id"])
9     
10         if nodes["objects"][str(id)]["inputs"]["a"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["a"]["value"]["value"] is not None:
11            a = float(nodes["objects"][str(id)]["inputs"]["a"]["value"]["value"])
12    
13        else:
14            a = float(nodes["objects"][str(id)]["inputs"]["a"]["standard"])
15    
16        if nodes["objects"][str(id)]["inputs"]["b"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["b"]["value"]["value"] is not None:
17            b = float(nodes["objects"][str(id)]["inputs"]["b"]["value"]["value"])
18    
19        else:
20            b = float(nodes["objects"][str(id)]["inputs"]["b"]["standard"])
21    
22        answer = int(a + b) if math.trunc(round(a + b, 10)) == math.ceil(round(a + b, 10)) else round(a + b, 10)
23    
24        for ids, connector in nodes["objects"][str(id)]["outputs"]["answer"]["value"].items():
25            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer
26    
27        return queue
28    
##### scr\code\program\objects\createObject.py #####
1     def createObject(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["name"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"] is not None:
8             name = str(nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"])
9     
10         else:
11            name = str(nodes["objects"][str(id)]["inputs"]["name"]["standard"])
12    
13        if nodes["objects"][str(id)]["inputs"]["x"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["x"]["value"]["value"] is not None:
14            x = float(nodes["objects"][str(id)]["inputs"]["x"]["value"]["value"])
15    
16        else:
17            x = float(nodes["objects"][str(id)]["inputs"]["x"]["standard"])
18    
19        if nodes["objects"][str(id)]["inputs"]["y"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["y"]["value"]["value"] is not None:
20            y = float(nodes["objects"][str(id)]["inputs"]["y"]["value"]["value"])
21    
22        else:
23            y = float(nodes["objects"][str(id)]["inputs"]["y"]["standard"])
24    
25        if not name.endswith(".obj"):
26            name += ".obj"
27    
28        type = program.allObjects[name]["type"]
29        variables = program.allObjects[name]["variables"]
30    
31        variables["pos"] = [x, y]
32    
33        obj = getattr(program.linkEngine.objects, type)(program, **variables)
34    
35        # print(obj.pos, obj.hitbox, len(program.objects.objects), variables)
36    
37        program.objects.add(obj)
38    
39        for ids, connector in nodes["objects"][str(id)]["outputs"]["id"]["value"].items():
40            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = obj.id
41    
42        return queue
43    
##### scr\code\program\objects\getObjectIDByName.py #####
1     def getObjectIDByName(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["name"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"] is not None:
8             name = str(nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"])
9     
10         else:
11            name = str(nodes["objects"][str(id)]["inputs"]["name"]["standard"])
12    
13        name = name + ".objc" if not name.endswith(".objc") else name
14    
15        answer = program.objectIDByName[program.scene][name] if name in program.objectIDByName[program.scene] else -1
16    
17        for ids, connector in nodes["objects"][str(id)]["outputs"]["id"]["value"].items():
18            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer
19    
20        return queue
21    
##### scr\code\program\objects\getObjectPos.py #####
1     def getObjectPos(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
8             ids = int(nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"])
9     
10         else:
11            ids = int(nodes["objects"][str(id)]["inputs"]["id"]["standard"])
12    
13        pos = program.objects.getById(ids).pos
14    
15        for ids, connector in nodes["objects"][str(id)]["outputs"]["x"]["value"].items():
16            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = pos.x
17    
18        for ids, connector in nodes["objects"][str(id)]["outputs"]["y"]["value"].items():
19            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = pos.y
20    
21        return queue
22    
##### scr\code\program\objects\getObjectVar.py #####
1     def getObjectVar(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["name"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"] is not None:
8             name = str(nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"])
9     
10         else:
11            name = str(nodes["objects"][str(id)]["inputs"]["name"]["standard"])
12    
13        if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
14            ids = nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"]
15    
16        else:
17            ids = nodes["objects"][str(id)]["inputs"]["id"]["standard"]
18    
19        answer = variables["objects"][program.scene][program.objectNameByID[program.scene][str(ids)]][name]["value"]
20    
21        for ids, connector in nodes["objects"][str(id)]["outputs"]["answer"]["value"].items():
22            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer
23    
24        return queue
25    
##### scr\code\program\objects\getResultingVector.py #####
1     def getResultingVector(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
8             ids = int(nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"])
9     
10         else:
11            ids = int(nodes["objects"][str(id)]["inputs"]["id"]["standard"])
12    
13        pos = program.objects.getById(ids).getVectorsPower()
14    
15        for ids, connector in nodes["objects"][str(id)]["outputs"]["x"]["value"].items():
16            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = pos.x
17    
18        for ids, connector in nodes["objects"][str(id)]["outputs"]["y"]["value"].items():
19            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = pos.y
20    
21        return queue
22    
##### scr\code\program\objects\jump.py #####
1     def jump(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
8             ids = str(nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"])
9     
10         else:
11            ids = str(nodes["objects"][str(id)]["inputs"]["id"]["standard"])
12    
13        obj = program.objects.getById(int(ids))
14    
15        obj.moveByType("jump")
16    
17        return queue
18    
##### scr\code\program\objects\moveObject.py #####
1     def moveObject(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
8             ids = str(nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"])
9     
10         else:
11            ids = str(nodes["objects"][str(id)]["inputs"]["id"]["standard"])
12    
13        if nodes["objects"][str(id)]["inputs"]["angle"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["angle"]["value"]["value"] is not None:
14            angle = float(nodes["objects"][str(id)]["inputs"]["angle"]["value"]["value"])
15    
16        else:
17            angle = float(nodes["objects"][str(id)]["inputs"]["angle"]["standard"])
18    
19        if nodes["objects"][str(id)]["inputs"]["power"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["power"]["value"]["value"] is not None:
20            power = float(nodes["objects"][str(id)]["inputs"]["power"]["value"]["value"])
21    
22        else:
23            power = float(nodes["objects"][str(id)]["inputs"]["power"]["standard"])
24    
25        obj = program.objects.getById(int(ids))
26    
27        obj.moveByAngle(angle, power, specifical=id)
28    
29        return queue
30    
##### scr\code\program\objects\removeObject.py #####
1     def removeObject(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
8             ids = int(nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"])
9     
10         else:
11            ids = int(nodes["objects"][str(id)]["inputs"]["id"]["standard"])
12    
13        program.objects.removeById(ids)
14    
15        return queue
16    
##### scr\code\program\objects\setObjectPos.py #####
1     def setObjectPos(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
8             ids = str(nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"])
9     
10         else:
11            ids = str(nodes["objects"][str(id)]["inputs"]["id"]["standard"])
12    
13        if nodes["objects"][str(id)]["inputs"]["x"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["x"]["value"]["value"] is not None:
14            x = float(nodes["objects"][str(id)]["inputs"]["x"]["value"]["value"])
15    
16        else:
17            x = float(nodes["objects"][str(id)]["inputs"]["x"]["standard"])
18    
19        if nodes["objects"][str(id)]["inputs"]["y"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["y"]["value"]["value"] is not None:
20            y = float(nodes["objects"][str(id)]["inputs"]["y"]["value"]["value"])
21    
22        else:
23            y = float(nodes["objects"][str(id)]["inputs"]["y"]["standard"])
24    
25        obj = program.objects.getById(int(ids))
26    
27        obj.pos.x = x
28        obj.pos.y = y
29    
30        return queue
31    
##### scr\code\program\objects\setObjectVar.py #####
1     def setObjectVar(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["name"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"] is not None:
8             name = str(nodes["objects"][str(id)]["inputs"]["name"]["value"]["value"])
9     
10         else:
11            name = str(nodes["objects"][str(id)]["inputs"]["name"]["standard"])
12    
13        if nodes["objects"][str(id)]["inputs"]["id"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"] is not None:
14            ids = nodes["objects"][str(id)]["inputs"]["id"]["value"]["value"]
15    
16        else:
17            ids = nodes["objects"][str(id)]["inputs"]["id"]["standard"]
18    
19        if nodes["objects"][str(id)]["inputs"]["value"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["value"]["value"]["value"] is not None:
20            value = nodes["objects"][str(id)]["inputs"]["value"]["value"]["value"]
21    
22        else:
23            value = nodes["objects"][str(id)]["inputs"]["value"]["standard"]
24    
25        type = variables["objects"][program.scene][program.objectNameByID[program.scene][str(ids)]][name]["type"]
26    
27        if type == "number":
28            value = float(value)
29    
30        variables["objects"][program.scene][program.objectNameByID[program.scene][str(ids)]][name]["value"] = value
31    
32        return queue
33    
##### scr\code\program\set\addDictElement.py #####
1     def addDictElement(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["dict"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["dict"]["value"]["value"] is not None:
8             dict_ = dict(nodes["objects"][str(id)]["inputs"]["dict"]["value"]["value"])
9     
10         else:
11            dict_ = dict(nodes["objects"][str(id)]["inputs"]["dict"]["standard"])
12    
13        if nodes["objects"][str(id)]["inputs"]["key"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["key"]["value"]["value"] is not None:
14            key = str(nodes["objects"][str(id)]["inputs"]["key"]["value"]["value"])
15    
16        else:
17            key = str(nodes["objects"][str(id)]["inputs"]["key"]["standard"])
18    
19        if nodes["objects"][str(id)]["inputs"]["element"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"] is not None:
20            element = eval(nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"])
21    
22        else:
23            element = eval(nodes["objects"][str(id)]["inputs"]["element"]["standard"])
24    
25        dict_[key] = element
26    
27        for ids, connector in nodes["objects"][str(id)]["outputs"]["dict"]["value"].items():
28            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = dict_
29    
30        return queue
31    
##### scr\code\program\set\addListElement.py #####
1     def addListElement(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["list"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"] is not None:
8             list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"])
9     
10         else:
11            list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["standard"])
12    
13        if nodes["objects"][str(id)]["inputs"]["element"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"] is not None:
14            if type(nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"]) == str:
15                element = eval(nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"])
16    
17            else:
18                element = eval(str(nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"]))
19    
20        else:
21            if type(nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"]) == str:
22                element = eval(nodes["objects"][str(id)]["inputs"]["element"]["standard"])
23    
24            else:
25                element = eval(str(nodes["objects"][str(id)]["inputs"]["element"]["standard"]))
26    
27        list_.append(element)
28    
29        for ids, connector in nodes["objects"][str(id)]["outputs"]["list"]["value"].items():
30            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = list_
31    
32        return queue
33    
##### scr\code\program\set\deleteByIndex.py #####
1     def deleteByIndex(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["list"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"] is not None:
8             list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"])
9     
10         else:
11            list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["standard"])
12    
13        if nodes["objects"][str(id)]["inputs"]["index"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["index"]["value"]["value"] is not None:
14            index = int(nodes["objects"][str(id)]["inputs"]["index"]["value"]["value"])
15    
16        else:
17            index = int(nodes["objects"][str(id)]["inputs"]["index"]["standard"])
18    
19        list_.pop(index)
20    
21        for ids, connector in nodes["objects"][str(id)]["outputs"]["list"]["value"].items():
22            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = list_
23    
24        return queue
25    
##### scr\code\program\set\getByIndex.py #####
1     def getByIndex(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["list"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"] is not None:
8             list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"])
9     
10         else:
11            list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["standard"])
12    
13        if nodes["objects"][str(id)]["inputs"]["index"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["index"]["value"]["value"] is not None:
14            index = int(nodes["objects"][str(id)]["inputs"]["index"]["value"]["value"])
15    
16        else:
17            index = int(nodes["objects"][str(id)]["inputs"]["index"]["standard"])
18    
19        answer = list_[index]
20    
21        for ids, connector in nodes["objects"][str(id)]["outputs"]["element"]["value"].items():
22            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer
23    
24        return queue
25    
##### scr\code\program\set\getByKey.py #####
1     def getByKey(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["dict"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["dict"]["value"]["value"] is not None:
8             dict_ = dict(nodes["objects"][str(id)]["inputs"]["dict"]["value"]["value"])
9     
10         else:
11            dict_ = dict(nodes["objects"][str(id)]["inputs"]["dict"]["standard"])
12    
13        if nodes["objects"][str(id)]["inputs"]["key"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["key"]["value"]["value"] is not None:
14            key = str(nodes["objects"][str(id)]["inputs"]["key"]["value"]["value"])
15    
16        else:
17            key = str(nodes["objects"][str(id)]["inputs"]["key"]["standard"])
18    
19        answer = dict_[key]
20    
21        for ids, connector in nodes["objects"][str(id)]["outputs"]["element"]["value"].items():
22            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer
23    
24        return queue
25    
##### scr\code\program\set\getIndexOfElement.py #####
1     def getIndexOfElement(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["list"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"] is not None:
8             list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"])
9     
10         else:
11            list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["standard"])
12    
13        if nodes["objects"][str(id)]["inputs"]["element"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"] is not None:
14            element = str(nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"])
15    
16        else:
17            element = str(nodes["objects"][str(id)]["inputs"]["element"]["standard"])
18    
19        answer = -1
20    
21        for index, elem in enumerate(list_):
22            if str(elem) == str(element):
23                answer = index
24    
25                break
26    
27        for ids, connector in nodes["objects"][str(id)]["outputs"]["index"]["value"].items():
28            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer
29    
30        return queue
31    
##### scr\code\program\set\getKeyOfElement.py #####
1     def getKeyOfElement(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["dict"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["dict"]["value"]["value"] is not None:
8             dict_ = dict(nodes["objects"][str(id)]["inputs"]["dict"]["value"]["value"])
9     
10         else:
11            dict_ = dict(nodes["objects"][str(id)]["inputs"]["dict"]["standard"])
12    
13        if nodes["objects"][str(id)]["inputs"]["element"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"] is not None:
14            element = str(nodes["objects"][str(id)]["inputs"]["element"]["value"]["value"])
15    
16        else:
17            element = str(nodes["objects"][str(id)]["inputs"]["element"]["standard"])
18    
19        answer = "NULL"
20    
21        for key, value in dict_.items():
22            if str(value) == str(element):
23                answer = key
24    
25                break
26    
27        for ids, connector in nodes["objects"][str(id)]["outputs"]["key"]["value"].items():
28            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer
29    
30        return queue
31    
##### scr\code\program\set\removeByKey.py #####
1     def removeByKey(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["dict"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["dict"]["value"]["value"] is not None:
8             dict_ = dict(nodes["objects"][str(id)]["inputs"]["dict"]["value"]["value"])
9     
10         else:
11            dict_ = dict(nodes["objects"][str(id)]["inputs"]["dict"]["standard"])
12    
13        if nodes["objects"][str(id)]["inputs"]["key"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["key"]["value"]["value"] is not None:
14            key = str(nodes["objects"][str(id)]["inputs"]["key"]["value"]["value"])
15    
16        else:
17            key = str(nodes["objects"][str(id)]["inputs"]["key"]["standard"])
18    
19        if key in dict_:
20            dict_.pop(key)
21    
22        for ids, connector in nodes["objects"][str(id)]["outputs"]["dict"]["value"].items():
23            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = dict_
24    
25        return queue
26    
##### scr\code\program\set\sliceList.py #####
1     def sliceList(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["list"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"] is not None:
8             list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["value"]["value"])
9     
10         else:
11            list_ = list(nodes["objects"][str(id)]["inputs"]["list"]["standard"])
12    
13        if nodes["objects"][str(id)]["inputs"]["start"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["start"]["value"]["value"] is not None:
14            start = int(nodes["objects"][str(id)]["inputs"]["start"]["value"]["value"])
15    
16        else:
17            start = int(nodes["objects"][str(id)]["inputs"]["start"]["standard"])
18    
19        if nodes["objects"][str(id)]["inputs"]["end"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["end"]["value"]["value"] is not None:
20            end = int(nodes["objects"][str(id)]["inputs"]["end"]["value"]["value"])
21    
22        else:
23            end = int(nodes["objects"][str(id)]["inputs"]["end"]["standard"])
24    
25        answer = list_[start:(None if end == -1 else end + 1)]
26    
27        for ids, connector in nodes["objects"][str(id)]["outputs"]["list"]["value"].items():
28            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer
29    
30        return queue
31    
##### scr\code\program\text\connectText.py #####
1     def connectText(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["text1"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["text1"]["value"]["value"] is not None:
8             text1 = str(nodes["objects"][str(id)]["inputs"]["text1"]["value"]["value"])
9     
10         else:
11            text1 = str(nodes["objects"][str(id)]["inputs"]["text1"]["standard"])
12    
13        if nodes["objects"][str(id)]["inputs"]["text2"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["text2"]["value"]["value"] is not None:
14            text2 = str(nodes["objects"][str(id)]["inputs"]["text2"]["value"]["value"])
15    
16        else:
17            text2 = str(nodes["objects"][str(id)]["inputs"]["text2"]["standard"])
18    
19        answer = text1 + text2
20    
21        for ids, connector in nodes["objects"][str(id)]["outputs"]["text"]["value"].items():
22            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer
23    
24        return queue
25    
##### scr\code\program\text\displayText.py #####
1     def displayText(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["text"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["text"]["value"]["value"] is not None:
8             text = str(nodes["objects"][str(id)]["inputs"]["text"]["value"]["value"])
9     
10         else:
11            text = str(nodes["objects"][str(id)]["inputs"]["text"]["standard"])
12    
13        if nodes["objects"][str(id)]["inputs"]["x"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["x"]["value"]["value"] is not None:
14            x = int(nodes["objects"][str(id)]["inputs"]["x"]["value"]["value"])
15    
16        else:
17            x = int(nodes["objects"][str(id)]["inputs"]["x"]["standard"])
18    
19        if nodes["objects"][str(id)]["inputs"]["y"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["y"]["value"]["value"] is not None:
20            y = int(nodes["objects"][str(id)]["inputs"]["y"]["value"]["value"])
21    
22        else:
23            y = int(nodes["objects"][str(id)]["inputs"]["y"]["standard"])
24    
25        program.afterDrawing.append(lambda: program.linkEngine.print_text(program.screen, x, y, text))
26    
27        return queue
28    
##### scr\code\program\text\sliceText.py #####
1     def sliceText(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["text"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["text"]["value"]["value"] is not None:
8             text = str(nodes["objects"][str(id)]["inputs"]["text"]["value"]["value"])
9     
10         else:
11            text = str(nodes["objects"][str(id)]["inputs"]["text"]["standard"])
12    
13        if nodes["objects"][str(id)]["inputs"]["start"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["start"]["value"]["value"] is not None:
14            start = int(nodes["objects"][str(id)]["inputs"]["start"]["value"]["value"])
15    
16        else:
17            start = int(nodes["objects"][str(id)]["inputs"]["start"]["standard"])
18    
19        if nodes["objects"][str(id)]["inputs"]["end"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["end"]["value"]["value"] is not None:
20            end = int(nodes["objects"][str(id)]["inputs"]["end"]["value"]["value"])
21    
22        else:
23            end = int(nodes["objects"][str(id)]["inputs"]["end"]["standard"])
24    
25        answer = text[start:(None if end == -1 else end + 1)]
26    
27        for ids, connector in nodes["objects"][str(id)]["outputs"]["text"]["value"].items():
28            nodes["objects"][str(ids)]["inputs"][connector["name"]]["value"]["value"] = answer
29    
30        return queue
31    
##### scr\code\program\text\writeText.py #####
1     def writeText(program, compiler, path: str, nodes: dict, id: int, variables: dict) -> dict:
2         queue = []
3     
4         for name in nodes["objects"][str(id)]["outputs"]["path"]["value"].values():
5             queue.append(name["id"])
6     
7         if nodes["objects"][str(id)]["inputs"]["text"]["value"] is not None and nodes["objects"][str(id)]["inputs"]["text"]["value"]["value"] is not None:
8             text = str(nodes["objects"][str(id)]["inputs"]["text"]["value"]["value"])
9     
10         else:
11            text = str(nodes["objects"][str(id)]["inputs"]["text"]["standard"])
12    
13        line = True
14    
15        answer = ">>> " + text.rstrip() + "\n" if line else ">>> " + text.rstrip()
16    
17        program.print(answer)
18    
19        print(answer)
20    
21        return queue
22    
##### scr\main.py #####
1     from PyQt5.QtWidgets import QMainWindow, QApplication, QTreeWidget, QStatusBar, QAction, QTreeWidgetItem, QShortcut, QPushButton
2     from PyQt5.QtGui import QKeySequence
3     from PyQt5.Qt import QIcon, Qt
4     
5     from scr.modules.widgets import TabFileBar, VersionLogScrollArea
6     
7     from scr.modules import functions
8     
9     from scr.variables import *
10     
11    import webbrowser
12    import qdarktheme
13    import threading
14    import requests
15    import ctypes
16    
17    
18    class FocusTreeWidget(QTreeWidget):
19        def __init__(self, parent=None):
20            QTreeWidget.__init__(self, parent)
21    
22            self.project = parent
23    
24        def mousePressEvent(self, event):
25            self.setFocus()
26    
27            event.accept()
28    
29    
30    class Main(QMainWindow):
31        def __init__(self, app) -> None:
32            try:
33                ctypes.windll.shcore.SetProcessDpiAwareness(True)
34    
35            except AttributeError:
36                pass
37    
38            QMainWindow.__init__(self)
39    
40            self.app = app
41    
42            qdarktheme.setup_theme(theme=SETTINGS["theme"])
43    
44            self.application = {}
45            self.engine = None
46    
47            self.dialog = None
48    
49            self.menubar = None
50    
51            self.selectProject = ""
52            self.selectFile = ""
53    
54            self.compiling = False
55    
56            self.desktop = QApplication.desktop()
57    
58            size["width"] = self.desktop.width()
59            size["height"] = self.desktop.height() - PLUS
60    
61            self.variables = {}
62            self.cash = {}
63    
64            self.objects = {}
65            self.menues = {}
66    
67            self.setGeometry(0, 0, int(size["width"] * 0.8), int(size["height"] * 0.8))
68            self.move((size["width"] - self.width()) // 2, (size["height"] - self.height()) // 2)
69    
70            self.shortcut()
71    
72            self.initialization()
73    
74            if not FLAGS["not-view-version-update"]:
75                self.versionUpdateMessage()
76    
77            self.init()
78    
79        def versionUpdateMessage(self) -> None:
80            def function():
81                thr = threading.Thread(target=lambda: webbrowser.open("https://artyom7774.github.io"))
82                thr.daemon = True
83                thr.start()
84    
85            url = "https://raw.githubusercontent.com/artyom7774/Game-Engine-3/main/scr/files/version.json"
86    
87            if functions.haveInternet():
88                response = requests.get(url)
89    
90                if response.status_code == 200:
91                    lastVersion = loads(response.text)["version"]
92                    nowVersion = load(open("scr/files/version.json", "r", encoding="utf-8"))["version"]
93    
94                    print(f"LOG: last version = {lastVersion}, now version = {nowVersion}")
95    
96                    if lastVersion != nowVersion:
97                        msg = QMessageBox()
98                        msg.setWindowTitle(f"{translate('Update')} {nowVersion} -> {lastVersion}")
99                        msg.setText(translate("A new version of the project has been released. Please update the product"))
100                        msg.setIcon(QMessageBox.Information)
101   
102                       openButton = QPushButton(translate("Open"))
103                       openButton.clicked.connect(lambda: function())
104   
105                       msg.addButton(openButton, QMessageBox.ActionRole)
106   
107                       okButton = msg.addButton(QMessageBox.Ok)
108   
109                       msg.exec_()
110   
111               else:
112                   print(f"ERROR: can't download now project version, status = {response.status_code}")
113   
114           else:
115               print("ERROR: can't download now project version, bad internet connection")
116   
117       def install(self) -> None:
118           if SYSTEM == "Windows":
119               os.system("setup.bat")
120   
121           elif SYSTEM == "Linux":
122               os.system("chmod +x setup.sh")
123               os.system("./setup.sh")
124   
125           else:
126               print("ERROR: system (Unknown) not supported install python")
127   
128           with open("python/.gitignore", "w", encoding="utf-8") as file:
129               file.write("*")
130   
131       def geometryInit(self) -> None:
132           if "main" in self.objects and "object_variables" in self.objects["main"]:
133               try:
134                   self.objects["main"]["object_variables"].hide()
135   
136                   self.objects["main"]["object_variables"].deleteLater()
137   
138               except RuntimeError:
139                   pass
140   
141           if "main" in self.objects and "variables" in self.objects["main"]:
142               for element in self.objects["main"]["variables"].values():
143                   try:
144                       element.hide()
145   
146                       element.deleteLater()
147   
148                   except RuntimeError:
149                       pass
150   
151           try:
152               self.objects["tree_project"].hide()
153   
154           except BaseException:
155               return 0
156   
157           self.objects["tree_project"].hide()
158           self.objects["tab_file_bar"].hide()
159           self.objects["center_rama"].hide()
160   
161           self.objects["version_log"].hide()
162   
163           if self.selectProject != "":
164               self.objects["tree_project"].show()
165               self.objects["tree_project"].setGeometry(10, 40, Size.x(16), Size.y(100) - 70)
166   
167               self.objects["tree_project_main"].setText(0, self.selectProject)
168   
169               self.objects["center_rama"].show()
170               self.objects["center_rama"].setGeometry(10 + 10 + Size.x(16), 40 + 30, Size.x(68) - 40, Size.y(100) - 70 - 30)
171   
172               self.objects["tab_file_bar"].show()
173               self.objects["tab_file_bar"].setGeometry(10 + 10 + Size.x(16), 40, Size.x(68) - 40, 30)
174   
175               if "main" in self.objects and "code" in self.objects["main"]:
176                   try:
177                       self.objects["main"]["code"].hide()
178   
179                   except RuntimeError:
180                       pass
181   
182               functions.project.centerMenuInit(self)
183   
184           else:
185               self.objects["version_log"].show()
186               self.objects["version_log"].setGeometry(10, 10, Size.x(200) - 20, Size.y(100) - 20)
187   
188           if self.selectFile == "" and self.objects["tab_file_bar"].count() != 0:
189               self.selectFile = self.objects["tab_file_bar"].objects[self.objects["tab_file_bar"].currentIndex()]["name"]
190   
191           self.objects["status_bar"].showMessage(self.selectFile)
192   
193       def initialization(self) -> None:
194           def tabFileBarCurrentChanged(index: int) -> None:
195               if len(self.objects["tab_file_bar"].objects) == 0:
196                   return 0
197   
198               self.selectFile = self.objects["tab_file_bar"].objects[index]["name"]
199               functions.tree.open(self, self.selectFile)
200   
201           def tabFileBarTabCloseRequested(index: int) -> None:
202               if self.selectFile == self.objects["tab_file_bar"].getNameByIndex(index):
203                   self.selectFile = ""
204   
205                   self.init()
206   
207           for key, value in self.objects.items():
208               try:
209                   value.hide()
210   
211               except AttributeError:
212                   pass
213   
214           self.setWindowTitle("Game Engine 3")
215   
216           self.selectProject = ""
217           self.selectFile = ""
218   
219           self.show()
220   
221           self.objects["project_tree_file_opened"] = {}
222   
223           # INSTALL PYTHON
224   
225           request = ["python", "python/Scripts/python.exe", "python/Scripts/pip.exe", "python/Scripts/pyinstaller.exe"]
226   
227           if not all([os.path.exists(element) for element in request]):
228               thr = threading.Thread(target=lambda: self.install())
229               thr.daemon = True
230               thr.start()
231   
232           # TAB FILE BAR
233   
234           self.objects["tab_file_bar"] = TabFileBar(self, self)
235           self.objects["tab_file_bar"].currentChanged.connect(lambda index: tabFileBarCurrentChanged(index))
236           self.objects["tab_file_bar"].tabCloseRequested.connect(lambda index: tabFileBarTabCloseRequested(index))
237   
238           # CENTER RAMA
239   
240           self.objects["center_rama"] = FocusTreeWidget(self)
241           # self.objects["center_rama"].mousePressEvent.connect(lambda: self.objects["center_rama"].setFocus())
242           self.objects["center_rama"].setHeaderHidden(True)
243   
244           # VERSION LOG
245   
246           self.objects["version_log"] = VersionLogScrollArea(self, load(open("scr/files/updates.json", "r", encoding="utf-8")))
247   
248           # PROJECT TREE
249   
250           self.objects["tree_project"] = QTreeWidget(self)
251           self.objects["tree_project"].setHeaderHidden(True)
252           self.objects["tree_project"].header().setFont(FONT)
253   
254           self.objects["tree_project"].setContextMenuPolicy(Qt.CustomContextMenu)
255   
256           self.objects["tree_project"].customContextMenuRequested.connect(
257               lambda pos: functions.project.projectTreeProjectMenuOpen(self, pos)
258           )
259   
260           self.objects["tree_project"].expanded.connect(
261               lambda item: functions.project.projectTreeOpenDir(self, self.objects["tree_project"].itemFromIndex(item))
262           )
263   
264           self.objects["tree_project"].collapsed.connect(
265               lambda item: functions.project.projectTreeCloseDir(self, self.objects["tree_project"].itemFromIndex(item))
266           )
267   
268           self.objects["tree_project"].itemDoubleClicked.connect(
269               lambda: functions.tree.open(self)
270           )
271   
272           self.objects["tree_project_main"] = QTreeWidgetItem(self.objects["tree_project"])
273           self.objects["tree_project_main"].setIcon(0, QIcon("project/files/sprites/dir.png"))
274           self.objects["tree_project_main"].setText(0, translate("Project"))
275   
276           # STATUS BAR
277   
278           self.objects["status_bar"] = QStatusBar()
279           self.setStatusBar(self.objects["status_bar"])
280   
281           self.init("initialization")
282   
283       def theme(self) -> None:
284           if SETTINGS["theme"] == "light":
285               pass
286   
287       def init(self, type: str = "") -> None:
288           self.menu()
289   
290           if self.selectProject == "":
291               self.theme()
292   
293               return 0
294   
295           functions.project.projectTreeInit(self)
296           functions.project.centerMenuInit(self)
297   
298           self.geometryInit()
299   
300           self.theme()
301   
302       def menu(self) -> None:
303           self.statusBar()
304   
305           self.menubar = self.menuBar()
306           self.menubar.clear()
307   
308           # FILE MENU
309   
310           file_create_action = QAction(translate("Create"), self)
311           file_create_action.triggered.connect(lambda: functions.menu.file.create(self))
312   
313           file_create_from_template = QAction(translate("Copy template"), self)
314           file_create_from_template.triggered.connect(lambda: functions.menu.file.createFromTemplate(self))
315   
316           file_open_action = QAction(translate("Open"), self)
317           file_open_action.triggered.connect(lambda: functions.menu.file.open(self))
318   
319           file_close_action = QAction(translate("Close"), self)
320           file_close_action.triggered.connect(lambda: functions.menu.file.close(self))
321   
322           file_settings_action = QAction(translate("Settings"), self)
323           file_settings_action.triggered.connect(lambda: functions.menu.file.settings(self))
324   
325           self.menues["file_menu"] = self.menubar.addMenu(translate("File"))
326   
327           self.menues["file_menu"].addAction(file_create_action)
328           self.menues["file_menu"].addAction(file_create_from_template)
329           self.menues["file_menu"].addSeparator()
330           self.menues["file_menu"].addAction(file_open_action)
331           self.menues["file_menu"].addAction(file_close_action)
332           self.menues["file_menu"].addSeparator()
333           self.menues["file_menu"].addAction(file_settings_action)
334   
335           # PROJECT MENU
336   
337           project_run_action = QAction(translate("Run"), self)
338           project_run_action.triggered.connect(lambda: functions.compile.run(self))
339   
340           project_compile_action = QAction(translate("Compile"), self)
341           project_compile_action.triggered.connect(lambda: functions.compile.compile(self))
342   
343           project_compile_and_run_action = QAction(translate("Compile and run"), self)
344           project_compile_and_run_action.triggered.connect(lambda: functions.compile.compileAndRun(self))
345   
346           project_save_project_as_action = QAction(translate("Save project"), self)
347           project_save_project_as_action.triggered.connect(lambda: functions.compile.saveProject(self))
348   
349           project_save_executable_as_action = QAction(translate("Save executable project"), self)
350           project_save_executable_as_action.triggered.connect(lambda: functions.compile.saveExecutableProject(self))
351   
352           self.menues["project_menu"] = self.menubar.addMenu(translate("Project"))
353   
354           if self.selectProject == "" and not self.compiling:
355               self.menues["project_menu"].setDisabled(True)
356   
357           self.menues["project_menu"].addAction(project_run_action)
358           self.menues["project_menu"].addSeparator()
359           self.menues["project_menu"].addAction(project_compile_action)
360           self.menues["project_menu"].addAction(project_compile_and_run_action)
361           self.menues["project_menu"].addSeparator()
362           self.menues["project_menu"].addAction(project_save_project_as_action)
363           self.menues["project_menu"].addAction(project_save_executable_as_action)
364   
365           # HELP MENU
366   
367           self.menues["help_menu"] = self.menubar.addMenu(translate("Help"))
368   
369           self.objects["help_pages"] = {}
370   
371           for name, value in load(open("scr/site/help.json", encoding="utf-8")).items():
372               self.objects["help_pages"][value["name"]] = dict(value)
373   
374           help_program_action = QAction(translate("Program"), self)
375           help_program_action.triggered.connect(lambda: functions.menu.help.help_(self))
376   
377           author_program_action = QAction(translate("About"), self)
378           author_program_action.triggered.connect(lambda: functions.menu.help.about(self))
379   
380           self.menues["help_menu"].addAction(help_program_action)
381           self.menues["help_menu"].addSeparator()
382           self.menues["help_menu"].addAction(author_program_action)
383   
384       def shortcut(self) -> None:
385           def right(project):
386               if project.selectFile[project.selectFile.find(".") + 1:].find("%scene%") != -1:
387                   functions.files.Scene.toObjectMove(project, "right")
388   
389           def left(project):
390               if project.selectFile[project.selectFile.find(".") + 1:].find("%scene%") != -1:
391                   functions.files.Scene.toObjectMove(project, "left")
392   
393           def up(project):
394               if project.selectFile[project.selectFile.find(".") + 1:].find("%scene%") != -1:
395                   functions.files.Scene.toObjectMove(project, "up")
396   
397           def down(project):
398               if project.selectFile[project.selectFile.find(".") + 1:].find("%scene%") != -1:
399                   functions.files.Scene.toObjectMove(project, "down")
400   
401           def q(project):
402               if project.selectFile[project.selectFile.find(".") + 1:].find("%scene%") != -1:
403                   functions.files.Scene.objectReleased(self)
404   
405           def ctrlC(project):
406               if functions.project.projectTreeProjectMenuInit(self)["copy"]:
407                   functions.tree.copy(self)
408   
409               if project.selectFile[project.selectFile.find(".") + 1:].find("%scene%") != -1:
410                   functions.files.Scene.copyObject(self)
411   
412           def ctrlV(project):
413               if functions.project.projectTreeProjectMenuInit(self)["paste"]:
414                   functions.tree.paste(self)
415   
416               if project.selectFile[project.selectFile.find(".") + 1:].find("%scene%") != -1:
417                   functions.files.Scene.pasteObject(self)
418   
419           def delete(project):
420               if functions.project.projectTreeProjectMenuInit(self)["remove"]:
421                   functions.tree.remove(self)
422   
423               if project.selectFile[project.selectFile.find(".") + 1:].find("%scene%") != -1:
424                   functions.files.Scene.deleteObject(self)
425   
426           self.objects["scene_move_right"] = QShortcut(QKeySequence("right"), self)
427           self.objects["scene_move_right"].activated.connect(lambda: right(self))
428   
429           self.objects["scene_move_left"] = QShortcut(QKeySequence("left"), self)
430           self.objects["scene_move_left"].activated.connect(lambda: left(self))
431   
432           self.objects["scene_move_up"] = QShortcut(QKeySequence("up"), self)
433           self.objects["scene_move_up"].activated.connect(lambda: up(self))
434   
435           self.objects["scene_move_down"] = QShortcut(QKeySequence("down"), self)
436           self.objects["scene_move_down"].activated.connect(lambda: down(self))
437   
438           self.objects["scene_release_object"] = QShortcut(QKeySequence("Q"), self)
439           self.objects["scene_release_object"].activated.connect(lambda: q(self))
440   
441           self.objects["tree_project_shortcut_copy"] = QShortcut(QKeySequence("Ctrl+C"), self)
442           self.objects["tree_project_shortcut_copy"].activated.connect(lambda: ctrlC(self))
443   
444           self.objects["tree_project_shortcut_paste"] = QShortcut(QKeySequence("Ctrl+V"), self)
445           self.objects["tree_project_shortcut_paste"].activated.connect(lambda: ctrlV(self))
446   
447           self.objects["tree_project_shortcut_remove"] = QShortcut(QKeySequence("Delete"), self)
448           self.objects["tree_project_shortcut_remove"].activated.connect(lambda: delete(self))
449   
450       def closeEvent(self, event) -> None:
451           event.accept()
452   
453       def resizeEvent(self, event) -> None:
454           size["width"] = self.width()
455           size["height"] = self.height() - PLUS
456   
457           self.desktop = QApplication.desktop()
458   
459           self.geometryInit()
460   
461           event.accept()
462   
##### scr\modules\dialogs\animator\animator.py #####
1     from PyQt5.QtWidgets import QDialog, QApplication, QMenu, QLabel, QWidget, QScrollArea, QFrame, QGridLayout, QSizePolicy, QVBoxLayout, QLineEdit, QTreeWidgetItem, QComboBox, QCheckBox, QPushButton, QTreeWidget
2     from PyQt5.QtCore import Qt, QMimeData, pyqtSignal
3     from PyQt5.QtGui import QPixmap, QImage, QDrag
4     
5     from PyQt5 import QtWidgets
6     
7     from scr.modules.widgets import FocusLineEdit
8     
9     from PIL import Image as PImage
10     
11    from scr.variables import *
12    
13    import numpy
14    import math
15    import os
16    
17    
18    class Image:
19        @staticmethod
20        def replaceTransparentColor(image, color):
21            image = image.convert("RGBA")
22            data = numpy.array(image)
23    
24            r, g, b, a = data.T
25            transparent_areas = (a == 0)
26            data[..., :-1][transparent_areas.T] = color
27            data[..., -1][transparent_areas.T] = 255
28    
29            return PImage.fromarray(data)
30    
31        @staticmethod
32        def pillowToQImage(image):
33            data = image.tobytes("raw", "RGB")
34            qimage = QImage(data, image.width, image.height, QImage.Format_RGB888)
35    
36            return qimage
37    
38        @staticmethod
39        def getPixmap(project, maxWidth, maxHeight, file):
40            try:
41                image = PImage.open(file)
42    
43            except BaseException:
44                MessageBox.error(translate("Can not open this image"))
45    
46                project.objects["tab_file_bar"].pop(len(project.objects["tab_file_bar"].objects) - 1)
47    
48                return 0
49    
50            capacity = 1
51    
52            while image.width * capacity > maxWidth or image.height * capacity > maxHeight:
53                capacity /= 2
54    
55            while image.width * capacity * 2 < maxWidth and image.height * capacity * 2 < maxHeight:
56                capacity *= 2
57    
58            if capacity > project.engine.FLOAT_PRECISION:
59                image = image.resize((math.trunc(image.width * capacity) + (math.trunc(image.width * capacity) < 1), math.trunc(image.height * capacity) + (math.trunc(image.height * capacity) < 1)), resample=PImage.NEAREST)
60    
61            else:
62                return 0
63    
64            x = (maxWidth - image.width) // 2
65            y = (maxHeight - image.height) // 2
66    
67            image = Image.replaceTransparentColor(image, (32, 33, 36) if SETTINGS["theme"] == 'dark' else (248, 249, 250))
68            image.save("scr/files/cash/image.png")
69    
70            pixmap = QPixmap()
71            pixmap.load("scr/files/cash/image.png")
72    
73            return x, y, pixmap
74    
75        @staticmethod
76        def init(project) -> None:
77            if os.path.isdir(project.selectFile):
78                return 0
79    
80            if project.selectFile == "":
81                return 0
82    
83            maxWidth = project.objects["center_rama"].width()
84            maxHeight = project.objects["center_rama"].height()
85    
86            try:
87                image = PImage.open(project.selectFile)
88    
89            except BaseException:
90                MessageBox.error(translate("Can not open this image"))
91    
92                project.objects["tab_file_bar"].pop(len(project.objects["tab_file_bar"].objects) - 1)
93    
94                return 0
95    
96            capacity = 1
97    
98            while image.width * capacity > maxWidth or image.height * capacity > maxHeight:
99                capacity /= 2
100    
101           while image.width * capacity * 2 < maxWidth and image.height * capacity * 2 < maxHeight:
102               capacity *= 2
103   
104           if capacity > project.engine.FLOAT_PRECISION:
105               image = image.resize((math.trunc(image.width * capacity) + (math.trunc(image.width * capacity) < 1), math.trunc(image.height * capacity) + (math.trunc(image.height * capacity) < 1)), resample=PImage.NEAREST)
106   
107           else:
108               return 0
109   
110           x = (maxWidth - image.width) // 2
111           y = (maxHeight - image.height) // 2
112   
113           image = Image.replaceTransparentColor(image, (32, 33, 36) if SETTINGS["theme"] == 'dark' else (248, 249, 250))
114           image.save("scr/files/cash/image.png")
115   
116           pixmap = QPixmap()
117           pixmap.load("scr/files/cash/image.png")
118   
119           project.objects["main"]["image"] = QLabel(parent=project)
120           project.objects["main"]["image"].setGeometry(project.objects["center_rama"].x() + x, project.objects["center_rama"].y() + y, image.width, image.height)
121           project.objects["main"]["image"].setPixmap(pixmap)
122           project.objects["main"]["image"].show()
123   
124   
125   class AnimatorCreateFrame(QDialog):
126       def __init__(self, project, dialog, parent=None) -> None:
127           QDialog.__init__(self, parent)
128   
129           self.project = project
130           self.dialog = dialog
131   
132           self.setWindowTitle(translate("Create frame"))
133           self.setFixedSize(600, 400)
134   
135           desktop = QtWidgets.QApplication.desktop()
136           self.move((desktop.width() - self.width()) // 2, (desktop.height() - self.height() - PLUS) // 2)
137   
138           self.objects = {}
139   
140           self.init()
141   
142       def init(self) -> None:
143           self.objects["empty"] = QPushButton(parent=self)
144           self.objects["empty"].setGeometry(0, 0, 0, 0)
145   
146           # SPRITE
147   
148           self.objects["sprite_label"] = QLabel(parent=self, text=translate("Path to sprite") + ":")
149           self.objects["sprite_label"].setGeometry(10, 10, 200, 25)
150           self.objects["sprite_label"].setFont(FONT)
151           self.objects["sprite_label"].show()
152   
153           self.objects["sprite_entry"] = QLineEdit(parent=self)
154           self.objects["sprite_entry"].setGeometry(210, 10, 300, 25)
155           self.objects["sprite_entry"].setFont(FONT)
156           self.objects["sprite_entry"].show()
157   
158           # CREATE
159   
160           self.objects["create_button"] = QPushButton(parent=self, text=translate("Create"))
161           self.objects["create_button"].setStyleSheet(BUTTON_BLUE_STYLE)
162   
163           self.objects["create_button"].released.connect(lambda: self.objects["empty"].setFocus())
164   
165           self.objects["create_button"].setGeometry(150, 340, 300, 40)
166           self.objects["create_button"].setFont(FONT)
167           self.objects["create_button"].show()
168   
169           self.objects["create_button"].clicked.connect(lambda event: self.createFrame(event))
170   
171       def createFrame(self, event):
172           path = self.objects["sprite_entry"].text()
173   
174           if not os.path.exists(f"projects/{self.project.selectProject}/project/{path}"):
175               return
176   
177           if path[path.rfind(".") + 1:] not in IMAGE_FORMATES:
178               return
179   
180           self.dialog.object["StaticObject"]["animation"]["value"]["groups"][self.dialog.selectGroup]["sprites"].append(path)
181   
182           AnimatorFunctions.save(self.project, self.dialog)
183   
184           self.close()
185   
186       def keyPressEvent(self, event) -> None:
187           if event.key() in (Qt.Key_Enter, Qt.Key_Return):
188               self.objects["create_button"].click()
189   
190           event.accept()
191   
192   
193   class AnimationContainerTile(QWidget):
194       clicked = pyqtSignal()
195   
196       def __init__(self, project, dialog, image_path, text, parent=None):
197           super().__init__(parent)
198   
199           self.project = project
200           self.dialog = dialog
201   
202           self.image_path = image_path
203   
204           self.setAttribute(Qt.WA_StyledBackground, True)
205           self.setAcceptDrops(True)
206   
207           self.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
208   
209           self.setContextMenuPolicy(Qt.CustomContextMenu)
210   
211           self.customContextMenuRequested.connect(self.showMenu)
212   
213           self.is_dragging = False
214           self.is_selected = False
215   
216           layout = QVBoxLayout(self)
217           layout.setContentsMargins(0, 0, 0, 0)
218           layout.setSpacing(0)
219   
220           self.image_label = QLabel()
221           self.image_label.setAlignment(Qt.AlignCenter)
222           self.image_label.setPixmap(QPixmap(image_path).scaled(75, 75))
223   
224           self.text_label = QLabel(text)
225           self.text_label.setAlignment(Qt.AlignCenter)
226           self.text_label.setFixedHeight(30)
227   
228           layout.addWidget(self.image_label)
229           layout.addWidget(self.text_label)
230   
231           self.setFixedSize(75, 105)
232   
233           self.dragStartPos = None
234   
235       def mousePressEvent(self, event):
236           if event.button() == Qt.LeftButton:
237               self.dragStartPos = event.pos()
238               self.is_dragging = False
239   
240               self.dialog.selectSprite = self.image_path
241   
242               if self.dialog.selectSprite is not None:
243                   x, y, pixmap = Image.getPixmap(self.project, 1060, 460, self.dialog.selectSprite)
244   
245                   if "main_image" in self.dialog.objects:
246                       self.dialog.objects["main_image"].hide()
247   
248                   self.dialog.objects["main_image"] = QLabel(parent=self.dialog.objects["main_rama"])
249                   self.dialog.objects["main_image"].setGeometry(x, y, pixmap.width(), pixmap.height())
250                   self.dialog.objects["main_image"].setPixmap(pixmap)
251                   self.dialog.objects["main_image"].show()
252   
253               super().mousePressEvent(event)
254   
255       def mouseMoveEvent(self, event):
256           if not (event.buttons() & Qt.LeftButton) or self.is_dragging:
257               return
258   
259           if (event.pos() - self.dragStartPos).manhattanLength() >= QApplication.startDragDistance():
260               self.is_dragging = True
261               drag = QDrag(self)
262               mime_data = QMimeData()
263               mime_data.setText(self.text_label.text())
264               drag.setMimeData(mime_data)
265   
266               pixmap = QPixmap(self.size())
267               self.render(pixmap)
268               drag.setPixmap(pixmap)
269               drag.setHotSpot(event.pos())
270               drag.exec_(Qt.MoveAction)
271   
272       def mouseReleaseEvent(self, event):
273           if event.button() == Qt.LeftButton and not self.is_dragging:
274               self.clicked.emit()
275   
276           super().mouseReleaseEvent(event)
277   
278       def setSelect(self, selected):
279           self.is_selected = selected
280           self.setStyleSheet("TileWidget { background-color: #657a9d; }" if selected else "")
281   
282       def showMenu(self, pos):
283           menu = QMenu(self)
284   
285           remove_action = menu.addAction("Удалить")
286           remove_action.triggered.connect(lambda: self.removeTile())
287   
288           menu.exec_(self.mapToGlobal(pos))
289   
290       def removeTile(self):
291           index = int(self.text_label.text()) - 1
292   
293           self.dialog.object["StaticObject"]["animation"]["value"]["groups"][self.dialog.selectGroup]["sprites"].pop(index)
294   
295           AnimatorFunctions.save(self.project, self.dialog)
296   
297   
298   class AnimationContainer(QWidget):
299       def __init__(self, project, dialog):
300           super().__init__()
301   
302           self.project = project
303           self.dialog = dialog
304   
305           self.widgets = []
306   
307           self.layout = QGridLayout()
308           self.layout.setContentsMargins(2, 2, 2, 2)
309           self.layout.setHorizontalSpacing(2)
310           self.layout.setVerticalSpacing(3)
311   
312           self.setLayout(self.layout)
313   
314           self.setAcceptDrops(True)
315   
316       def addWidget(self, widget):
317           self.widgets.append(widget)
318           widget.clicked.connect(lambda: self.select(widget))
319           self.rearrange()
320   
321       def removeWidget(self, widget):
322           if widget in self.widgets:
323               self.widgets.remove(widget)
324               widget.deleteLater()
325               self.rearrange()
326   
327       def select(self, selected_widget):
328           for widget in self.widgets:
329               widget.setSelect(widget == selected_widget)
330   
331       def rearrange(self):
332           while self.layout.count():
333               item = self.layout.takeAt(0)
334               if widget := item.widget():
335                   widget.setParent(None)
336   
337           if not self.widgets:
338               return
339   
340           margins = self.layout.contentsMargins()
341           available_width = self.width() - margins.left() - margins.right()
342           widget_width = self.widgets[0].width()
343           spacing = self.layout.horizontalSpacing()
344           cols = max(1, (available_width + spacing) // (widget_width + spacing))
345   
346           row, col = 0, 0
347           for widget in self.widgets:
348               if col >= cols:
349                   col = 0
350                   row += 1
351               self.layout.addWidget(widget, row, col)
352               col += 1
353   
354           for r in range(row + 1):
355               self.layout.setRowMinimumHeight(r, 115)
356   
357           self.updateGeometry()
358   
359       def dragEnterEvent(self, event):
360           if event.mimeData().hasText():
361               event.acceptProposedAction()
362   
363       def dropEvent(self, event):
364           pos = event.pos()
365           source_widget = event.source()
366   
367           if not isinstance(source_widget, AnimationContainerTile) or source_widget not in self.widgets:
368               return
369   
370           margins = self.layout.contentsMargins()
371           widget_width = source_widget.width()
372           widget_height = source_widget.height()
373           spacing_h = self.layout.horizontalSpacing()
374           spacing_v = self.layout.verticalSpacing()
375   
376           x = pos.x() - margins.left()
377           y = pos.y() - margins.top()
378   
379           cols = max(1, (self.width() - margins.left() - margins.right() + spacing_h) // (widget_width + spacing_h))
380           col = x // (widget_width + spacing_h)
381           row = y // (widget_height + spacing_v)
382   
383           col = max(0, min(col, cols - 1))
384           current_index = self.widgets.index(source_widget)
385           new_index = min(row * cols + col, len(self.widgets))
386   
387           if new_index != current_index:
388               self.widgets.remove(source_widget)
389               self.widgets.insert(new_index, source_widget)
390               self.rearrange()
391   
392               array = list(self.dialog.object["StaticObject"]["animation"]["value"]["groups"][self.dialog.selectGroup]["sprites"])
393   
394               array.remove(source_widget.temp)
395               array.insert(new_index, source_widget.temp)
396   
397               self.dialog.object["StaticObject"]["animation"]["value"]["groups"][self.dialog.selectGroup]["sprites"] = list(array)
398   
399               AnimatorFunctions.save(self.project, self.dialog)
400   
401           event.accept()
402   
403       def resizeEvent(self, event):
404           self.rearrange()
405           super().resizeEvent(event)
406   
407   
408   class AnimatorFunctions:
409       @staticmethod
410       def createNewGroup(project, dialog):
411           name = "group"
412           index = 0
413   
414           while (f"{name}-{index}" if index != 0 else name) in dialog.object["StaticObject"]["animation"]["value"]["groups"]:
415               index += 1
416   
417           name = f"{name}-{index}" if index != 0 else name
418   
419           dialog.object["StaticObject"]["animation"]["value"]["groups"][name] = {
420               "name": name,
421               "sprites": [
422   
423               ],
424               "settings": {
425                   "repeat": False,
426                   "fpsPerFrame": 10,
427                   "standard": False
428               }
429           }
430   
431           AnimatorFunctions.save(project, dialog)
432   
433       @staticmethod
434       def createNewFrame(project, dialog):
435           dialog.init()
436   
437           dialog.dialog = AnimatorCreateFrame(project, dialog)
438           dialog.dialog.exec_()
439   
440       @staticmethod
441       def renameGroup(project, dialog, name, widget):
442           text = widget.text()
443   
444           if text in dialog.object["StaticObject"]["animation"]["value"]["groups"]:
445               return dialog.init()
446   
447           dialog.object["StaticObject"]["animation"]["value"]["groups"][text] = dict(dialog.object["StaticObject"]["animation"]["value"]["groups"][name])
448           dialog.object["StaticObject"]["animation"]["value"]["groups"].pop(name)
449   
450           dialog.selectGroup = text
451   
452           AnimatorFunctions.save(project, dialog)
453   
454       @staticmethod
455       def chooseGroup(project, dialog, name, widget):
456           if name != dialog.selectGroup:
457               dialog.selectSprite = None
458   
459           dialog.selectGroup = name
460   
461           for i in range(dialog.objects["groups"].topLevelItemCount()):
462               temp = dialog.objects["groups"].topLevelItem(i)
463   
464               item = dialog.objects["groups"].itemWidget(temp, 0)
465   
466               if dialog.selectGroup == temp.data(0, Qt.UserRole):
467                   item.setStyleSheet(f"background-color: #{'657a9d' if SETTINGS['theme'] == 'dark' else 'b5cae6'};")
468   
469               else:
470                   item.setStyleSheet(f"background-color: #{'3f4042' if SETTINGS['theme'] == 'dark' else 'f8f9fa'};")
471   
472           dialog.init(expects=["groups"])
473   
474       @staticmethod
475       def save(project, dialog):
476           with open(dialog.path, "w", encoding="utf-8") as f:
477               dump(dialog.object, f, indent=4)
478   
479           dialog.init()
480   
481       @staticmethod
482       def settingsRepeat(project, dialog, widget):
483           value = widget.isChecked()
484   
485           dialog.object["StaticObject"]["animation"]["value"]["groups"][dialog.selectGroup]["settings"]["repeat"] = value
486   
487           AnimatorFunctions.save(project, dialog)
488   
489       @staticmethod
490       def settingsBase(project, dialog, widget):
491           value = widget.isChecked()
492   
493           if value:
494               for group in dialog.object["StaticObject"]["animation"]["value"]["groups"].values():
495                   group["settings"]["standard"] = False
496   
497           dialog.object["StaticObject"]["animation"]["value"]["groups"][dialog.selectGroup]["settings"]["standard"] = value
498   
499           AnimatorFunctions.save(project, dialog)
500   
501       @staticmethod
502       def settingsFps(project, dialog, widget):
503           value = widget.text()
504   
505           try:
506               int(value)
507   
508           except BaseException:
509               dialog.init()
510   
511           else:
512               dialog.object["StaticObject"]["animation"]["value"]["groups"][dialog.selectGroup]["settings"]["fpsPerFrame"] = int(value)
513   
514               AnimatorFunctions.save(project, dialog)
515   
516   
517   class Animator(QDialog):
518       def __init__(self, project, parent=None, path=None) -> None:
519           QDialog.__init__(self, parent)
520   
521           if path is None:
522               self.path = project.selectFile
523   
524           else:
525               self.path = path
526   
527           self.project = project
528   
529           self.setWindowTitle(translate("Animation"))
530           self.setFixedSize(1280, 720)
531   
532           desktop = QtWidgets.QApplication.desktop()
533           self.move((desktop.width() - self.width()) // 2, (desktop.height() - self.height() - PLUS) // 2)
534   
535           with open(self.path, "r", encoding="utf-8") as f:
536               self.object = load(f)
537   
538           self.object["StaticObject"]["animation"]["value"]["groups"] = dict(sorted(self.object["StaticObject"]["animation"]["value"]["groups"].items(), key=lambda x: x[0]))
539   
540           self.selectGroup = list(self.object["StaticObject"]["animation"]["value"]["groups"].keys())[0]
541           self.selectSprite = None
542   
543           self.objects = {}
544   
545           self.init()
546   
547       def init(self, expects: list = None) -> None:
548           if expects is None:
549               expects = []
550   
551           rem = []
552   
553           for name, element in self.objects.items():
554               if name in expects:
555                   continue
556   
557               try:
558                   element.deleteLater()
559   
560               except RuntimeError:
561                   pass
562   
563               rem.append(name)
564   
565           for element in rem:
566               self.objects.pop(element)
567   
568           self.object["StaticObject"]["animation"]["value"]["groups"] = dict(sorted(self.object["StaticObject"]["animation"]["value"]["groups"].items(), key=lambda x: x[0]))
569   
570           self.objects["empty"] = QPushButton(self)
571           self.objects["empty"].setGeometry(0, 0, 0, 0)
572   
573           # MAIN
574   
575           self.objects["main_rama"] = QTreeWidget(self)
576           self.objects["main_rama"].header().hide()
577           self.objects["main_rama"].setGeometry(10, 10, 1060, 460)
578           self.objects["main_rama"].show()
579   
580           if self.selectSprite is not None:
581               x, y, pixmap = Image.getPixmap(self.project, 1060, 460, self.selectSprite)
582   
583               self.objects["main_image"] = QLabel(parent=self.objects["main_rama"])
584               self.objects["main_image"].setGeometry(x, y, pixmap.width(), pixmap.height())
585               self.objects["main_image"].setPixmap(pixmap)
586               self.objects["main_image"].show()
587   
588           # ANIMATION
589   
590           self.objects["animation_rama"] = QTreeWidget(self)
591           self.objects["animation_rama"].header().hide()
592           self.objects["animation_rama"].setGeometry(10, 480, 1060, 230)
593           self.objects["animation_rama"].show()
594   
595           self.objects["animation_scroll"] = QScrollArea(self)
596           self.objects["animation_scroll"].setWidgetResizable(True)
597           self.objects["animation_scroll"].setFrameShape(QFrame.NoFrame)
598   
599           self.objects["animation_scroll_container"] = AnimationContainer(self.project, self)
600           self.objects["animation_scroll"].setWidget(self.objects["animation_scroll_container"])
601   
602           for i, sprite in enumerate(self.object["StaticObject"]["animation"]["value"]["groups"][self.selectGroup]["sprites"]):
603               tile = AnimationContainerTile(self.project, self, f"projects/{self.project.selectProject}/project/{sprite}", f"{i + 1}")
604   
605               tile.temp = sprite
606   
607               self.objects["animation_scroll_container"].addWidget(tile)
608   
609           self.objects["animation_scroll"].setGeometry(10, 480, 1060, 230)
610           self.objects["animation_scroll"].show()
611   
612           # GROUPS
613   
614           if "groups" not in expects:
615               self.objects["groups"] = QTreeWidget(self)
616               self.objects["groups"].header().hide()
617               self.objects["groups"].setGeometry(1080, 10, 190, 345)
618               self.objects["groups"].setRootIsDecorated(False)
619               self.objects["groups"].show()
620   
621               for name, group in self.object["StaticObject"]["animation"]["value"]["groups"].items():
622                   item = QTreeWidgetItem()
623   
624                   item.setData(0, Qt.UserRole, name)
625   
626                   self.objects["groups"].addTopLevelItem(item)
627   
628                   groupLineEdit = FocusLineEdit()
629                   groupLineEdit.setFont(FONT)
630                   groupLineEdit.setText(name)
631   
632                   if self.selectGroup == name:
633                       groupLineEdit.setStyleSheet(f"background-color: #{'657a9d' if SETTINGS['theme'] == 'dark' else 'b5cae6'};")
634   
635                   groupLineEdit.connectFocusFunction = lambda empty=None, n=name, w=groupLineEdit: AnimatorFunctions.chooseGroup(self.project, self, n, w)
636                   groupLineEdit.releasedFocusFunction = lambda empty=None, n=name, w=groupLineEdit: AnimatorFunctions.renameGroup(self.project, self, n, w)
637   
638                   self.objects["groups"].setItemWidget(item, 0, groupLineEdit)
639   
640           self.objects["groups_create_group"] = QPushButton(self.objects["groups"])
641           self.objects["groups_create_group"].setStyleSheet(BUTTON_BLUE_STYLE)
642           self.objects["groups_create_group"].setGeometry(5, self.objects["groups"].height() - 60, self.objects["groups"].width() - 10, 25)
643           self.objects["groups_create_group"].setText(translate("Create group"))
644           self.objects["groups_create_group"].show()
645   
646           self.objects["groups_create_group"].clicked.connect(lambda: AnimatorFunctions.createNewGroup(self.project, self))
647   
648           self.objects["groups_create_frame"] = QPushButton(self.objects["groups"])
649           self.objects["groups_create_frame"].setStyleSheet(BUTTON_BLUE_STYLE)
650           self.objects["groups_create_frame"].setGeometry(5, self.objects["groups"].height() - 30, self.objects["groups"].width() - 10, 25)
651           self.objects["groups_create_frame"].setText(translate("Create frame"))
652           self.objects["groups_create_frame"].show()
653   
654           self.objects["groups_create_frame"].clicked.connect(lambda: AnimatorFunctions.createNewFrame(self.project, self))
655   
656           # SETTINGS
657   
658           self.objects["settings_rama"] = QTreeWidget(self)
659           self.objects["settings_rama"].header().hide()
660           self.objects["settings_rama"].setGeometry(1080, 365, 190, 345)
661           self.objects["settings_rama"].show()
662   
663           settings = self.object["StaticObject"]["animation"]["value"]["groups"][self.selectGroup]["settings"]
664   
665           self.objects["settings_repeat_label"] = QLabel(self.objects["settings_rama"])
666           self.objects["settings_repeat_label"].setGeometry(5, 5, 110, 20)
667           self.objects["settings_repeat_label"].setText(translate("Repeat:"))
668           self.objects["settings_repeat_label"].setFont(FONT)
669           self.objects["settings_repeat_label"].show()
670   
671           self.objects["settings_repeat_check_box"] = QCheckBox(self.objects["settings_rama"])
672           self.objects["settings_repeat_check_box"].setChecked(settings["repeat"])
673           self.objects["settings_repeat_check_box"].setGeometry(145, 5, 40, 22)
674           self.objects["settings_repeat_check_box"].show()
675   
676           self.objects["settings_repeat_check_box"].stateChanged.connect(lambda empty=None, pr=self.project, dia=self: AnimatorFunctions.settingsRepeat(pr, dia, self.objects["settings_repeat_check_box"]))
677   
678           self.objects["settings_base_label"] = QLabel(self.objects["settings_rama"])
679           self.objects["settings_base_label"].setGeometry(5, 30, 170, 20)
680           self.objects["settings_base_label"].setText(translate("Base animation:"))
681           self.objects["settings_base_label"].setFont(FONT)
682           self.objects["settings_base_label"].show()
683   
684           self.objects["settings_base_check_box"] = QCheckBox(self.objects["settings_rama"])
685           self.objects["settings_base_check_box"].setChecked(settings["standard"])
686           self.objects["settings_base_check_box"].setGeometry(145, 30, 40, 22)
687           self.objects["settings_base_check_box"].show()
688   
689           self.objects["settings_base_check_box"].stateChanged.connect(lambda empty=None, pr=self.project, dia=self: AnimatorFunctions.settingsBase(pr, dia, self.objects["settings_base_check_box"]))
690   
691           self.objects["settings_frame_label"] = QLabel(self.objects["settings_rama"])
692           self.objects["settings_frame_label"].setGeometry(5, 55, 110, 20)
693           self.objects["settings_frame_label"].setText(translate("FPS per frame:"))
694           self.objects["settings_frame_label"].setFont(FONT)
695           self.objects["settings_frame_label"].show()
696   
697           self.objects["settings_frame_line_edit"] = FocusLineEdit(self.objects["settings_rama"])
698           self.objects["settings_frame_line_edit"].setText(str(settings["fpsPerFrame"]))
699           self.objects["settings_frame_line_edit"].setGeometry(145, 55, 40, 22)
700           self.objects["settings_frame_line_edit"].show()
701   
702           self.objects["settings_frame_line_edit"].releasedFocusFunction = lambda empty=None, pr=self.project, dia=self: AnimatorFunctions.settingsFps(pr, dia, self.objects["settings_frame_line_edit"])
703   
704   
705   def animatorCreateDialog(project, path: str = None):
706       project.dialog = Animator(project, project, path)
707       project.dialog.exec_()
708   
##### scr\modules\dialogs\animator\__init__.py #####
1     from .animator import Animator, animatorCreateDialog
2     
##### scr\modules\dialogs\code\create_node.py #####
1     from PyQt5.QtWidgets import QDialog,  QPushButton, QTreeWidget, QTreeWidgetItem, QApplication
2     from PyQt5.QtCore import Qt
3     from PyQt5.QtGui import QIcon
4     
5     from engine.vector.float import Vec2f
6     
7     from scr.modules.functions.project import getColor
8     
9     from scr.variables import *
10     
11    import random
12    
13    
14    class CreateNodeFunctions:
15        @staticmethod
16        def create(project, dialog, position, event):
17            node = dialog.objects["select"]
18    
19            pos = Vec2f(
20                (position.x() + project.cash["file"][project.selectFile].x) // CODE_GRID_CELL_SIZE,
21                (position.y() + project.cash["file"][project.selectFile].y) // CODE_GRID_CELL_SIZE
22            )
23    
24            node["id"] = random.randint(1, 1000000000)
25    
26            node["x"] = pos.x
27            node["y"] = pos.y
28    
29            with open(project.selectFile, "r", encoding="utf-8") as file:
30                function = load(file)
31    
32            function["objects"][node["id"]] = node
33    
34            with open(project.selectFile, "w", encoding="utf-8") as file:
35                dump(function, file, indent=4)
36    
37            dialog.close()
38    
39            project.init()
40    
41    
42    class CreateNode(QDialog):
43        def __init__(self, project, position, parent=None) -> None:
44            QDialog.__init__(self, parent)
45    
46            self.project = project
47    
48            self.position = position
49    
50            self.setWindowTitle(translate("Create node"))
51            self.setFixedSize(900, 600)
52    
53            desktop = QApplication.desktop()
54            self.move((desktop.width() - self.width()) // 2, (desktop.height() - self.height() - PLUS) // 2)
55    
56            self.objects = {}
57    
58            self.init()
59    
60        def choose(self, item, column) -> None:
61            data = item.data(column, 1000)
62    
63            if data["level"] != 2:
64                return 0
65    
66            self.objects["select"] = data["node"]
67    
68            self.objects["open_button"].setDisabled(False)
69    
70        def init(self) -> None:
71            self.objects["empty"] = QPushButton(parent=self)
72            self.objects["empty"].setGeometry(0, 0, 0, 0)
73    
74            # NODES
75    
76            self.objects["nodes"] = QTreeWidget(parent=self)
77            self.objects["nodes"].setGeometry(10, 10, 880, 520)
78            self.objects["nodes"].header().setFont(FONT)
79            self.objects["nodes"].setHeaderHidden(True)
80            self.objects["nodes"].show()
81    
82            self.objects["nodes"].itemClicked.connect(self.choose)
83    
84            self.objects["select"] = None
85            self.objects["widgets"] = {}
86    
87            with open("scr/code/config.json", "r", encoding="utf-8") as file:
88                config = load(file)
89    
90            self.objects["widgets"]["nodes"] = QTreeWidgetItem(self.objects["nodes"])
91            self.objects["widgets"]["nodes"].setIcon(0, QIcon(getColor("dir")))
92            self.objects["widgets"]["nodes"].setText(0, translate("Nodes"))
93            self.objects["widgets"]["nodes"].setData(0, 1000, {"level": 0, "path": "nodes"})
94            self.objects["widgets"]["nodes"].setExpanded(True)
95    
96            for key, value in config["groups"].items():
97                self.objects["widgets"][f"nodes/{key}"] = QTreeWidgetItem(self.objects["widgets"]["nodes"])
98                self.objects["widgets"][f"nodes/{key}"].setIcon(0, QIcon(getColor("dir")))
99                self.objects["widgets"][f"nodes/{key}"].setText(0, translate(value["name"]))
100                self.objects["widgets"][f"nodes/{key}"].setData(0, 1000, {"level": 1, "path": f"nodes/{key}"})
101               self.objects["widgets"][f"nodes/{key}"].setExpanded(True)
102   
103               for node in value["nodes"]:
104                   self.objects["widgets"][f"nodes/{key}/{element}"] = QTreeWidgetItem(self.objects["widgets"][f"nodes/{key}"])
105                   self.objects["widgets"][f"nodes/{key}/{element}"].setIcon(0, QIcon(getColor("func")))
106                   self.objects["widgets"][f"nodes/{key}/{element}"].setText(0, translate(config["nodes"][node]["display"]["name"]))
107                   self.objects["widgets"][f"nodes/{key}/{element}"].setData(0, 1000, {"level": 2, "path": f"nodes/{key}/{element}", "name": node, "node": config["nodes"][node]})
108   
109           # CREATE
110   
111           self.objects["open_button"] = QPushButton(parent=self, text=translate("Create"))
112           self.objects["open_button"].setStyleSheet(BUTTON_BLUE_STYLE)
113   
114           self.objects["open_button"].released.connect(lambda: self.objects["empty"].setFocus())
115   
116           self.objects["open_button"].setGeometry(300, 540, 300, 40)
117           self.objects["open_button"].setFont(FONT)
118           self.objects["open_button"].show()
119   
120           self.objects["open_button"].setDisabled(True)
121   
122           self.objects["open_button"].clicked.connect(lambda event: CreateNodeFunctions.create(self.project, self, self.position, event))
123   
124       def keyPressEvent(self, event) -> None:
125           if event.key() in (Qt.Key_Enter, Qt.Key_Return):
126               self.objects["open_button"].click()
127   
128           event.accept()
129   
##### scr\modules\dialogs\code\__init__.py #####
1     from .create_node import CreateNode
2     
##### scr\modules\dialogs\file\create_from_template_project.py #####
1     from PyQt5.QtWidgets import QDialog, QLabel, QPushButton, QLineEdit, QComboBox
2     from PyQt5.QtCore import Qt
3     from PyQt5 import QtWidgets, QtCore
4     
5     from scr.modules import functions
6     
7     from scr.variables import *
8     
9     import os
10     
11    
12    class CreateProjectFunctions:
13        @staticmethod
14        def create(project, dialog, event) -> None:
15            name = dialog.objects["name_entry"].text()
16    
17            if name == "":
18                dialog.objects["log_label"].setText("Imposiable project name")
19    
20                return 0
21    
22            try:
23                with open(f"scr/files/using/{name}", "w", encoding="utf-8") as file:
24                    pass
25    
26            except BaseException:
27                dialog.objects["log_label"].setText("Imposiable project name")
28    
29                return 0
30    
31            for element in os.listdir("projects/"):
32                if element == name:
33                    dialog.objects["log_label"].setText("Project name already exist")
34    
35                    return 0
36    
37            template = dialog.templates[dialog.objects["template_combobox"].currentIndex()]
38    
39            project.selectProject = name
40    
41            dialog.createProject(name, template)
42    
43            dialog.close()
44    
45    
46    class CreateFromTemplateProject(QDialog):
47        def __init__(self, project, parent=None) -> None:
48            QDialog.__init__(self, parent)
49    
50            self.project = project
51    
52            self.setWindowTitle(translate("Copy template"))
53            self.setFixedSize(600, 400)
54    
55            desktop = QtWidgets.QApplication.desktop()
56            self.move((desktop.width() - self.width()) // 2, (desktop.height() - self.height() - PLUS) // 2)
57    
58            self.template = "scr/files/templates"
59            self.templates = list(sorted([name for name in os.listdir(self.template)], key=lambda x: 0 if x == translate("Base") else 1))
60    
61            self.objects = {}
62    
63            self.init()
64    
65        def init(self) -> None:
66            self.objects["empty"] = QPushButton(parent=self)
67            self.objects["empty"].setGeometry(0, 0, 0, 0)
68    
69            # NAME
70    
71            self.objects["name_label"] = QLabel(parent=self, text=translate("Project name") + ":")
72            self.objects["name_label"].setGeometry(10, 10, 200, 25)
73            self.objects["name_label"].setFont(FONT)
74            self.objects["name_label"].show()
75    
76            self.objects["name_entry"] = QLineEdit(parent=self)
77            self.objects["name_entry"].setGeometry(210, 10, 300, 25)
78            self.objects["name_entry"].setFont(FONT)
79            self.objects["name_entry"].show()
80    
81            # TEMPLATE
82    
83            self.objects["template_label"] = QLabel(parent=self, text=translate("Template") + ":")
84            self.objects["template_label"].setGeometry(10, 45, 200, 25)
85            self.objects["template_label"].setFont(FONT)
86            self.objects["template_label"].show()
87    
88            self.objects["template_combobox"] = QComboBox(parent=self)
89            self.objects["template_combobox"].setCurrentIndex(0)
90            self.objects["template_combobox"].addItems([translate(element) for element in self.templates])
91            self.objects["template_combobox"].setGeometry(210, 45, 300, 25)
92            self.objects["template_combobox"].setFont(FONT)
93            self.objects["template_combobox"].show()
94    
95            # LOG TEXT
96    
97            self.objects["log_label"] = QLabel(parent=self, text="")
98            self.objects["log_label"].setGeometry(0, 310, 600, 20)
99            self.objects["log_label"].setFont(FONT)
100            self.objects["log_label"].show()
101   
102           self.objects["log_label"].setAlignment(QtCore.Qt.AlignmentFlag.AlignHCenter)
103           self.objects["log_label"].setStyleSheet("color: red;")
104   
105           # CREATE
106   
107           self.objects["create_button"] = QPushButton(parent=self, text=translate("Create"))
108           self.objects["create_button"].setStyleSheet(BUTTON_BLUE_STYLE)
109   
110           self.objects["create_button"].released.connect(lambda: self.objects["empty"].setFocus())
111   
112           self.objects["create_button"].setGeometry(150, 340, 300, 40)
113           self.objects["create_button"].setFont(FONT)
114           self.objects["create_button"].show()
115   
116           self.objects["create_button"].clicked.connect(lambda event: CreateProjectFunctions.create(self.project, self, event))
117   
118       def createProject(self, name, template) -> None:
119           functions.project.createProjectDirecroryByTemplate(self.project, name, template)
120   
121           functions.project.projectOpen(self.project)
122   
123       def keyPressEvent(self, event) -> None:
124           if event.key() in (Qt.Key_Enter, Qt.Key_Return):
125               self.objects["create_button"].click()
126   
127           event.accept()
128   
129   
##### scr\modules\dialogs\file\create_project.py #####
1     from PyQt5.QtWidgets import QDialog, QLabel, QPushButton, QLineEdit
2     from PyQt5.QtCore import Qt
3     from PyQt5 import QtWidgets, QtCore
4     
5     from scr.modules import functions
6     
7     from scr.variables import *
8     
9     import os
10     
11    
12    class CreateProjectFunctions:
13        @staticmethod
14        def create(project, dialog, event) -> None:
15            name = dialog.objects["name_entry"].text()
16    
17            if name == "":
18                dialog.objects["log_label"].setText("Imposiable project name")
19    
20                return 0
21    
22            try:
23                with open(f"scr/files/using/{name}", "w", encoding="utf-8") as file:
24                    pass
25    
26            except BaseException:
27                dialog.objects["log_label"].setText("Imposiable project name")
28    
29                return 0
30    
31            for element in os.listdir("projects/"):
32                if element == name:
33                    dialog.objects["log_label"].setText("Project name already exist")
34    
35                    return 0
36    
37            project.selectProject = name
38    
39            dialog.createProject(name)
40    
41            dialog.close()
42    
43    
44    class CreateProject(QDialog):
45        def __init__(self, project, parent=None) -> None:
46            QDialog.__init__(self, parent)
47    
48            self.project = project
49    
50            self.setWindowTitle(translate("Create project"))
51            self.setFixedSize(600, 400)
52    
53            desktop = QtWidgets.QApplication.desktop()
54            self.move((desktop.width() - self.width()) // 2, (desktop.height() - self.height() - PLUS) // 2)
55    
56            self.objects = {}
57    
58            self.init()
59    
60        def init(self) -> None:
61            self.objects["empty"] = QPushButton(parent=self)
62            self.objects["empty"].setGeometry(0, 0, 0, 0)
63    
64            # NAME
65    
66            self.objects["name_label"] = QLabel(parent=self, text=translate("Project name") + ":")
67            self.objects["name_label"].setGeometry(10, 10, 200, 25)
68            self.objects["name_label"].setFont(FONT)
69            self.objects["name_label"].show()
70    
71            self.objects["name_entry"] = QLineEdit(parent=self)
72            self.objects["name_entry"].setGeometry(210, 10, 300, 25)
73            self.objects["name_entry"].setFont(FONT)
74            self.objects["name_entry"].show()
75    
76            # LOG TEXT
77    
78            self.objects["log_label"] = QLabel(parent=self, text="")
79            self.objects["log_label"].setGeometry(0, 310, 600, 20)
80            self.objects["log_label"].setFont(FONT)
81            self.objects["log_label"].show()
82    
83            self.objects["log_label"].setAlignment(QtCore.Qt.AlignmentFlag.AlignHCenter)
84            self.objects["log_label"].setStyleSheet("color: red;")
85    
86            # CREATE
87    
88            self.objects["create_button"] = QPushButton(parent=self, text=translate("Create"))
89            self.objects["create_button"].setStyleSheet(BUTTON_BLUE_STYLE)
90    
91            self.objects["create_button"].released.connect(lambda: self.objects["empty"].setFocus())
92    
93            self.objects["create_button"].setGeometry(150, 340, 300, 40)
94            self.objects["create_button"].setFont(FONT)
95            self.objects["create_button"].show()
96    
97            self.objects["create_button"].clicked.connect(lambda event: CreateProjectFunctions.create(self.project, self, event))
98    
99        def createProject(self, name) -> None:
100            functions.project.createProjectDirectory(self.project, name)
101   
102           functions.project.projectOpen(self.project)
103   
104       def keyPressEvent(self, event) -> None:
105           if event.key() in (Qt.Key_Enter, Qt.Key_Return):
106               self.objects["create_button"].click()
107   
108           event.accept()
109   
110   
##### scr\modules\dialogs\file\open_project.py #####
1     from PyQt5.QtWidgets import QDialog, QLabel, QComboBox, QPushButton
2     from PyQt5.QtCore import Qt
3     from PyQt5 import QtWidgets
4     
5     from scr.modules import functions
6     
7     from scr.variables import *
8     
9     import os
10     
11    
12    class OpenProjectFunctions:
13        @staticmethod
14        def open(project, dialog, event):
15            name = dialog.objects["project_combobox"].currentText()
16    
17            if name == "":
18                return 0
19    
20            project.selectProject = name
21    
22            functions.project.projectOpen(project)
23    
24            project.init()
25    
26            dialog.close()
27    
28    
29    class OpenProject(QDialog):
30        def __init__(self, project, parent=None) -> None:
31            QDialog.__init__(self, parent)
32    
33            self.project = project
34    
35            self.setWindowTitle(translate("Open project"))
36            self.setFixedSize(600, 400)
37    
38            desktop = QtWidgets.QApplication.desktop()
39            self.move((desktop.width() - self.width()) // 2, (desktop.height() - self.height() - PLUS) // 2)
40    
41            self.objects = {}
42    
43            self.init()
44    
45        def init(self) -> None:
46            self.objects["empty"] = QPushButton(parent=self)
47            self.objects["empty"].setGeometry(0, 0, 0, 0)
48    
49            # ALL PROJECTS -> COMBOBOX
50    
51            self.objects["project_label"] = QLabel(parent=self, text=translate("Project") + ":")
52            self.objects["project_label"].setGeometry(10, 10, 200, 25)
53            self.objects["project_label"].setFont(FONT)
54            self.objects["project_label"].show()
55    
56            self.objects["project_combobox"] = QComboBox(parent=self)
57            self.objects["project_combobox"].setGeometry(210, 10, 300, 25)
58            self.objects["project_combobox"].setFont(FONT)
59            self.objects["project_combobox"].show()
60    
61            self.objects["project_combobox"].addItems([file for file in os.listdir("projects/")])
62    
63            # OPEN
64    
65            self.objects["open_button"] = QPushButton(parent=self, text=translate("Open"))
66            self.objects["open_button"].setStyleSheet(BUTTON_BLUE_STYLE)
67    
68            self.objects["open_button"].released.connect(lambda: self.objects["empty"].setFocus())
69    
70            self.objects["open_button"].setGeometry(150, 340, 300, 40)
71            self.objects["open_button"].setFont(FONT)
72            self.objects["open_button"].show()
73    
74            self.objects["open_button"].clicked.connect(lambda event: OpenProjectFunctions.open(self.project, self, event))
75    
76        def keyPressEvent(self, event) -> None:
77            if event.key() in (Qt.Key_Enter, Qt.Key_Return):
78                self.objects["open_button"].click()
79    
80            event.accept()
81    
82    
##### scr\modules\dialogs\file\settings.py #####
1     from PyQt5.QtWidgets import QDialog, QLabel, QComboBox, QPushButton
2     from PyQt5 import QtWidgets
3     
4     from scr.variables import *
5     
6     import subprocess
7     import qdarktheme
8     import threading
9     
10     
11    class SettingsFunctions:
12        @staticmethod
13        def newRunProgram() -> None:
14            if SYSTEM == "Windows":
15                if DIVELOP:
16                    subprocess.run(["venv/Scripts/python.exe", "Game Engine 3.py"])
17    
18                else:
19                    subprocess.run(["Game Engine 3.exe"])
20    
21            elif SYSTEM == "Linux":
22                pass
23    
24            else:
25                print("ERROR: system (Unknown) not supported this opperation")
26    
27        @staticmethod
28        def confirm(project, dialog, event) -> None:
29            global BUTTON_RED_STYLE, BUTTON_BLUE_STYLE
30    
31            languages = dict(zip(LANGUAGES.values(), LANGUAGES.keys()))
32            themes = list(THEMES.keys())
33    
34            settings = {
35                "language": languages[dialog.objects["language_combobox"].currentText()],
36                "theme": themes[dialog.objects["theme_combobox"].currentIndex()]
37            }
38    
39            for key, value in settings.items():
40                SETTINGS[key] = value
41    
42            translate.lang = SETTINGS["language"]
43    
44            qdarktheme.setup_theme(theme=SETTINGS["theme"])
45    
46            with open("scr/files/settings/settings.json", "w", encoding="utf-8") as file:
47                dump(SETTINGS, file, indent=4)
48    
49            thr = threading.Thread(target=lambda: SettingsFunctions.newRunProgram())
50            thr.start()
51    
52            dialog.close()
53    
54            project.close()
55    
56        @staticmethod
57        def cancel(project, dialog, event) -> None:
58            dialog.close()
59    
60        @staticmethod
61        def reset(project, dialog, event) -> None:
62            settings = {}
63    
64            for key, value in BASE_SETTINGS.items():
65                settings[key] = value
66    
67            var = [dialog.objects["language_combobox"].itemText(i) for i in range(dialog.objects["language_combobox"].count())]
68            dialog.objects["language_combobox"].setCurrentIndex([element == LANGUAGES[settings["language"]] for element in var].index(True))
69    
70        @staticmethod
71        def install(project, dialog, event):
72            os.system("setup.bat")
73    
74            dialog.objects["reset_button"].setDisabled(False)
75            dialog.objects["reset_button"].setText(translate("Reinstall python"))
76    
77        @staticmethod
78        def python(project, dialog, event) -> None:
79            dialog.objects["reset_button"].setDisabled(True)
80            dialog.objects["reset_button"].setText(translate("In progress..."))
81    
82            thr = threading.Thread(target=lambda: SettingsFunctions.install(project, dialog, event))
83            thr.start()
84    
85    
86    class Settings(QDialog):
87        def __init__(self, project, parent=None) -> None:
88            QDialog.__init__(self, parent)
89    
90            self.project = project
91    
92            self.setWindowTitle(translate("Settings"))
93            self.setFixedSize(1280, 720)
94    
95            desktop = QtWidgets.QApplication.desktop()
96            self.move((desktop.width() - self.width()) // 2, (desktop.height() - self.height() - PLUS) // 2)
97    
98            self.objects = {}
99    
100            self.init()
101   
102       def init(self) -> None:
103           self.objects["empty"] = QPushButton(parent=self)
104           self.objects["empty"].setGeometry(0, 0, 0, 0)
105   
106           # LANGUAGE
107   
108           self.objects["language_label"] = QLabel(parent=self, text=translate("Language") + ":")
109           self.objects["language_label"].setGeometry(10, 10, 200, 25)
110           self.objects["language_label"].setFont(FONT)
111           self.objects["language_label"].show()
112   
113           self.objects["language_combobox"] = QComboBox(parent=self)
114           self.objects["language_combobox"].addItems([obj for obj in LANGUAGES.values()])
115           self.objects["language_combobox"].setCurrentIndex([translate(obj).lower() == translate(LANGUAGES[SETTINGS["language"]]).lower() for obj in LANGUAGES.values()].index(True))
116           self.objects["language_combobox"].setGeometry(210, 10, 300, 25)
117           self.objects["language_combobox"].setFont(FONT)
118           self.objects["language_combobox"].show()
119   
120           # THEME
121   
122           self.objects["theme_label"] = QLabel(parent=self, text=translate("Theme") + ":")
123           self.objects["theme_label"].setGeometry(10, 45, 200, 25)
124           self.objects["theme_label"].setFont(FONT)
125           self.objects["theme_label"].show()
126   
127           self.objects["theme_combobox"] = QComboBox(parent=self)
128           self.objects["theme_combobox"].addItems([translate(obj) for obj in THEMES.values()])
129           self.objects["theme_combobox"].setCurrentIndex([translate(obj).lower() == translate(THEMES[SETTINGS["theme"]]).lower() for obj in THEMES.values()].index(True))
130           self.objects["theme_combobox"].setGeometry(210, 45, 300, 25)
131           self.objects["theme_combobox"].setFont(FONT)
132           self.objects["theme_combobox"].show()
133   
134           # COMFIRM
135   
136           self.objects["confirm_button"] = QPushButton(parent=self, text=translate("Confirm"))
137           self.objects["confirm_button"].setGeometry(20, 740 - 80, 300, 40)
138           self.objects["confirm_button"].setFont(FONT)
139           self.objects["confirm_button"].show()
140   
141           self.objects["confirm_button"].clicked.connect(lambda event: SettingsFunctions.confirm(self.project, self, event))
142   
143           self.objects["confirm_button"].released.connect(lambda: self.objects["empty"].setFocus())
144           self.objects["confirm_button"].setStyleSheet(BUTTON_BLUE_STYLE)
145   
146           self.objects["cancel_button"] = QPushButton(parent=self, text=translate("Cancel"))
147           self.objects["cancel_button"].setGeometry(340, 740 - 80, 300, 40)
148           self.objects["cancel_button"].setFont(FONT)
149           self.objects["cancel_button"].show()
150   
151           self.objects["cancel_button"].clicked.connect(lambda event: SettingsFunctions.cancel(self.project, self, event))
152   
153           self.objects["cancel_button"].released.connect(lambda: self.objects["empty"].setFocus())
154           self.objects["cancel_button"].setStyleSheet(BUTTON_BLUE_STYLE)
155   
156           # RESET SETTINGS
157   
158           self.objects["reset_button"] = QPushButton(parent=self, text=translate("Reset settings"))
159           self.objects["reset_button"].setGeometry(960, 740 - 80, 300, 40)
160           self.objects["reset_button"].setFont(FONT)
161           self.objects["reset_button"].show()
162   
163           self.objects["reset_button"].clicked.connect(lambda event: SettingsFunctions.reset(self.project, self, event))
164   
165           self.objects["reset_button"].released.connect(lambda: self.objects["empty"].setFocus())
166           self.objects["reset_button"].setStyleSheet(BUTTON_RED_STYLE)
167   
168           # REINSTALL PYTHON
169   
170           self.objects["reset_button"] = QPushButton(parent=self, text=translate("Reinstall python"))
171           self.objects["reset_button"].setGeometry(960, 680 - 80, 300, 40)
172           self.objects["reset_button"].setFont(FONT)
173           self.objects["reset_button"].show()
174   
175           self.objects["reset_button"].clicked.connect(lambda event: SettingsFunctions.python(self.project, self, event))
176   
177           self.objects["reset_button"].released.connect(lambda: self.objects["empty"].setFocus())
178           self.objects["reset_button"].setStyleSheet(BUTTON_RED_STYLE)
179   
##### scr\modules\dialogs\file\__init__.py #####
1     from .create_project import CreateProject
2     from .open_project import OpenProject
3     from .settings import Settings
4     from .create_from_template_project import CreateFromTemplateProject
5     
##### scr\modules\dialogs\help\about.py #####
1     from PyQt5.QtWidgets import QDialog, QLabel
2     from PyQt5.QtCore import Qt
3     from PyQt5 import QtWidgets
4     
5     from scr.variables import *
6     
7     import datetime
8     
9     
10     class About(QDialog):
11        def __init__(self, project, parent=None) -> None:
12            QDialog.__init__(self, parent)
13    
14            self.project = project
15    
16            self.setWindowTitle(translate("About"))
17            self.setFixedSize(600, 400)
18    
19            desktop = QtWidgets.QApplication.desktop()
20            self.move((desktop.width() - self.width()) // 2, (desktop.height() - self.height() - PLUS) // 2)
21    
22            self.objects = {}
23    
24            self.init()
25    
26        def init(self) -> None:
27            for element in self.objects.values():
28                element.deleteLater()
29    
30            self.objects["name"] = QLabel(parent=self)
31            self.objects["name"].setText(f"Game Engine 3 v{load(open('scr/files/version.json', 'r', encoding='utf-8'))['version']}")
32            self.objects["name"].setGeometry(40, 10, 300, 40)
33            self.objects["name"].setFont(BIG_HELP_FONT)
34            self.objects["name"].show()
35    
36            self.objects["site"] = QLabel(parent=self)
37            self.objects["site"].setFont(HELP_FONT)
38            self.objects["site"].setGeometry(10, 45, 600, 40)
39            self.objects["site"].setTextFormat(Qt.RichText)
40            self.objects["site"].setText("Site: <a href='https://artyom7774.github.io'>https://artyom7774.github.io</a>")
41            self.objects["site"].setOpenExternalLinks(True)
42            self.objects["site"].show()
43    
44            self.objects["github"] = QLabel(parent=self)
45            self.objects["github"].setFont(HELP_FONT)
46            self.objects["github"].setGeometry(10, 65, 600, 40)
47            self.objects["github"].setTextFormat(Qt.RichText)
48            self.objects["github"].setText("GitHub: <a href='https://github.com/artyom7774/Game-Engine-3'>https://github.com/artyom7774/Game-Engine-3</a>")
49            self.objects["github"].setOpenExternalLinks(True)
50            self.objects["github"].show()
51    
52            self.objects["copyright"] = QLabel(parent=self)
53            self.objects["copyright"].setAlignment(Qt.AlignCenter)
54            self.objects["copyright"].setFont(HELP_FONT)
55            self.objects["copyright"].setGeometry(0, 370, 600, 30)
56            self.objects["copyright"].setText(f"Copyright ©2023-{datetime.datetime.now().year}")
57            self.objects["copyright"].show()
58    
##### scr\modules\dialogs\help\help.py #####
1     from PyQt5.QtWidgets import QDialog, QLabel
2     from PyQt5.QtCore import Qt
3     from PyQt5 import QtWidgets
4     
5     from scr.variables import *
6     
7     import webbrowser
8     import threading
9     
10     
11    class Help(QMessageBox):
12        def __init__(self, project, parent=None) -> None:
13            QDialog.__init__(self, parent)
14    
15            self.project = project
16    
17            self.setWindowTitle(translate("Create file"))
18            self.setFixedSize(600, 400)
19    
20            desktop = QtWidgets.QApplication.desktop()
21            self.move((desktop.width() - self.width()) // 2, (desktop.height() - self.height() - PLUS) // 2)
22    
23            self.objects = {}
24    
25            self.init()
26    
27            thr = threading.Thread(target=lambda: webbrowser.open("https://artyom7774.github.io"))
28            thr.daemon = True
29            thr.start()
30    
31        def init(self):
32            pass
33    
##### scr\modules\dialogs\help\__init__.py #####
1     from .help import Help
2     from .about import About
3     
##### scr\modules\dialogs\scene\create_scene_object.py #####
1     from PyQt5.QtWidgets import QDialog, QLabel, QComboBox, QPushButton
2     from PyQt5.QtCore import Qt
3     from PyQt5 import QtWidgets
4     
5     from scr.modules import functions
6     
7     from scr.variables import *
8     
9     import shutil
10     import os
11    
12    
13    class CreateSceneObjectFunctions:
14        @staticmethod
15        def create(project, dialog, position, event) -> None:
16            index = dialog.objects["project_combobox"].currentIndex()
17    
18            try:
19                path = functions.project.getAllProjectObjects(project)[index]
20    
21            except IndexError:
22                return
23    
24            name = path[path.rfind("/") + 1:]
25            name = name[:path.rfind(".")]
26    
27            extension = path[path.rfind(".") + 1:]
28    
29            name = name.replace(f".{extension}", "")
30    
31            files = os.listdir(project.selectFile)
32            files.sort()
33    
34            index = 0
35    
36            for file in files:
37                for element in files:
38                    if element.endswith(f"{index}.objc"):
39                        index += 1
40    
41            out = f"{project.selectFile}/{name}-{index}.objc"
42    
43            shutil.copyfile(path, out)
44    
45            position = [
46                position.x() - project.objects["main"]["scene"].width() // 2 + project.cash["file"][project.selectFile].camera.pos.x,
47                position.y() - project.objects["main"]["scene"].height() // 2 + project.cash["file"][project.selectFile].camera.pos.y
48            ]
49    
50            if project.objects["main"]["scene_settings"]["Scene"]["snap"]["value"]:
51                width = project.objects["main"]["scene_settings"]["Scene"]["grid"]["value"]["x"]["value"]
52                height = project.objects["main"]["scene_settings"]["Scene"]["grid"]["value"]["y"]["value"]
53    
54                position[0] = position[0] // width * width
55                position[1] = position[1] // height * height
56    
57            with open(out, "r", encoding="utf-8") as f:
58                obj = load(f)
59    
60            obj["StaticObject"]["pos"]["value"]["x"]["value"] = position[0]
61            obj["StaticObject"]["pos"]["value"]["y"]["value"] = position[1]
62    
63            with open(out, "w") as f:
64                dump(obj, f)
65    
66            project.init()
67    
68            dialog.close()
69    
70    
71    class CreateSceneObject(QDialog):
72        def __init__(self, project, position, parent=None) -> None:
73            QDialog.__init__(self, parent)
74    
75            self.project = project
76    
77            self.position = position
78    
79            self.setWindowTitle(translate("Create object"))
80            self.setFixedSize(600, 400)
81    
82            desktop = QtWidgets.QApplication.desktop()
83            self.move((desktop.width() - self.width()) // 2, (desktop.height() - self.height() - PLUS) // 2)
84    
85            self.objects = {}
86    
87            self.init()
88    
89        def init(self) -> None:
90            self.objects["empty"] = QPushButton(parent=self)
91            self.objects["empty"].setGeometry(0, 0, 0, 0)
92    
93            # ALL PROJECTS -> COMBOBOX
94    
95            self.objects["project_label"] = QLabel(parent=self, text=translate("Object") + ":")
96            self.objects["project_label"].setGeometry(10, 10, 200, 25)
97            self.objects["project_label"].setFont(FONT)
98            self.objects["project_label"].show()
99    
100            self.objects["project_combobox"] = QComboBox(parent=self)
101           self.objects["project_combobox"].setGeometry(210, 10, 300, 25)
102           self.objects["project_combobox"].setFont(FONT)
103           self.objects["project_combobox"].show()
104   
105           self.objects["project_combobox"].addItems(functions.project.getAllProjectObjects(self.project, True))
106   
107           # CREATE
108   
109           self.objects["open_button"] = QPushButton(parent=self, text=translate("Create"))
110           self.objects["open_button"].setStyleSheet(BUTTON_BLUE_STYLE)
111   
112           self.objects["open_button"].released.connect(lambda: self.objects["empty"].setFocus())
113   
114           self.objects["open_button"].setGeometry(150, 340, 300, 40)
115           self.objects["open_button"].setFont(FONT)
116           self.objects["open_button"].show()
117   
118           self.objects["open_button"].clicked.connect(lambda event: CreateSceneObjectFunctions.create(self.project, self, self.position, event))
119   
120       def keyPressEvent(self, event) -> None:
121           if event.key() in (Qt.Key_Enter, Qt.Key_Return):
122               self.objects["open_button"].click()
123   
124           event.accept()
125   
##### scr\modules\dialogs\scene\__init__.py #####
1     from .create_scene_object import CreateSceneObject
2     
##### scr\modules\dialogs\tree\create_dir.py #####
1     from PyQt5.QtWidgets import QDialog, QLabel, QPushButton, QLineEdit
2     from PyQt5.QtCore import Qt
3     from PyQt5 import QtWidgets, QtCore
4     
5     from scr.modules.functions.project import projectTreeGetPath, projectTreeGetFilePath
6     
7     from scr.variables import *
8     
9     import os
10     
11    
12    class CreateDirFunctions:
13        @staticmethod
14        def create(project, dialog, event) -> None:
15            path = projectTreeGetFilePath(projectTreeGetPath(project.objects["tree_project"].selectedItems()[0]))
16    
17            name = dialog.objects["name_entry"].text()
18    
19            # LOGGER
20    
21            if name == "":
22                dialog.objects["log_label"].setText("Imposiable directory name")
23    
24                return 0
25    
26            try:
27                with open(f"scr/files/using/{name}", "w", encoding="utf-8") as file:
28                    pass
29    
30            except BaseException:
31                dialog.objects["log_label"].setText("Imposiable directory name")
32    
33                return 0
34    
35            for element in os.listdir(path):
36                if element == name:
37                    dialog.objects["log_label"].setText("Directory name already exist")
38    
39                    return 0
40    
41            # CREATE
42    
43            os.mkdir(f"{path}/{name}")
44    
45            project.init()
46    
47            dialog.close()
48    
49    
50    class CreateDir(QDialog):
51        def __init__(self, project, parent=None) -> None:
52            QDialog.__init__(self, parent)
53    
54            self.project = project
55    
56            self.setWindowTitle(translate("Create directory"))
57            self.setFixedSize(600, 400)
58    
59            desktop = QtWidgets.QApplication.desktop()
60            self.move((desktop.width() - self.width()) // 2, (desktop.height() - self.height() - PLUS) // 2)
61    
62            self.objects = {}
63    
64            self.init()
65    
66        def init(self) -> None:
67            self.objects["empty"] = QPushButton(parent=self)
68            self.objects["empty"].setGeometry(0, 0, 0, 0)
69    
70            # NAME
71    
72            self.objects["name_label"] = QLabel(parent=self, text=translate("Directory name") + ":")
73            self.objects["name_label"].setGeometry(10, 10, 200, 25)
74            self.objects["name_label"].setFont(FONT)
75            self.objects["name_label"].show()
76    
77            self.objects["name_entry"] = QLineEdit(parent=self)
78            self.objects["name_entry"].setGeometry(210, 10, 300, 25)
79            self.objects["name_entry"].setFont(FONT)
80            self.objects["name_entry"].show()
81    
82            # LOG TEXT
83    
84            self.objects["log_label"] = QLabel(parent=self, text="")
85            self.objects["log_label"].setGeometry(0, 310, 600, 20)
86            self.objects["log_label"].setFont(FONT)
87            self.objects["log_label"].show()
88    
89            self.objects["log_label"].setAlignment(QtCore.Qt.AlignmentFlag.AlignHCenter)
90            self.objects["log_label"].setStyleSheet("color: red;")
91    
92            # CREATE
93    
94            self.objects["create_button"] = QPushButton(parent=self, text=translate("Create"))
95            self.objects["create_button"].setStyleSheet(BUTTON_BLUE_STYLE)
96    
97            self.objects["create_button"].released.connect(lambda: self.objects["empty"].setFocus())
98    
99            self.objects["create_button"].setGeometry(150, 340, 300, 40)
100            self.objects["create_button"].setFont(FONT)
101           self.objects["create_button"].show()
102   
103           self.objects["create_button"].clicked.connect(lambda event: CreateDirFunctions.create(self.project, self, event))
104   
105       def keyPressEvent(self, event) -> None:
106           if event.key() in (Qt.Key_Enter, Qt.Key_Return):
107               self.objects["create_button"].click()
108   
109           event.accept()
110   
##### scr\modules\dialogs\tree\create_file.py #####
1     from PyQt5.QtWidgets import QDialog, QLabel, QPushButton, QLineEdit
2     from PyQt5.QtCore import Qt
3     from PyQt5 import QtWidgets, QtCore
4     
5     from scr.modules.functions.project import projectTreeGetPath, projectTreeGetFilePath
6     
7     from scr.variables import *
8     
9     import os
10     
11    
12    class CreateFileFunctions:
13        @staticmethod
14        def create(project, dialog, event) -> None:
15            path = projectTreeGetFilePath(projectTreeGetPath(project.objects["tree_project"].selectedItems()[0]))
16    
17            name = dialog.objects["name_entry"].text() + "." + dialog.objects["extension_entry"].text()
18    
19            # LOGGER
20    
21            if name == "":
22                dialog.objects["log_label"].setText("Imposiable file name")
23    
24                return 0
25    
26            if dialog.objects["extension_entry"].text() in ("cfg", *BLOCKED_FORMATES):
27                dialog.objects["log_label"].setText("Imposiable file extension")
28    
29                return 0
30    
31            if name[-1] == ".":
32                dialog.objects["log_label"].setText("File extension is not found")
33    
34                return 0
35    
36            try:
37                with open(f"scr/files/using/{name}", "w", encoding="utf-8") as file:
38                    pass
39    
40            except BaseException:
41                dialog.objects["log_label"].setText("Imposiable File name")
42    
43                return 0
44    
45            for element in os.listdir(path):
46                if element == name:
47                    dialog.objects["log_label"].setText("File name already exist")
48    
49                    return 0
50    
51            # CREATE
52    
53            with open(f"{path}/{name}", "w", encoding="utf-8") as file:
54                pass
55    
56            project.init()
57    
58            dialog.close()
59    
60    
61    class CreateFile(QDialog):
62        def __init__(self, project, parent=None) -> None:
63            QDialog.__init__(self, parent)
64    
65            self.project = project
66    
67            self.setWindowTitle(translate("Create file"))
68            self.setFixedSize(600, 400)
69    
70            desktop = QtWidgets.QApplication.desktop()
71            self.move((desktop.width() - self.width()) // 2, (desktop.height() - self.height() - PLUS) // 2)
72    
73            self.objects = {}
74    
75            self.init()
76    
77        def init(self) -> None:
78            self.objects["empty"] = QPushButton(parent=self)
79            self.objects["empty"].setGeometry(0, 0, 0, 0)
80    
81            # NAME
82    
83            self.objects["name_label"] = QLabel(parent=self, text=translate("File name") + ":")
84            self.objects["name_label"].setGeometry(10, 10, 200, 25)
85            self.objects["name_label"].setFont(FONT)
86            self.objects["name_label"].show()
87    
88            self.objects["name_entry"] = QLineEdit(parent=self)
89            self.objects["name_entry"].setGeometry(210, 10, 300, 25)
90            self.objects["name_entry"].setFont(FONT)
91            self.objects["name_entry"].show()
92    
93            # EXTENSION
94    
95            self.objects["extension_label"] = QLabel(parent=self, text=translate("File extension") + ":")
96            self.objects["extension_label"].setGeometry(10, 45, 200, 25)
97            self.objects["extension_label"].setFont(FONT)
98            self.objects["extension_label"].show()
99    
100            self.objects["extension_entry"] = QLineEdit(parent=self)
101           self.objects["extension_entry"].setGeometry(210, 45, 300, 25)
102           self.objects["extension_entry"].setFont(FONT)
103           self.objects["extension_entry"].show()
104   
105           # LOG TEXT
106   
107           self.objects["log_label"] = QLabel(parent=self, text="")
108           self.objects["log_label"].setGeometry(0, 310, 600, 20)
109           self.objects["log_label"].setFont(FONT)
110           self.objects["log_label"].show()
111   
112           self.objects["log_label"].setAlignment(QtCore.Qt.AlignmentFlag.AlignHCenter)
113           self.objects["log_label"].setStyleSheet("color: red;")
114   
115           # CREATE
116   
117           self.objects["create_button"] = QPushButton(parent=self, text=translate("Create"))
118           self.objects["create_button"].setStyleSheet(BUTTON_BLUE_STYLE)
119   
120           self.objects["create_button"].released.connect(lambda: self.objects["empty"].setFocus())
121   
122           self.objects["create_button"].setGeometry(150, 340, 300, 40)
123           self.objects["create_button"].setFont(FONT)
124           self.objects["create_button"].show()
125   
126           self.objects["create_button"].clicked.connect(lambda event: CreateFileFunctions.create(self.project, self, event))
127   
128       def keyPressEvent(self, event) -> None:
129           if event.key() in (Qt.Key_Enter, Qt.Key_Return):
130               self.objects["create_button"].click()
131   
132           event.accept()
133   
##### scr\modules\dialogs\tree\create_function.py #####
1     from PyQt5.QtWidgets import QDialog, QLabel, QPushButton, QLineEdit
2     from PyQt5.QtCore import Qt
3     from PyQt5 import QtWidgets, QtCore
4     
5     from scr.modules.functions.project import projectTreeGetPath, projectTreeGetFilePath
6     
7     from scr.variables import *
8     
9     import os
10     
11    CODE_BASE_FILE = dumps({"variables": {}, "objects": {}}, indent=4)
12    
13    
14    class CreateFunctionFunctions:
15        @staticmethod
16        def create(project, dialog, event) -> None:
17            path = projectTreeGetFilePath(projectTreeGetPath(project.objects["tree_project"].selectedItems()[0]))
18    
19            name = dialog.objects["name_entry"].text()
20    
21            # LOGGER
22    
23            if name == "":
24                dialog.objects["log_label"].setText("Imposiable function name")
25    
26                return 0
27    
28            try:
29                with open(f"scr/files/using/{name}", "w", encoding="utf-8") as file:
30                    pass
31    
32            except BaseException:
33                dialog.objects["log_label"].setText("Imposiable function name")
34    
35                return 0
36    
37            for element in os.listdir(path):
38                if element == name:
39                    dialog.objects["log_label"].setText("Function name already exist")
40    
41                    return 0
42    
43            # CREATE
44    
45            with open(f"{path}/{name}.func", "w", encoding="utf-8") as file:
46                file.write(CODE_BASE_FILE)
47    
48            project.init()
49    
50            dialog.close()
51    
52    
53    class CreateFunction(QDialog):
54        def __init__(self, project, parent=None) -> None:
55            QDialog.__init__(self, parent)
56    
57            self.project = project
58    
59            self.setWindowTitle(translate("Create function"))
60            self.setFixedSize(600, 400)
61    
62            desktop = QtWidgets.QApplication.desktop()
63            self.move((desktop.width() - self.width()) // 2, (desktop.height() - self.height() - PLUS) // 2)
64    
65            self.objects = {}
66    
67            self.init()
68    
69        def init(self) -> None:
70            self.objects["empty"] = QPushButton(parent=self)
71            self.objects["empty"].setGeometry(0, 0, 0, 0)
72    
73            # NAME
74    
75            self.objects["name_label"] = QLabel(parent=self, text=translate("Function name") + ":")
76            self.objects["name_label"].setGeometry(10, 10, 200, 25)
77            self.objects["name_label"].setFont(FONT)
78            self.objects["name_label"].show()
79    
80            self.objects["name_entry"] = QLineEdit(parent=self)
81            self.objects["name_entry"].setGeometry(210, 10, 300, 25)
82            self.objects["name_entry"].setFont(FONT)
83            self.objects["name_entry"].show()
84    
85            # LOG TEXT
86    
87            self.objects["log_label"] = QLabel(parent=self, text="")
88            self.objects["log_label"].setGeometry(0, 310, 600, 20)
89            self.objects["log_label"].setFont(FONT)
90            self.objects["log_label"].show()
91    
92            self.objects["log_label"].setAlignment(QtCore.Qt.AlignmentFlag.AlignHCenter)
93            self.objects["log_label"].setStyleSheet("color: red;")
94    
95            # CREATE
96    
97            self.objects["create_button"] = QPushButton(parent=self, text=translate("Create"))
98            self.objects["create_button"].setStyleSheet(BUTTON_BLUE_STYLE)
99    
100            self.objects["create_button"].released.connect(lambda: self.objects["empty"].setFocus())
101   
102           self.objects["create_button"].setGeometry(150, 340, 300, 40)
103           self.objects["create_button"].setFont(FONT)
104           self.objects["create_button"].show()
105   
106           self.objects["create_button"].clicked.connect(lambda event: CreateFunctionFunctions.create(self.project, self, event))
107   
108       def keyPressEvent(self, event) -> None:
109           if event.key() in (Qt.Key_Enter, Qt.Key_Return):
110               self.objects["create_button"].click()
111   
112           event.accept()
113   
##### scr\modules\dialogs\tree\create_object.py #####
1     from PyQt5.QtWidgets import QDialog, QLabel, QPushButton, QLineEdit
2     from PyQt5.QtCore import Qt
3     from PyQt5 import QtWidgets, QtCore
4     
5     from scr.modules.functions.project import projectTreeGetPath, projectTreeGetFilePath
6     
7     from scr.variables import *
8     
9     import os
10     
11    
12    class CreateObjectFunctions:
13        @staticmethod
14        def create(project, dialog, event, name: str = None, logger: bool = True, loadFile: str = "engine/files/objects.json", save: str = None) -> None:
15            if save is None:
16                path = projectTreeGetFilePath(projectTreeGetPath(project.objects["tree_project"].selectedItems()[0]))
17    
18            else:
19                path = save
20    
21            if name is None:
22                name = dialog.objects["name_entry"].text()
23    
24            # LOGGER
25    
26            if logger:
27                if name == "":
28                    dialog.objects["log_label"].setText("Imposiable object name")
29    
30                    return 0
31    
32                try:
33                    with open(f"scr/files/using/{name}", "w", encoding="utf-8") as file:
34                        pass
35    
36                except BaseException:
37                    dialog.objects["log_label"].setText("Imposiable object name")
38    
39                    return 0
40    
41                for element in os.listdir(path):
42                    if element == name:
43                        dialog.objects["log_label"].setText("Object name already exist")
44    
45                        return 0
46    
47            # CREATE
48    
49            with open(loadFile, "r", encoding="utf-8") as file:
50                objects = load(file)
51    
52            out = {
53                "dependences": objects["dependences"],
54                "dependence": objects["dependences"][objects["standard"]["type"]],
55                "type": {
56                    "name": objects["name"]["type"],
57                    "value": objects["standard"]["type"],
58                    "type": objects["type"]["type"]
59                },
60                "variables": {}
61            }
62    
63            if out["type"]["type"] == "choose":
64                out["type"]["choose"] = objects["specials"]["choose"]["type"]
65    
66            for element in list(set([key for key in objects["dependences"].keys()] + [out["type"]["value"]])):
67                for value in objects["objects"][element]:
68                    if element not in out:
69                        out[element] = {}
70    
71                    if objects["type"] == "choose":
72                        out[element][value] = {
73                            "name": objects["name"][value],
74                            "value": objects["standard"][value],
75                            "type": objects["type"][value],
76                            "choose": objects["specials"]["choose"][value]
77                        }
78    
79                    else:
80                        out[element][value] = {
81                            "name": objects["name"][value],
82                            "value": objects["standard"][value],
83                            "type": objects["type"][value]
84                        }
85    
86            if name == "":
87                with open(f"{path}", "w", encoding="utf-8") as file:
88                    dump(out, file, indent=4)
89    
90            else:
91                with open(f"{path}/{name}.obj", "w", encoding="utf-8") as file:
92                    dump(out, file, indent=4)
93    
94            project.init()
95    
96            if dialog is not None:
97                dialog.close()
98    
99    
100    class CreateObject(QDialog):
101       def __init__(self, project, parent=None) -> None:
102           QDialog.__init__(self, parent)
103   
104           self.project = project
105   
106           self.setWindowTitle(translate("Create object"))
107           self.setFixedSize(600, 400)
108   
109           desktop = QtWidgets.QApplication.desktop()
110           self.move((desktop.width() - self.width()) // 2, (desktop.height() - self.height() - PLUS) // 2)
111   
112           self.objects = {}
113   
114           self.init()
115   
116       def init(self) -> None:
117           self.objects["empty"] = QPushButton(parent=self)
118           self.objects["empty"].setGeometry(0, 0, 0, 0)
119   
120           # NAME
121   
122           self.objects["name_label"] = QLabel(parent=self, text=translate("Object name") + ":")
123           self.objects["name_label"].setGeometry(10, 10, 200, 25)
124           self.objects["name_label"].setFont(FONT)
125           self.objects["name_label"].show()
126   
127           self.objects["name_entry"] = QLineEdit(parent=self)
128           self.objects["name_entry"].setGeometry(210, 10, 300, 25)
129           self.objects["name_entry"].setFont(FONT)
130           self.objects["name_entry"].show()
131   
132           # LOG TEXT
133   
134           self.objects["log_label"] = QLabel(parent=self, text="")
135           self.objects["log_label"].setGeometry(0, 310, 600, 20)
136           self.objects["log_label"].setFont(FONT)
137           self.objects["log_label"].show()
138   
139           self.objects["log_label"].setAlignment(QtCore.Qt.AlignmentFlag.AlignHCenter)
140           self.objects["log_label"].setStyleSheet("color: red;")
141   
142           # CREATE
143   
144           self.objects["create_button"] = QPushButton(parent=self, text=translate("Create"))
145           self.objects["create_button"].setStyleSheet(BUTTON_BLUE_STYLE)
146   
147           self.objects["create_button"].released.connect(lambda: self.objects["empty"].setFocus())
148   
149           self.objects["create_button"].setGeometry(150, 340, 300, 40)
150           self.objects["create_button"].setFont(FONT)
151           self.objects["create_button"].show()
152   
153           self.objects["create_button"].clicked.connect(lambda event: CreateObjectFunctions.create(self.project, self, event))
154   
155       def keyPressEvent(self, event) -> None:
156           if event.key() in (Qt.Key_Enter, Qt.Key_Return):
157               self.objects["create_button"].click()
158   
159           event.accept()
160   
##### scr\modules\dialogs\tree\create_scene.py #####
1     from PyQt5.QtWidgets import QDialog, QLabel, QPushButton, QLineEdit
2     from PyQt5.QtCore import Qt
3     from PyQt5 import QtWidgets, QtCore
4     
5     from scr.modules.functions.project import projectTreeGetPath, projectTreeGetFilePath
6     
7     from scr.variables import *
8     
9     import os
10     
11    
12    class CreateSceneFunctions:
13        @staticmethod
14        def create(project, dialog, event) -> None:
15            path = projectTreeGetFilePath(projectTreeGetPath(project.objects["tree_project"].selectedItems()[0]))
16    
17            name = dialog.objects["name_entry"].text()
18    
19            # LOGGER
20    
21            if name == "":
22                dialog.objects["log_label"].setText("Imposiable scene name")
23    
24                return 0
25    
26            try:
27                with open(f"scr/files/using/{name}", "w", encoding="utf-8") as file:
28                    pass
29    
30            except BaseException:
31                dialog.objects["log_label"].setText("Imposiable scene name")
32    
33                return 0
34    
35            for element in os.listdir(path):
36                if element == name:
37                    dialog.objects["log_label"].setText("Scene name already exist")
38    
39                    return 0
40    
41            # CREATE
42    
43            os.mkdir(f"{path}/%scene%{name}")
44    
45            project.init()
46    
47            dialog.close()
48    
49    
50    class CreateScene(QDialog):
51        def __init__(self, project, parent=None) -> None:
52            QDialog.__init__(self, parent)
53    
54            self.project = project
55    
56            self.setWindowTitle(translate("Create scene"))
57            self.setFixedSize(600, 400)
58    
59            desktop = QtWidgets.QApplication.desktop()
60            self.move((desktop.width() - self.width()) // 2, (desktop.height() - self.height() - PLUS) // 2)
61    
62            self.objects = {}
63    
64            self.init()
65    
66        def init(self) -> None:
67            self.objects["empty"] = QPushButton(parent=self)
68            self.objects["empty"].setGeometry(0, 0, 0, 0)
69    
70            # NAME
71    
72            self.objects["name_label"] = QLabel(parent=self, text=translate("Scene name") + ":")
73            self.objects["name_label"].setGeometry(10, 10, 200, 25)
74            self.objects["name_label"].setFont(FONT)
75            self.objects["name_label"].show()
76    
77            self.objects["name_entry"] = QLineEdit(parent=self)
78            self.objects["name_entry"].setGeometry(210, 10, 300, 25)
79            self.objects["name_entry"].setFont(FONT)
80            self.objects["name_entry"].show()
81    
82            # LOG TEXT
83    
84            self.objects["log_label"] = QLabel(parent=self, text="")
85            self.objects["log_label"].setGeometry(0, 310, 600, 20)
86            self.objects["log_label"].setFont(FONT)
87            self.objects["log_label"].show()
88    
89            self.objects["log_label"].setAlignment(QtCore.Qt.AlignmentFlag.AlignHCenter)
90            self.objects["log_label"].setStyleSheet("color: red;")
91    
92            # CREATE
93    
94            self.objects["create_button"] = QPushButton(parent=self, text=translate("Create"))
95            self.objects["create_button"].setStyleSheet(BUTTON_BLUE_STYLE)
96    
97            self.objects["create_button"].released.connect(lambda: self.objects["empty"].setFocus())
98    
99            self.objects["create_button"].setGeometry(150, 340, 300, 40)
100            self.objects["create_button"].setFont(FONT)
101           self.objects["create_button"].show()
102   
103           self.objects["create_button"].clicked.connect(lambda event: CreateSceneFunctions.create(self.project, self, event))
104   
105       def keyPressEvent(self, event) -> None:
106           if event.key() in (Qt.Key_Enter, Qt.Key_Return):
107               self.objects["create_button"].click()
108   
109           event.accept()
110   
##### scr\modules\dialogs\tree\rename_object.py #####
1     from PyQt5.QtWidgets import QDialog, QLabel, QPushButton, QLineEdit
2     from PyQt5.QtCore import Qt
3     from PyQt5 import QtWidgets, QtCore
4     
5     from scr.modules.functions.project import projectTreeGetPath, projectTreeGetFilePath
6     
7     from scr.variables import *
8     
9     import os
10     import re
11    
12    
13    class RenameObjectFunctions:
14        @staticmethod
15        def rename(project, dialog, event) -> None:
16            path = projectTreeGetFilePath(projectTreeGetPath(project.objects["tree_project"].selectedItems()[0]))
17    
18            name = dialog.objects["name_entry"].text()
19    
20            # LOGGER
21    
22            if name == "":
23                dialog.objects["log_label"].setText("Imposiable object name")
24    
25                return 0
26    
27            try:
28                with open(f"scr/files/using/{name}", "w", encoding="utf-8") as file:
29                    pass
30    
31            except BaseException:
32                dialog.objects["log_label"].setText("Imposiable object name")
33    
34                return 0
35    
36            for element in os.listdir(path if os.path.isdir(path) else path[:path.rfind("/")]):
37                if element == name:
38                    dialog.objects["log_label"].setText("Object name already exist")
39    
40                    return 0
41    
42            # UPDATE FILES
43    
44            last = path[path.rfind("/") + 1:]
45            extension = last[last.rfind(".") + 1:]
46    
47            specials = "".join(re.findall(r'%.*?%', last))
48    
49            if os.path.isdir(path):
50                last, extension = extension, last
51    
52            else:
53                pass
54    
55            # RENAME
56    
57            try:
58                if os.path.isfile(path):
59                    os.rename(path, path[:path.rfind("/")] + "/" + specials + name + "." + extension)
60    
61                else:
62                    os.rename(path, path[:path.rfind("/")] + "/" + specials + name)
63    
64            except FileExistsError:
65                MessageBox.error("file exists in this directory")
66    
67            project.init()
68    
69            dialog.close()
70    
71    
72    class RenameObject(QDialog):
73        def __init__(self, project, parent=None) -> None:
74            QDialog.__init__(self, parent)
75    
76            self.project = project
77    
78            self.setWindowTitle(translate("Rename object"))
79            self.setFixedSize(600, 400)
80    
81            desktop = QtWidgets.QApplication.desktop()
82            self.move((desktop.width() - self.width()) // 2, (desktop.height() - self.height() - PLUS) // 2)
83    
84            self.objects = {}
85    
86            self.init()
87    
88        def init(self) -> None:
89            self.objects["empty"] = QPushButton(parent=self)
90            self.objects["empty"].setGeometry(0, 0, 0, 0)
91    
92            # NAME
93    
94            self.objects["name_label"] = QLabel(parent=self, text=translate("New name") + ":")
95            self.objects["name_label"].setGeometry(10, 10, 200, 25)
96            self.objects["name_label"].setFont(FONT)
97            self.objects["name_label"].show()
98    
99            self.objects["name_entry"] = QLineEdit(parent=self)
100            self.objects["name_entry"].setGeometry(210, 10, 300, 25)
101           self.objects["name_entry"].setFont(FONT)
102           self.objects["name_entry"].show()
103   
104           # LOG TEXT
105   
106           self.objects["log_label"] = QLabel(parent=self, text="")
107           self.objects["log_label"].setGeometry(0, 310, 600, 20)
108           self.objects["log_label"].setFont(FONT)
109           self.objects["log_label"].show()
110   
111           self.objects["log_label"].setAlignment(QtCore.Qt.AlignmentFlag.AlignHCenter)
112           self.objects["log_label"].setStyleSheet("color: red;")
113   
114           # CREATE
115   
116           self.objects["create_button"] = QPushButton(parent=self, text=translate("Rename"))
117           self.objects["create_button"].setStyleSheet(BUTTON_BLUE_STYLE)
118   
119           self.objects["create_button"].released.connect(lambda: self.objects["empty"].setFocus())
120   
121           self.objects["create_button"].setGeometry(150, 340, 300, 40)
122           self.objects["create_button"].setFont(FONT)
123           self.objects["create_button"].show()
124   
125           self.objects["create_button"].clicked.connect(lambda event: RenameObjectFunctions.rename(self.project, self, event))
126   
127       def keyPressEvent(self, event) -> None:
128           if event.key() in (Qt.Key_Enter, Qt.Key_Return):
129               self.objects["create_button"].click()
130   
131           event.accept()
132   
##### scr\modules\dialogs\tree\__init__.py #####
1     from .create_function import CreateFunction
2     from .create_scene import CreateScene
3     from .create_dir import CreateDir
4     from .create_file import CreateFile
5     from .rename_object import RenameObject
6     from .create_object import CreateObject
7     
##### scr\modules\dialogs\__init__.py #####
1     from .tree import *
2     from .file import *
3     from .help import *
4     from .code import *
5     
6     from .scene import *
7     
8     from .animator import *
9     
##### scr\modules\functions\algorithm.py #####
1     import functools
2     import typing
3     import math
4     
5     from engine.functions.cache import cache
6     
7     
8     def cacheBezierCurve(func):
9         cache = {}
10     
11        @functools.wraps(func)
12        def wrapper(*args, **kwargs):
13            x0, y0, x1, y1, x2, y2, x3, y3, d = args
14    
15            key = f"{x0 - x1}-{x1 - x2}-{x2 - x3}-{y0 - y1}-{y1 - y2}-{y2 - y3}-{d}"
16    
17            if key not in cache:
18                cache[key] = {
19                    "pos": (x0, y0),
20                    "value": func(*args, **kwargs)
21                }
22    
23            px = x0 - cache[key]["pos"][0]
24            py = y0 - cache[key]["pos"][1]
25    
26            if px == 0 and py == 0:
27                return cache[key]["value"]
28    
29            return [[element[0] + px, element[1] + py] for element in cache[key]["value"]]
30    
31        return wrapper
32    
33    
34    @cacheBezierCurve
35    def bezierCurveDeep(x0: int, y0: int, x1: int, y1: int, x2: int, y2: int, x3: int, y3: int, d: int) -> typing.List[typing.List[int]]:
36        def function(x0: int, y0: int, x1: int, y1: int, x2: int, y2: int, x3: int, y3: int, d: int) -> typing.List[int]:
37            px = (x3 - x0) / 3
38            py = (y3 - y0) / 3
39    
40            mx1 = x1 - x0 - px
41            my1 = y1 - y0 - py
42            mx2 = x2 - x3 + px
43            my2 = y2 - y3 + py
44    
45            d1 = math.sqrt(mx1 ** 2 + my1 ** 2)
46            d2 = math.sqrt(mx2 ** 2 + my2 ** 2)
47    
48            if d1 < d and d2 < d:
49                answer.append([x3, y3])
50    
51            else:
52                x01 = (x0 + x1) / 2
53                y01 = (y0 + y1) / 2
54                x12 = (x1 + x2) / 2
55                y12 = (y1 + y2) / 2
56                x23 = (x2 + x3) / 2
57                y23 = (y2 + y3) / 2
58                x012 = (x01 + x12) / 2
59                y012 = (y01 + y12) / 2
60                x123 = (x12 + x23) / 2
61                y123 = (y12 + y23) / 2
62                x0123 = (x012 + x123) / 2
63                y0123 = (y012 + y123) / 2
64    
65                function(x0, y0, x01, y01, x012, y012, x0123, y0123, d)
66                function(x0123, y0123, x123, y123, x23, y23, x3, y3, d)
67    
68        answer = []
69    
70        function(x0, y0, x1, y1, x2, y2, x3, y3, d)
71    
72        return [[math.ceil(element[0]), math.ceil(element[1])] if i not in (0, len(answer) - 1) else element for i, element in enumerate(answer)]
73    
74    
75    @cacheBezierCurve
76    def bezierCurveWidth(x0: int, y0: int, x1: int, y1: int, x2: int, y2: int, x3: int, y3: int, d: int) -> typing.List[typing.List[int]]:
77        answer = [[x0, y0]]
78    
79        stack = [[x0, y0, x1, y1, x2, y2, x3, y3]]
80    
81        while stack:
82            var = stack.pop()
83    
84            x0, y0, x1, y1, x2, y2, x3, y3 = var
85    
86            px = (x3 - x0) / 3
87            py = (y3 - y0) / 3
88    
89            mx1 = x1 - x0 - px
90            my1 = y1 - y0 - py
91            mx2 = x2 - x3 + px
92            my2 = y2 - y3 + py
93    
94            d1 = math.sqrt(mx1 ** 2 + my1 ** 2)
95            d2 = math.sqrt(mx2 ** 2 + my2 ** 2)
96    
97            if d1 < d and d2 < d:
98                answer.append([x3, y3])
99    
100            else:
101               x01 = (x0 + x1) / 2
102               y01 = (y0 + y1) / 2
103               x12 = (x1 + x2) / 2
104               y12 = (y1 + y2) / 2
105               x23 = (x2 + x3) / 2
106               y23 = (y2 + y3) / 2
107               x012 = (x01 + x12) / 2
108               y012 = (y01 + y12) / 2
109               x123 = (x12 + x23) / 2
110               y123 = (y12 + y23) / 2
111               x0123 = (x012 + x123) / 2
112               y0123 = (y012 + y123) / 2
113   
114               stack.append([x0123, y0123, x123, y123, x23, y23, x3, y3])
115               stack.append([x0, y0, x01, y01, x012, y012, x0123, y0123])
116   
117       answer.append([x3, y3])
118   
119       return answer
120   
##### scr\modules\functions\main\files\code.py #####
1     from PyQt5.QtWidgets import QLabel, QMenu, QAction, QVBoxLayout, QTreeWidget, QTreeWidgetItem, QTextEdit, QDialog, QToolTip, QLineEdit, QPushButton, QComboBox
2     from PyQt5.QtGui import QPainter, QColor, QPen, QPixmap, QImage, QPolygon, QTextCursor
3     from PyQt5.Qt import Qt, QPoint, QTimer, QSize
4     
5     from PyQt5.Qsci import QsciScintilla, QsciLexerPython
6     
7     from scr.modules.dialogs import CreateNode
8     from scr.modules.functions.algorithm import bezierCurveDeep, bezierCurveWidth
9     
10     from scr.modules.widgets import FocusLineEdit, FocusComboBox
11    
12    from engine.vector.float import Vec2f
13    from engine.vector.int import Vec2i, Vec4i
14    
15    from scr.variables import *
16    
17    import dataclasses
18    import pyperclip
19    import typing
20    import random
21    import math
22    import copy
23    
24    
25    def isCurrectNode(obj: dict):
26        def func(obj, path):
27            if len(path) == 0:
28                return obj, []
29    
30            var = obj[path[0]]
31            path.pop(0)
32    
33            return var, path
34    
35        for element in NODE_CURRECT_TEST:
36            try:
37                func(obj, element.split("/"))
38    
39            except BaseException:
40                return False
41    
42        return True
43    
44    
45    @dataclasses.dataclass
46    class CodeHash:
47        size: int = 1
48    
49        lastToolTipPos: Vec2i = None
50        lastToolTipPoses: typing.List[Vec2i] = None
51    
52        x: int = 0
53        y: int = 0
54    
55    
56    @dataclasses.dataclass
57    class CodeReplacer:
58        node: int = None
59    
60    
61    @dataclasses.dataclass
62    class CodeLiner:
63        points: dict = None
64        cash: dict = None
65    
66        node: dict = None
67    
68        start: Vec2i = None
69    
70    
71    class TypeSet:
72        @staticmethod
73        def set_(type: str, text: str):
74            return getattr(TypeSet, type)(text)
75    
76        @staticmethod
77        def choose(value: typing.Any):
78            return float(value) if math.trunc(float(value)) != math.ceil(float(value)) else int(float(value))
79    
80        @staticmethod
81        def path(value: typing.Any):
82            return value
83    
84        @staticmethod
85        def number(value: typing.Any):
86            return float(value) if math.trunc(float(value)) != math.ceil(float(value)) else int(float(value))
87    
88        @staticmethod
89        def text(value: typing.Any):
90            return str(value)
91    
92        @staticmethod
93        def logic(value: typing.Any):
94            return True if value in ("true", "True", "1") else False
95    
96        @staticmethod
97        def list(value: typing.Any) -> bool:
98            return eval(value)
99    
100        @staticmethod
101       def dict(value: typing.Any) -> bool:
102           return eval(value)
103   
104       @staticmethod
105       def Any(value: typing.Any):
106           return value
107   
108   
109   class TypeCurrect:
110       @staticmethod
111       def currect_(type: str, text: str) -> bool:
112           return getattr(TypeCurrect, type)(text)
113   
114       @staticmethod
115       def choose(value: typing.Any) -> bool:
116           return True
117   
118       @staticmethod
119       def path(value: typing.Any) -> bool:
120           return True
121   
122       @staticmethod
123       def number(value: typing.Any) -> bool:
124           try:
125               float(value)
126   
127           except BaseException:
128               return False
129   
130           else:
131               return True
132   
133       @staticmethod
134       def text(value: typing.Any) -> bool:
135           return True
136   
137       @staticmethod
138       def logic(value: typing.Any) -> bool:
139           return value in ("true", "True", "false", "False", "0", "1")
140   
141       @staticmethod
142       def list(value: typing.Any) -> bool:
143           try:
144               return type(eval(value)) == list
145   
146           except BaseException:
147               return False
148   
149       @staticmethod
150       def dict(value: typing.Any) -> bool:
151           try:
152               return type(eval(value)) == dict
153   
154           except BaseException:
155               return False
156   
157       @staticmethod
158       def Any(value: typing.Any) -> bool:
159           return True
160   
161   
162   class TextEditor(QDialog):
163       def __init__(self, project, input, id):
164           super().__init__()
165   
166           self.project = project
167           self.input = input
168           self.id = id
169   
170           self.setWindowTitle(translate("Text Editor"))
171   
172           self.setGeometry(0, 0, int(size["width"] * 0.55), int(size["height"] * 0.7))
173           self.move((size["width"] - self.width()) // 2, (size["height"] - self.height()) // 2)
174   
175           self.layout = QVBoxLayout()
176   
177           self.editor = QsciScintilla(self)
178           self.editor.setFont(QFont("Courier", 10))
179   
180           palette = self.project.palette()
181   
182           self.editor.setCaretForegroundColor(palette.text().color())
183           self.editor.setMarginsBackgroundColor(palette.base().color())
184           self.editor.setMarginsForegroundColor(palette.text().color())
185           self.editor.setFoldMarginColors(palette.base().color(), palette.text().color())
186           self.editor.setEdgeColor(palette.text().color())
187           self.editor.setSelectionBackgroundColor(palette.highlight().color())
188           self.editor.setSelectionForegroundColor(palette.highlightedText().color())
189           self.editor.setPaper(palette.base().color())
190           self.editor.setColor(palette.text().color())
191           self.editor.setFont(QFont("Courier", 10))
192   
193           lexer = QsciLexerPython()
194           lexer.setFont(QFont("Courier", 10))
195   
196           lexer.setDefaultPaper(palette.base().color())
197           lexer.setPaper(palette.base().color())
198   
199           self.editor.setMarginWidth(0, "0000")
200           self.editor.setMarginType(0, QsciScintilla.MarginType.NumberMargin)
201   
202           self.editor.setLexer(lexer)
203   
204           self.editor.setText(str(self.input["standard"]))
205   
206           self.editor.setWrapMode(QsciScintilla.WrapWord)
207   
208           self.editor.setTabWidth(4)
209   
210           self.layout.addWidget(self.editor)
211   
212           self.setLayout(self.layout)
213   
214       def closeEvent(self, event):
215           text = self.editor.text()
216   
217           try:
218               type = self.project.objects["main"]["function"]["objects"][str(self.id)]["inputs"][self.input["code"]]["type"]
219   
220           except KeyError:
221               return
222   
223           if TypeCurrect.currect_(type, text):
224               self.project.objects["main"]["function"]["objects"][str(self.id)]["inputs"][self.input["code"]]["standard"] = TypeSet.set_(type, text)
225   
226           with open(self.project.selectFile, "w", encoding="utf-8") as file:
227               dump(self.project.objects["main"]["function"], file, indent=4)
228   
229           self.project.init()
230   
231   
232   class CodeNodeStroke(QLabel):
233       def __init__(self, parent):
234           QLabel.__init__(self, parent)
235   
236           self.setAttribute(Qt.WA_TransparentForMouseEvents)
237   
238           self.setStyleSheet("background-color: rgba(0, 0, 0, 0); border: 2px solid #689ad3; border-radius: 5px")
239   
240   
241   class CodeNodeConnectorLineEdit(QLineEdit):
242       def __init__(self, parent, project, id, input) -> None:
243           QLineEdit.__init__(self, parent)
244   
245           self.project = project
246   
247           self.use = False
248   
249           self.id = id
250           self.input = input
251   
252       def save(self) -> None:
253           text = self.text()
254   
255           type = self.project.objects["main"]["function"]["objects"][str(self.id)]["inputs"][self.input["code"]]["type"]
256   
257           if TypeCurrect.currect_(type, text):
258               self.project.objects["main"]["function"]["objects"][str(self.id)]["inputs"][self.input["code"]]["standard"] = TypeSet.set_(type, text)
259   
260       def focusInEvent(self, event) -> None:
261           self.use = True
262   
263           event.accept()
264   
265       def focusOutEvent(self, event) -> None:
266           self.use = False
267   
268           self.save()
269   
270           event.accept()
271   
272   
273   class CodeNodeConnectorTextBox(QTextEdit):
274       def __init__(self, parent, project, id, input, heigth_) -> None:
275           super().__init__(parent)
276   
277           self.project = project
278           self.use = False
279           self.id = id
280           self.input = input
281   
282           self.heigth_ = heigth_
283   
284           self.setAlignment(Qt.AlignLeft)
285   
286           cursor = self.textCursor()
287           cursor.movePosition(QTextCursor.Start)
288   
289           self.setTabStopDistance(20)
290   
291           self.setTextCursor(cursor)
292   
293           self.button = QPushButton(project.objects["main"]["code"])
294           self.button.setStyleSheet(f"border: 1px solid #cecac9; color: #{'cecac9' if SETTINGS['theme'] == 'dark' else '686b71'};")
295           self.button.setText(translate("Text Editor"))
296           self.button.setFont(MFONT)
297           self.button.show()
298   
299           self.button.clicked.connect(lambda: self.editor())
300   
301           self.setContentsMargins(0, 0, 0, 0)
302   
303       def save(self) -> None:
304           text = self.toPlainText()
305           type = self.project.objects["main"]["function"]["objects"][str(self.id)]["inputs"][self.input["code"]]["type"]
306   
307           if TypeCurrect.currect_(type, text):
308               self.project.objects["main"]["function"]["objects"][str(self.id)]["inputs"][self.input["code"]]["standard"] = TypeSet.set_(type, text)
309   
310       def init(self):
311           self.button.setGeometry(self.x(), self.y() + 25 * (self.heigth_ - 1), self.width(), 16 + 4)
312   
313           self.button.raise_()
314   
315       def editor(self):
316           self.project.dialog = TextEditor(self.project, self.input, self.id)
317           self.project.dialog.exec_()
318   
319       def setGeometry(self, x, y, w, h):
320           super().setGeometry(x, y, w, h)
321   
322           self.button.setGeometry(self.x(), self.y() + 25 * (self.heigth_ - 1), self.width(), 16 + 4)
323   
324       def move(self, x, y):
325           super().move(x, y)
326   
327           self.button.move(self.x(), self.y() + 25 * (self.heigth_ - 1))
328   
329       def deleteLater(self):
330           self.button.deleteLater()
331   
332           super().deleteLater()
333   
334       def show(self) -> None:
335           super().show()
336   
337       def hide(self) -> None:
338           super().hide()
339   
340           self.button.hide()
341   
342       def focusInEvent(self, event) -> None:
343           self.use = True
344   
345           event.accept()
346   
347       def focusOutEvent(self, event) -> None:
348           self.use = False
349   
350           self.save()
351   
352           event.accept()
353   
354       def keyPressEvent(self, event):
355           if event.key() in (Qt.Key_Return, Qt.Key_Enter):
356               self.insertPlainText("\n")
357   
358               event.accept()
359   
360           else:
361               super().keyPressEvent(event)
362   
363   
364   class CodeNodeConnectorComboBox(QComboBox):
365       def __init__(self, parent, project, id, input) -> None:
366           QComboBox.__init__(self, parent)
367   
368           self.project = project
369   
370           self.id = id
371           self.input = input
372   
373           self.use = False
374   
375           self.index = self.input["standard"]
376   
377           self.addItems(self.input["choose"]["options"])
378           self.setCurrentIndex(self.input["standard"])
379   
380           self.currentIndexChanged.connect(self.indexChange)
381   
382       def save(self, full: bool = False) -> None:
383           self.project.objects["main"]["function"]["objects"][str(self.id)]["inputs"][self.input["code"]]["standard"] = self.index
384   
385           if full:
386               with open(self.project.selectFile, "w", encoding="utf-8") as file:
387                   dump(self.project.objects["main"]["function"], file, indent=4)
388   
389       def indexChange(self, index) -> None:
390           self.index = index
391   
392           self.save(True)
393   
394   
395   class CodeNodeConnector(QLabel):
396       def __init__(self, parent, project, node: dict, id: int, keys: dict, number: int, input: dict = None, output: dict = None) -> None:
397           QLabel.__init__(self, parent)
398   
399           self.project = project
400   
401           self.setGeometry(0, (number + 1) * CODE_GRID_CELL_SIZE, parent.width(), CODE_GRID_CELL_SIZE)
402           self.setAttribute(Qt.WA_TranslucentBackground)
403   
404           self.number = number
405           self.id = id
406   
407           self.keys = keys
408   
409           self.node = node
410   
411           self.left = None
412           self.right = None
413   
414           self.input = input
415   
416           self.inputLeftText = None
417           self.inputLeftRama = None
418   
419           invisibleInput = False
420           invisible = False
421           type = None
422   
423           if "special" in self.node:
424               if input["code"] in self.node["special"]["inputs"]:
425                   special = self.node["special"]["inputs"][input["code"]]
426   
427                   if "invisible-input" in special:
428                       invisibleInput = special["invisible-input"]
429   
430                   if "invisible" in special:
431                       invisible = special["invisible"]
432   
433                   if "type" in special:
434                       type = special["type"]
435   
436           if input is not None:
437               self.left = QLabel(self)
438               self.left.setGeometry(0, 9, 10, 10)
439               self.left.setAttribute(Qt.WA_TranslucentBackground)
440   
441               if not invisibleInput:
442                   if input["value"] is not None:
443                       self.left.setPixmap(QPixmap(project.objects["main"]["config"]["connectors"]["sprites"][project.objects["main"]["function"]["objects"][str(input["value"]["id"])]["outputs"][input["value"]["name"]]["type"]]))
444   
445                   else:
446                       self.left.setPixmap(QPixmap(project.objects["main"]["config"]["connectors"]["sprites"][input["type"]]))
447   
448               if self.node["type"] == "event" and self.input["type"] == "path":
449                   self.left.hide()
450   
451               else:
452                   self.left.show()
453   
454               if input["type"] not in CODE_CONNECTOR_NO_HAVE_INPUT_TYPES and not invisible:
455                   if type is not None:
456                       if type == "text-box":
457                           height = self.node["special"]["inputs"][input["code"]]["height"]
458   
459                           self.inputLeftText = CodeNodeConnectorTextBox(project.objects["main"]["code"], self.project, id, input, height)
460                           self.inputLeftText.setAttribute(Qt.WA_TranslucentBackground)
461                           self.inputLeftText.setGeometry(self.x() + parent.x() + 20, self.y() + parent.y() + 4, self.width() - 40, 14 + 25 * (height - 2))
462                           self.inputLeftText.setStyleSheet("background-color: rgba(63, 64, 66, 0); border: 0px")
463                           self.inputLeftText.setPlainText(str(input["standard"]))
464                           self.inputLeftText.setFont(MFONT)
465                           self.inputLeftText.show()
466   
467                           self.inputLeftText.init()
468   
469                       self.inputLeftRama = QLabel(project.objects["main"]["code"])
470                       self.inputLeftRama.setAttribute(Qt.WA_TransparentForMouseEvents)
471                       self.inputLeftRama.setGeometry(self.x() + parent.x() + 20, self.y() + parent.y() + 6, self.width() - 40, 18 + 25 * (height - 2))
472                       self.inputLeftRama.setStyleSheet("border: 1px solid #cecac9;")
473                       self.inputLeftRama.show()
474   
475                   else:
476                       if input["type"] == "choose":
477                           self.inputLeftText = CodeNodeConnectorComboBox(project.objects["main"]["code"], self.project, id, input)
478                           self.inputLeftText.setAttribute(Qt.WA_TranslucentBackground)
479                           self.inputLeftText.setGeometry(self.x() + parent.x() + 20, self.y() + parent.y() + 3, self.width() - 40, 14)
480                           self.inputLeftText.setStyleSheet("background-color: rgba(63, 64, 66, 0); border: 0px")
481                           self.inputLeftText.setFont(MFONT)
482                           self.inputLeftText.show()
483   
484                       else:
485                           self.inputLeftText = CodeNodeConnectorLineEdit(project.objects["main"]["code"], self.project, id, input)
486                           self.inputLeftText.setAttribute(Qt.WA_TranslucentBackground)
487                           self.inputLeftText.setGeometry(self.x() + parent.x() + 20, self.y() + parent.y() + 4, self.width() - 40, 14)
488                           self.inputLeftText.setStyleSheet("background-color: rgba(63, 64, 66, 0); border: 0px")
489                           self.inputLeftText.setText(str(input["standard"]))
490                           self.inputLeftText.setFont(MFONT)
491                           self.inputLeftText.show()
492   
493                       self.inputLeftRama = QLabel(project.objects["main"]["code"])
494                       self.inputLeftRama.setAttribute(Qt.WA_TransparentForMouseEvents)
495                       self.inputLeftRama.setGeometry(self.x() + parent.x() + 20, self.y() + parent.y() + 6, self.width() - 40, 18)
496                       self.inputLeftRama.setStyleSheet("border: 1px solid #cecac9;")
497                       self.inputLeftRama.show()
498   
499               self.leftText = translate(node["display"]["text"][input["name"]])
500   
501               self.project.objects["main"]["liner"].points["inputs"].append([{"id": id, "number": number, "keys": self.keys, "node": self.node}, Vec2i(parent.x() + self.x() + 5, parent.y() + self.y() + self.height() // 2)])
502   
503           if output is not None:
504               self.right = QLabel(self)
505               self.right.setGeometry(self.width() - 12, 9, 10, 10)
506               self.right.setAttribute(Qt.WA_TranslucentBackground)
507               self.right.setPixmap(QPixmap(project.objects["main"]["config"]["connectors"]["sprites"][output["type"]]))
508               self.right.show()
509   
510               self.rightText = translate(node["display"]["text"][output["name"]])
511   
512               self.project.objects["main"]["liner"].points["outputs"].append([{"id": id, "number": number, "keys": self.keys, "connector": output["type"]}, Vec2i(parent.x() + self.x() + self.width() - 5, parent.y() + self.y() + self.height() // 2)])
513   
514           self.show()
515   
516       def updateObjectGeometry(self) -> None:
517           self.move(0, (self.number + 1) * CODE_GRID_CELL_SIZE)
518   
519           if self.left is not None:
520               self.project.objects["main"]["liner"].points["inputs"].append([{"id": self.id, "number": self.number, "keys": self.keys, "node": self.node}, Vec2i(self.parent().x() + self.x() + 5, self.parent().y() + self.y() + self.height() // 2)])
521   
522               self.left.move(0, 9)
523   
524           if self.right is not None:
525               self.project.objects["main"]["liner"].points["outputs"].append([{"id": self.id, "number": self.number, "keys": self.keys}, Vec2i(self.parent().x() + self.x() + 5, self.parent().y() + self.y() + self.height() // 2)])
526   
527               self.right.move(self.width() - 12, 9)
528   
529           if self.inputLeftText is not None:
530               self.inputLeftText.move(self.x() + self.parent().x() + 20, self.y() + self.parent().y() + 4 - (self.input["type"] == "choose"))
531               self.inputLeftRama.move(self.x() + self.parent().x() + 20, self.y() + self.parent().y() + 6)
532   
533   
534   class CodeNode(QTreeWidget):
535       font = None
536   
537       def __init__(self, parent, node: dict) -> None:
538           QTreeWidget.__init__(self, parent.objects["main"]["code"])
539   
540           if self.font is None:
541               self.font = QFont()
542               self.font.setBold(True)
543   
544           self.setHeaderHidden(True)
545           self.show()
546   
547           self.setAttribute(Qt.WA_TransparentForMouseEvents)
548           self.setStyleSheet(f"border-width: 0px; border-radius: 0px; background-color: rgba{'(63, 64, 66, 220)' if SETTINGS['theme'] == 'dark' else '(218, 220, 224, 220)'};")
549   
550           self.project = parent
551   
552           self.node = node
553   
554           self.connectors = {}
555   
556           self.setGeometry(
557               int((self.node["x"] * CODE_GRID_CELL_SIZE - self.project.cash["file"][self.project.selectFile].x) * CODE_GRID_CELL_SIZE // CODE_GRID_CELL_SIZE),
558               int((self.node["y"] * CODE_GRID_CELL_SIZE - self.project.cash["file"][self.project.selectFile].y - self.node["height"] - 1) * CODE_GRID_CELL_SIZE // CODE_GRID_CELL_SIZE + (self.node["height"] - 2)),
559               int(self.node["width"] * CODE_GRID_CELL_SIZE + 3),
560               int(self.node["height"] * CODE_GRID_CELL_SIZE + 3)
561           )
562   
563           self.bg = QLabel(self)
564           self.bg.setGeometry(2, 2, node["width"] * (CODE_GRID_CELL_SIZE + 1) - 6, CODE_GRID_CELL_SIZE - 1)
565           self.bg.setStyleSheet(f"border-width: 0px; background-color: {self.project.objects['main']['config']['colors'][self.node['type']]['first']};")
566           self.bg.show()
567   
568           qpixmap = QPixmap(self.bg.width(), self.bg.height())
569           qpixmap.fill(QColor(self.project.objects["main"]["config"]["colors"][self.node["type"]]["first"]))
570   
571           painter = QPainter(qpixmap)
572           painter.setPen(QPen(QColor(self.project.objects["main"]["config"]["colors"][self.node["type"]]["second"]), 1))
573   
574           """
575           def get_max_font_width(width, text):
576               if not text or width <= 0:
577                   return 0
578   
579               font = QFont()
580               max_size = 0
581               
582               low = 1
583               high = 1000
584   
585               while low <= high:
586                   mid = (low + high) // 2
587                   
588                   font.setPointSize(mid)
589                   metrics = QFontMetrics(font)
590                   
591                   text_width = metrics.horizontalAdvance(text)
592   
593                   if text_width <= width:
594                       max_size = mid
595                       low = mid + 1
596                       
597                   else:
598                       high = mid - 1
599   
600               return max_size
601   
602           """
603   
604           self.font.setPointSize(8) # динамический размер
605   
606           painter.setFont(self.font)
607   
608           painter.drawImage(2, 2, QImage(self.project.objects["main"]["config"]["icons"][self.node["type"]]))
609   
610           painter.drawText(
611               24, self.bg.height() - 8, translate(f"{self.node['display']['name']}")
612           )
613   
614           painter.end()
615   
616           # CONNECTORS
617   
618           if "sorting" in self.node and "outputs" in self.node["sorting"]:
619               self.node["outputs"] = dict(sorted(self.node["outputs"].items(), key=lambda x: self.node["sorting"]["outputs"].index(x[1]["code"])))
620   
621           else:
622               self.node["outputs"] = dict(sorted(self.node["outputs"].items(), key=lambda x: self.project.objects["main"]["config"]["sorting"].index(x[1]["type"])))
623   
624           if "sorting" in self.node and "inputs" in self.node["sorting"]:
625               self.node["inputs"] = dict(sorted(self.node["inputs"].items(), key=lambda x: self.node["sorting"]["inputs"].index(x[1]["code"])))
626   
627           else:
628               self.node["inputs"] = dict(sorted(self.node["inputs"].items(), key=lambda x: self.project.objects["main"]["config"]["sorting"].index(x[1]["type"])))
629   
630           values = [[] for _ in range(max(len(self.node["inputs"]), len(self.node["outputs"])))]
631           keys = [{} for _ in range(max(len(self.node["inputs"]), len(self.node["outputs"])))]
632   
633           usingOtputsPointPossesKeys = []
634   
635           for i, key in enumerate(self.node["inputs"]):
636               values[i].append(self.node["inputs"][key])
637               keys[i]["input"] = key
638   
639               if self.node["inputs"][key]["value"] is not None:
640                   finish = self.project.objects["main"]["function"]["objects"][str(self.node["inputs"][key]["value"]["id"])]
641   
642                   indexStart = list(self.node["inputs"].keys()).index(key) + 1
643                   indexFinish = list(finish["outputs"].keys()).index(self.node["inputs"][key]["value"]["name"]) + 1
644   
645                   usingOtputsPointPossesKeys.append(self.node["id"])
646   
647                   if self.node["id"] not in self.project.objects["main"]["liner"].cash["outputsPointPosses"]:
648                       self.project.objects["main"]["liner"].cash["outputsPointPosses"][self.node["id"]] = []
649   
650                   self.project.objects["main"]["liner"].cash["outputsPointPosses"][self.node["id"]].append({
651                       "start": self.node,
652                       "finish": finish,
653   
654                       "keys": keys,
655                       "key": key,
656   
657                       "connector": self.node["inputs"][key]["type"],
658   
659                       "pos": {
660                           "start": None,
661                           "finish": None
662                       }
663                   })
664   
665                   self.project.objects["main"]["liner"].cash["outputsPointPosses"][self.node["id"]][-1]["pos"]["start"] = Vec2i(
666                       self.project.objects["main"]["liner"].cash["outputsPointPosses"][self.node["id"]][-1]["start"]["x"] * CODE_GRID_CELL_SIZE + 5 - self.project.cash["file"][self.project.selectFile].x,
667                       (self.project.objects["main"]["liner"].cash["outputsPointPosses"][self.node["id"]][-1]["start"]["y"] + indexStart) * CODE_GRID_CELL_SIZE + CODE_GRID_CELL_SIZE // 2 - self.project.cash["file"][self.project.selectFile].y - 3
668                   )
669   
670                   self.project.objects["main"]["liner"].cash["outputsPointPosses"][self.node["id"]][-1]["pos"]["finish"] = Vec2i(
671                       (self.project.objects["main"]["liner"].cash["outputsPointPosses"][self.node["id"]][-1]["finish"]["x"] + self.project.objects["main"]["liner"].cash["outputsPointPosses"][self.node["id"]][-1]["finish"]["width"]) * CODE_GRID_CELL_SIZE - 5 - self.project.cash["file"][self.project.selectFile].x,
672                       (self.project.objects["main"]["liner"].cash["outputsPointPosses"][self.node["id"]][-1]["finish"]["y"] + indexFinish) * CODE_GRID_CELL_SIZE + CODE_GRID_CELL_SIZE // 2 - self.project.cash["file"][self.project.selectFile].y - 3
673                   )
674   
675           for i in range(max(len(self.node["inputs"]), len(self.node["outputs"]))):
676               if len(values[i]) == 0:
677                   values[i].append(None)
678   
679           for i, key in enumerate(self.node["outputs"]):
680               values[i].append(self.node["outputs"][key])
681               keys[i]["output"] = key
682   
683           for i in range(max(len(self.node["inputs"]), len(self.node["outputs"]))):
684               if len(values[i]) == 1:
685                   values[i].append(None)
686   
687           for i, connector in enumerate(values):
688               self.connectors[i] = CodeNodeConnector(self, self.project, self.node, self.node["id"], keys, i, *connector)
689   
690           # PIXMAP
691   
692           self.bg.setPixmap(qpixmap)
693   
694       def updateObjectGeometry(self) -> None:
695           self.move(
696               int((self.node["x"] * CODE_GRID_CELL_SIZE - self.project.cash["file"][self.project.selectFile].x) * CODE_GRID_CELL_SIZE // CODE_GRID_CELL_SIZE),
697               int((self.node["y"] * CODE_GRID_CELL_SIZE - self.project.cash["file"][self.project.selectFile].y - self.node["height"] - 1) * CODE_GRID_CELL_SIZE // CODE_GRID_CELL_SIZE + (self.node["height"] - 2))
698           )
699   
700           for key, connector in self.connectors.items():
701               connector.updateObjectGeometry()
702   
703   
704   class CodeLabel(QLabel):
705       def __init__(self, parent=None, pressFunction: typing.Callable = None, releasedFunction: typing.Callable = None) -> None:
706           QLabel.__init__(self, parent)
707   
708           self.pressFunction = pressFunction
709           self.releasedFunction = releasedFunction
710   
711           self.project = parent
712   
713           self.nowPoint = QPoint()
714           self.point = QPoint()
715   
716           self.position = None
717   
718           self.setMouseTracking(True)
719   
720           self.project.objects["main"]["code_timer"] = QTimer(self)
721           self.project.objects["main"]["code_timer"].timeout.connect(lambda: self.timerToolTip())
722           self.project.objects["main"]["code_timer"].start(1000 // 2)
723   
724           self.project.objects["main"]["code_timer_second"] = QTimer(self)
725           self.project.objects["main"]["code_timer_second"].timeout.connect(lambda: self.timerMoveScene())
726           self.project.objects["main"]["code_timer_second"].start(1000 // 40)
727   
728           self.stop = False
729   
730       def timerToolTip(self):
731           x = self.nowPoint.x()
732           y = self.nowPoint.y()
733   
734           try:
735               self.project.cash["file"][self.project.selectFile].lastToolTipPoses.append(Vec2i(x, y))
736   
737           except KeyError:
738               return
739   
740           if len(self.project.cash["file"][self.project.selectFile].lastToolTipPoses) > 2:
741               self.project.cash["file"][self.project.selectFile].lastToolTipPoses.pop(0)
742   
743           self.project.objects["main"]["code"].viewToolTip()
744   
745       def timerMoveScene(self):
746           # MOVE SCENE IF SELECT COLLECTOR
747   
748           if self.project.objects["main"]["liner"].start is not None:
749               if self.point.x() < 20:
750                   self.project.cash["file"][self.project.selectFile].x -= 8
751                   self.project.objects["main"]["liner"].start.x += 8
752   
753                   Code.update(self.project, call="move")
754   
755               if self.point.x() > self.project.objects["main"]["code"].width() - 20:
756                   self.project.cash["file"][self.project.selectFile].x += 8
757                   self.project.objects["main"]["liner"].start.x -= 8
758   
759                   Code.update(self.project, call="move")
760   
761               if self.point.y() < 20:
762                   self.project.cash["file"][self.project.selectFile].y -= 8
763                   self.project.objects["main"]["liner"].start.y += 8
764   
765                   Code.update(self.project, call="move")
766   
767               if self.point.y() > self.project.objects["main"]["code"].height() - 20:
768                   self.project.cash["file"][self.project.selectFile].y += 8
769                   self.project.objects["main"]["liner"].start.y -= 8
770   
771                   Code.update(self.project, call="move")
772   
773       def mousePressEvent(self, event) -> None:
774           # Code.update(self.project)
775   
776           flag = False
777   
778           for id, node in self.project.objects["main"]["function"]["objects"].items():
779               for index, connector in self.project.objects["main"]["nodes"][node["id"]].connectors.items():
780                   if connector.inputLeftText is not None:
781                       connector.inputLeftText.save()
782   
783                       flag = max(flag, connector.inputLeftText.use)
784   
785           if flag:
786               dump(self.project.objects["main"]["function"], open(self.project.selectFile, "w", encoding="utf-8"), indent=4)
787   
788           self.setFocus()
789   
790           x = event.pos().x()
791           y = event.pos().y()
792   
793           self.project.objects["main"]["liner"].start = None
794           self.project.objects["main"]["liner"].node = None
795   
796           find = None
797   
798           if event.button() != Qt.MidButton:
799               for element in self.project.objects["main"]["liner"].points["outputs"]:
800                   if abs(element[1].x - event.pos().x()) < CODE_POINT_PRECISION and abs(element[1].y - event.pos().y()) < CODE_POINT_PRECISION:
801                       find = element
802   
803                       find[0]["connector"] = element[0]["connector"]
804   
805                       break
806   
807               else:
808                   for elem in self.project.objects["main"]["liner"].cash["outputsPointPosses"].values():
809                       for element in elem:
810                           if abs(element["pos"]["start"].x - event.pos().x()) < CODE_POINT_PRECISION and abs(element["pos"]["start"].y - event.pos().y()) < CODE_POINT_PRECISION:
811                               var = element["start"]["inputs"][element["key"]]["value"]
812   
813                               if var is None:
814                                   continue
815   
816                               find = [
817                                   {
818                                       "id": element["finish"]["id"],
819                                       "connector": element["connector"],
820                                       "number": list(element["finish"]["outputs"].keys()).index(var["name"]),
821                                       "keys": [{"output": element} for element in self.project.objects["main"]["function"]["objects"][str(element["finish"]["id"])]["outputs"]]
822                                   },
823                                   element["pos"]["finish"]
824                               ]
825   
826                               self.project.objects["main"]["liner"].start = Vec2i(find[1].x, find[1].y)
827                               self.project.objects["main"]["liner"].node = find
828   
829                               self.project.objects["main"]["function"]["objects"][str(element["start"]["id"])]["inputs"][element["key"]]["value"] = None
830   
831                               with open(self.project.selectFile, "w", encoding="utf-8") as file:
832                                   dump(self.project.objects["main"]["function"], file, indent=4)
833   
834                               # self.stop = True
835   
836                               return
837   
838                       else:
839                           continue
840   
841                       break
842   
843               if find is not None:
844                   self.project.objects["main"]["liner"].start = Vec2i(find[1].x, find[1].y)
845                   self.project.objects["main"]["liner"].node = find
846   
847               else:
848                   self.project.objects["main"]["liner"].start = None
849   
850           if event.button() == Qt.LeftButton:
851               self.point = event.pos()
852   
853           else:
854               self.project.objects["main"]["liner"].start = None
855   
856           find = None
857           pos = None
858   
859           if event.buttons() == Qt.MidButton and self.project.objects["main"]["replacer"].node is None:
860               for id, node in self.project.objects["main"]["function"]["objects"].items():
861                   if node["x"] * CODE_GRID_CELL_SIZE < x + self.project.cash["file"][self.project.selectFile].x < (node["x"] + node["width"]) * CODE_GRID_CELL_SIZE and node["y"] * CODE_GRID_CELL_SIZE < y + self.project.cash["file"][self.project.selectFile].y < (node["y"] + node["height"]) * CODE_GRID_CELL_SIZE:
862                       find = {"id": id, "node": node}
863   
864                       break
865   
866               if find is not None:
867                   self.project.objects["main"]["replacer"].node = find["id"]
868   
869                   Code.selected(self.project)
870   
871           elif event.buttons() == Qt.MidButton and self.project.objects["main"]["replacer"].node is not None and (self.nowPoint.x() != 0 and self.nowPoint.y() != 0):
872               self.project.objects["main"]["function"]["objects"][str(self.project.objects["main"]["replacer"].node)]["x"] = (self.nowPoint.x() + self.project.cash["file"][self.project.selectFile].x) // CODE_GRID_CELL_SIZE
873               self.project.objects["main"]["function"]["objects"][str(self.project.objects["main"]["replacer"].node)]["y"] = (self.nowPoint.y() + self.project.cash["file"][self.project.selectFile].y) // CODE_GRID_CELL_SIZE
874   
875               with open(self.project.selectFile, "w", encoding="utf-8") as file:
876                   dump(self.project.objects["main"]["function"], file, indent=4)
877   
878               self.project.objects["main"]["replacer"].node = None
879   
880               self.project.init()
881   
882       def mouseReleaseEvent(self, event) -> None:
883           # Code.update(self.project)
884   
885           self.stop = False
886   
887           for element in self.project.objects["main"]["liner"].points["inputs"]:
888               if abs(element[1].x - event.pos().x()) < CODE_POINT_PRECISION and abs(element[1].y - event.pos().y()) < CODE_POINT_PRECISION:
889                   finish = element
890                   break
891   
892           else:
893               finish = None
894   
895           if finish is not None and self.project.objects["main"]["liner"].start is not None:
896               start = self.project.objects["main"]["liner"].node
897   
898               if abs(self.project.objects["main"]["liner"].start.x - event.pos().x()) < CODE_POINT_PRECISION and abs(self.project.objects["main"]["liner"].start.y - event.pos().y()) < CODE_POINT_PRECISION:
899                   pass
900   
901               elif start is not None:
902                   if self.project.objects["main"]["function"]["objects"][str(finish[0]["id"])]["inputs"][finish[0]["keys"][finish[0]["number"]]["input"]]["type"] in [self.project.objects["main"]["function"]["objects"][str(start[0]["id"])]["outputs"][start[0]["keys"][start[0]["number"]]["output"]]["type"]] + self.project.objects["main"]["config"]["infelicity"][self.project.objects["main"]["function"]["objects"][str(start[0]["id"])]["outputs"][start[0]["keys"][start[0]["number"]]["output"]]["type"]]:
903                       if start[0]["id"] != finish[0]["id"] and finish[0]["node"]["type"] != "event":
904                           path = self.project.objects["main"]["function"]["objects"][str(finish[0]["id"])]["inputs"][finish[0]["keys"][finish[0]["number"]]["input"]]["code"]
905   
906                           self.project.objects["main"]["function"]["objects"][str(finish[0]["id"])]["inputs"][path]["value"] = {
907                               "id": start[0]["id"],
908                               "name": start[0]["keys"][start[0]["number"]]["output"]
909                           }
910   
911                           with open(self.project.selectFile, "w", encoding="utf-8") as file:
912                               dump(self.project.objects["main"]["function"], file, indent=4)
913   
914               else:
915                   pass
916   
917           self.project.objects["main"]["liner"].start = None
918           self.project.objects["main"]["liner"].node = None
919   
920           if event.button() == Qt.LeftButton:
921               if self.releasedFunction is not None:
922                   self.releasedFunction(event.pos().x() - self.project.objects["main"]["code"].width() // 2, event.pos().y() - self.project.objects["main"]["code"].height() // 2)
923   
924       def mouseMoveEvent(self, event) -> None:
925           # MOVE SCENE
926   
927           self.nowPoint = event.pos()
928   
929           if event.buttons() == Qt.LeftButton:
930               x = event.pos().x() - self.point.x()
931               y = event.pos().y() - self.point.y()
932   
933               self.point = event.pos()
934   
935               if self.project.objects["main"]["liner"].start is None:
936                   self.project.cash["file"][self.project.selectFile].x -= x
937                   self.project.cash["file"][self.project.selectFile].y -= y
938   
939               Code.update(self.project, call="move")
940   
941           Code.selected(self.project)
942   
943       def viewToolTip(self):
944           pos = self.nowPoint
945   
946           find = None
947   
948           for id, node in self.project.objects["main"]["nodes"].items():
949               if find:
950                   break
951   
952               for key, connector in node.connectors.items():
953                   if connector.left is not None:
954                       x = node.x() + connector.x() + connector.left.x() + connector.left.width() // 2
955                       y = node.y() + connector.y() + connector.left.y() + connector.left.height() // 2
956   
957                       if abs(pos.x() - x) < CODE_POINT_PRECISION // 2 and abs(pos.y() - y) < CODE_POINT_PRECISION // 2:
958                           find = {"pos": Vec2i(x, y), "text": connector.leftText}
959   
960                           break
961   
962                   if connector.right is not None:
963                       x = node.x() + connector.x() + connector.right.x() + connector.right.width() // 2
964                       y = node.y() + connector.y() + connector.right.y() + connector.right.height() // 2
965   
966                       if abs(pos.x() - x) < CODE_POINT_PRECISION // 2 and abs(pos.y() - y) < CODE_POINT_PRECISION // 2:
967                           find = {"pos": Vec2i(x, y), "text": connector.rightText}
968   
969                           break
970   
971           if find is not None and (self.project.cash["file"][self.project.selectFile].lastToolTipPos is None or self.project.cash["file"][self.project.selectFile].lastToolTipPos != find["pos"]):
972               for pos in self.project.cash["file"][self.project.selectFile].lastToolTipPoses:
973                   if not (abs(pos.x - find["pos"].x) < CODE_POINT_PRECISION and abs(pos.y - find["pos"].y) < CODE_POINT_PRECISION):
974                       break
975   
976               else:
977                   QToolTip.showText(QPoint(find["pos"].x + self.x() + self.project.x(), find["pos"].y + self.y() + self.project.y() - 8), translate(f"{find['text']}"))
978   
979           else:
980               QToolTip.hideText()
981   
982   
983   class CodeAdditionsVarsType(QTreeWidget):
984       def __init__(self, parent, pos: Vec4i, name: str, path: str) -> None:
985           QTreeWidget.__init__(self, parent)
986   
987           self.style = f"background-color: rgba(0, 0, 0, 0); border: 1px solid #{'3f4042' if SETTINGS['theme'] == 'dark' else 'dadce0'}"
988   
989           with open("scr/code/config.json", "r", encoding="utf-8") as file:
990               self.config = load(file)
991   
992           self.project = parent
993   
994           self.pos = pos
995   
996           self.path = path
997   
998           self.setGeometry(self.pos.x, self.pos.y, self.pos.z, self.pos.w)
999   
1000           self.setContextMenuPolicy(Qt.CustomContextMenu)
1001  
1002          self.setColumnCount(3)
1003  
1004          self.setColumnWidth(0, self.width() // 3 - 2)
1005          self.setColumnWidth(1, self.width() // 3 - 2)
1006          self.setColumnWidth(2, self.width() // 3 - 2)
1007  
1008          self.header().setMaximumHeight(25)
1009  
1010          self.setHeaderLabels([translate("Name"), translate("Type"), translate("Value")])
1011  
1012          self.plusButton = QPushButton(self)
1013          self.plusButton.setGeometry(6, self.height() - 30, self.width() - 12, 25)
1014          self.plusButton.setText(name)
1015          self.plusButton.show()
1016  
1017          with open(self.path, "r", encoding="utf-8") as file:
1018              self.variables = load(file)["variables"]
1019  
1020          self.setRootIsDecorated(False)
1021  
1022          self.menu = None
1023  
1024          self.plusButton.clicked.connect(lambda: self.new())
1025  
1026          self.init()
1027  
1028          self.show()
1029  
1030      def eventFilter(self, obj, event):
1031          if event.type() == event.ContextMenu:
1032              self.createMenu(self.mapFromGlobal(event.globalPos()))
1033  
1034              return True
1035  
1036          return super().eventFilter(obj, event)
1037  
1038      def createMenu(self, position) -> None:
1039          x = position.x()
1040          y = position.y()
1041  
1042          ox = x - self.project.objects["center_rama"].x() + self.x()
1043          oy = y - self.project.objects["center_rama"].y() + self.y()
1044  
1045          pos = QPoint(ox, oy)
1046  
1047          index = self.currentIndex().row()
1048  
1049          name = list(self.variables.keys())[index]
1050  
1051          self.menu = QMenu()
1052          # self.menu.setWindowFlags(self.menu.windowFlags() | Qt.Popup)
1053          # self.menu.raise_()
1054  
1055          delete_variable = QAction(translate("Remove"), self.project)
1056          delete_variable.triggered.connect(lambda empty=None, n=name: self.removeVariableFunction(n))
1057  
1058          self.menu.addAction(delete_variable)
1059  
1060          self.menu.popup(self.project.objects["main"]["code"].mapToGlobal(pos))
1061  
1062      def removeVariableFunction(self, name):
1063          with open(self.path, "r", encoding="utf-8") as file:
1064              text = load(file)
1065  
1066          self.variables.pop(name)
1067  
1068          text["variables"] = self.variables
1069  
1070          with open(self.path, "w", encoding="utf-8") as file:
1071              dump(text, file, indent=4)
1072  
1073          self.project.init()
1074  
1075      def init(self) -> None:
1076          for i, name in enumerate(self.variables):
1077              value = self.variables[name]
1078  
1079              item = QTreeWidgetItem()
1080  
1081              item.setSizeHint(0, QSize(0, 25))
1082  
1083              self.addTopLevelItem(item)
1084  
1085              self.project.objects["main"][f"additions_element_name_{name}"] = FocusLineEdit(releasedFocusFunction=lambda empty=None, n=name: self.functionName(n))
1086              self.project.objects["main"][f"additions_element_name_{name}"].setText(value["name"])
1087              self.project.objects["main"][f"additions_element_name_{name}"].setStyleSheet(self.style)
1088  
1089              self.setItemWidget(item, 0, self.project.objects["main"][f"additions_element_name_{name}"])
1090  
1091              self.project.objects["main"][f"additions_element_type_{name}"] = FocusComboBox()
1092              self.project.objects["main"][f"additions_element_type_{name}"].addItems(self.config["variablesTypes"])
1093              self.project.objects["main"][f"additions_element_type_{name}"].setCurrentIndex(self.config["variablesTypes"].index(value["type"]))
1094              self.project.objects["main"][f"additions_element_type_{name}"].currentIndexChanged.connect(lambda empty, n=name: self.functionType(n))
1095              self.project.objects["main"][f"additions_element_type_{name}"].setStyleSheet(self.style)
1096  
1097              self.setItemWidget(item, 1, self.project.objects["main"][f"additions_element_type_{name}"])
1098  
1099              self.project.objects["main"][f"additions_element_value_{name}"] = FocusLineEdit(releasedFocusFunction=lambda empty=None, n=name: self.functionValue(n))
1100              self.project.objects["main"][f"additions_element_value_{name}"].setText(str(value["value"]))
1101              self.project.objects["main"][f"additions_element_value_{name}"].setStyleSheet(self.style)
1102  
1103              self.setItemWidget(item, 2, self.project.objects["main"][f"additions_element_value_{name}"])
1104  
1105      def new(self) -> None:
1106          with open(self.path, "r", encoding="utf-8") as file:
1107              text = load(file)
1108  
1109          name = "undefined"
1110          plus = 0
1111  
1112          while (name if plus == 0 else f"{name} ({plus})") in text["variables"]:
1113              plus += 1
1114  
1115          name = name if plus == 0 else f"{name} ({plus})"
1116  
1117          text["variables"][name] = {
1118              "name": name,
1119              "type": "text",
1120              "value": self.config["standardVariablesTypes"]["text"]
1121          }
1122  
1123          with open(self.path, "w", encoding="utf-8") as file:
1124              dump(text, file, indent=4)
1125  
1126          self.project.init()
1127  
1128      def functionName(self, name: str) -> None:
1129          with open(self.path, "r", encoding="utf-8") as file:
1130              text = load(file)
1131  
1132          try:
1133              name = text["variables"][name]["name"]
1134  
1135          except KeyError:
1136              return 0
1137  
1138          new = self.project.objects["main"][f"additions_element_name_{name}"].text()
1139  
1140          if new == name or len(new) < 1 or new in list(text["variables"].keys()):
1141              self.project.objects["main"][f"additions_element_name_{name}"].setText(name)
1142  
1143              return
1144  
1145          text["variables"][new] = copy.deepcopy(text["variables"][name])
1146          text["variables"][new]["name"] = new
1147  
1148          text["variables"].pop(name)
1149  
1150          with open(self.path, "w", encoding="utf-8") as file:
1151              dump(text, file, indent=4)
1152  
1153          self.project.init()
1154  
1155      def functionType(self, name: str) -> None:
1156          with open(self.path, "r", encoding="utf-8") as file:
1157              text = load(file)
1158  
1159          index = self.project.objects["main"][f"additions_element_type_{name}"].currentIndex()
1160  
1161          new = self.config["variablesTypes"][index]
1162  
1163          text["variables"][name]["type"] = new
1164          text["variables"][name]["value"] = self.config["standardVariablesTypes"][new]
1165  
1166          with open(self.path, "w", encoding="utf-8") as file:
1167              dump(text, file, indent=4)
1168  
1169          self.project.init()
1170  
1171      def functionValue(self, name: str) -> None:
1172          with open(self.path, "r", encoding="utf-8") as file:
1173              text = load(file)
1174  
1175          value = self.project.objects["main"][f"additions_element_value_{name}"].text()
1176  
1177          if TypeCurrect.currect_(text["variables"][name]["type"], value):
1178              text["variables"][name]["value"] = TypeSet.set_(text["variables"][name]["type"], value)
1179  
1180          with open(self.path, "w", encoding="utf-8") as file:
1181              dump(text, file, indent=4)
1182  
1183          self.project.init()
1184  
1185  
1186  class CodeAdditions:
1187      @staticmethod
1188      def init(project) -> None:
1189          project.objects["main"]["variables"] = {}
1190  
1191          project.objects["main"]["variables"]["locals"] = CodeAdditionsVarsType(
1192              project,
1193              Vec4i(
1194                  project.objects["center_rama"].x() + project.objects["center_rama"].width() + 10,
1195                  40,
1196                  project.width() - (project.objects["center_rama"].x() + project.objects["center_rama"].width() + 10) - 10,
1197                  (project.height() - 80) // 2
1198              ),
1199              translate("Create local variable"),
1200              project.selectFile
1201          )
1202  
1203          project.objects["main"]["variables"]["globals"] = CodeAdditionsVarsType(
1204              project,
1205              Vec4i(
1206                  project.objects["center_rama"].x() + project.objects["center_rama"].width() + 10,
1207                  40 + 10 + (project.height() - 80) // 2,
1208                  project.width() - (project.objects["center_rama"].x() + project.objects["center_rama"].width() + 10) - 10,
1209                  (project.height() - 80) // 2
1210              ),
1211              translate("Create global variable"),
1212              f"projects/{project.selectProject}/project/project.cfg"
1213          )
1214  
1215      @staticmethod
1216      def update(project):
1217          CodeAdditions.remove(project)
1218  
1219          CodeAdditions.init(project)
1220  
1221      @staticmethod
1222      def remove(project):
1223          if "variables" in project.objects["main"]:
1224              for element in project.objects["main"]["variables"].values():
1225                  try:
1226                      element.hide()
1227  
1228                      element.deleteLater()
1229  
1230                  except RuntimeError:
1231                      pass
1232  
1233  
1234  class Code:
1235      @staticmethod
1236      def init(project) -> None:
1237          project.objects["main"]["code"] = CodeLabel(
1238              parent=project,
1239              releasedFunction=lambda x, y: Code.update(project)
1240          )
1241  
1242          project.objects["main"]["code"].setGeometry(project.objects["center_rama"].x() + 2, project.objects["center_rama"].y() + 2, project.objects["center_rama"].width() - 4, project.objects["center_rama"].height() - 4)
1243          project.objects["main"]["code"].show()
1244  
1245          project.objects["main"]["code"].setContextMenuPolicy(Qt.CustomContextMenu)
1246  
1247          project.objects["main"]["code"].customContextMenuRequested.connect(
1248              lambda pos: Code.menu(project, pos)
1249          )
1250  
1251          if project.cash["file"][project.selectFile].lastToolTipPoses is None:
1252              project.cash["file"][project.selectFile].lastToolTipPoses = []
1253  
1254          if "replacer" not in project.objects["main"]:
1255              project.objects["main"]["replacer"] = CodeReplacer()
1256  
1257          project.objects["main"]["liner"] = CodeLiner()
1258  
1259          if project.objects["main"]["liner"].points is None:
1260              project.objects["main"]["liner"].points = {"inputs": [], "outputs": []}
1261  
1262          project.objects["main"]["liner"].cash = {"outputsPointPosses": {}}
1263  
1264          if "nodes" not in project.objects["main"]:
1265              project.objects["main"]["nodes"] = {}
1266  
1267          with open("scr/code/config.json", "r", encoding="utf-8") as file:
1268              project.objects["main"]["config"] = load(file)
1269  
1270          CodeAdditions.init(project)
1271  
1272          Code.update(project)
1273  
1274      @staticmethod
1275      def update(project, call: str = "") -> None:
1276          project.objects["main"]["liner"].cash["outputsPointPosses"] = {}
1277  
1278          project.objects["main"]["liner"].points = {"inputs": [], "outputs": []}
1279  
1280          pos = Vec2i(project.cash["file"][project.selectFile].x, project.cash["file"][project.selectFile].y)
1281  
1282          try:
1283              with open(project.selectFile, "r", encoding="utf-8") as file:
1284                  project.objects["main"]["function"] = load(file)
1285  
1286          except json.JSONDecodeError:
1287              return 0
1288  
1289          # GRID
1290  
1291          qpixmap = QPixmap(project.objects["center_rama"].width(), project.objects["center_rama"].height())
1292          qpixmap.fill(QColor(32, 33, 36) if SETTINGS["theme"] == "dark" else QColor(248, 249, 250))
1293  
1294          painter = QPainter(qpixmap)
1295          painter.setPen(QPen(QColor(63, 64, 66)if SETTINGS["theme"] == "dark" else QColor(218, 220, 224), 1))
1296  
1297          painter.setFont(SFONT)
1298  
1299          size = CODE_GRID_CELL_SIZE // project.cash["file"][project.selectFile].size
1300  
1301          for x in range(-size - pos.x % size, project.objects["center_rama"].width() + size, size):
1302              painter.drawLine(x, 0, x, project.objects["center_rama"].height())
1303              painter.drawLine(x + 1, 0, x + 1, project.objects["center_rama"].height())
1304  
1305          for y in range(-size - pos.y % size, project.objects["center_rama"].height() + size, size):
1306              painter.drawLine(0, y, project.objects["center_rama"].width(), y)
1307              painter.drawLine(0, y + 1, project.objects["center_rama"].width(), y + 1)
1308  
1309          # UI
1310  
1311          painter.setPen(QPen(QColor(255, 255, 255), 2))
1312  
1313          painter.setPen(QPen(QColor(255, 255, 255) if SETTINGS["theme"] == "dark" else QColor(70, 70, 70), 1))
1314  
1315          painter.drawText(
1316              5, project.objects["center_rama"].height() - 8, f"X, Y: {pos.x}  {pos.y}"
1317          )
1318  
1319          painter.setPen(QPen(QColor("#cecac9"), 2))
1320  
1321          # NODES
1322  
1323          Code.nodes(project, call != "move")
1324  
1325          # ALL CONNECTORS
1326  
1327          for id, node in project.objects["main"]["function"]["objects"].items():
1328              for i, name in enumerate(node["inputs"]):
1329                  connector = node["inputs"][name]
1330  
1331                  if connector["value"] is not None:
1332                      nd = project.objects["main"]["function"]["objects"][str(connector["value"]["id"])]["outputs"][connector["value"]["name"]]["type"]
1333  
1334                      painter.setPen(QPen(QColor(project.objects["main"]["config"]["connectors"]["colors"][nd]), 2))
1335  
1336                      start = {"node": node, "id": id, "name": name, "index": i + 1}
1337                      finish = {"node": project.objects["main"]["function"]["objects"][str(connector["value"]["id"])], "id": connector["value"]["id"], "name": connector["value"]["name"], "index": list(project.objects["main"]["function"]["objects"][str(connector["value"]["id"])]["outputs"].keys()).index(connector["value"]["name"]) + 1}
1338  
1339                      poses = {
1340                          "start": Vec2i(start["node"]["x"] * CODE_GRID_CELL_SIZE + 5 - project.cash["file"][project.selectFile].x, (start["node"]["y"] + start["index"]) * CODE_GRID_CELL_SIZE + CODE_GRID_CELL_SIZE // 2 - project.cash["file"][project.selectFile].y),
1341                          "finish": Vec2i((finish["node"]["x"] + finish["node"]["width"]) * CODE_GRID_CELL_SIZE - 5 - project.cash["file"][project.selectFile].x, (finish["node"]["y"] + finish["index"]) * CODE_GRID_CELL_SIZE + CODE_GRID_CELL_SIZE // 2 - project.cash["file"][project.selectFile].y)
1342                      }
1343  
1344                      poses = bezierCurveWidth(
1345                          poses["start"].x,
1346                          poses["start"].y + 1,
1347                          (poses["start"].x + poses["finish"].x) // 2,
1348                          poses["start"].y + 1,
1349                          (poses["start"].x + poses["finish"].x) // 2,
1350                          poses["finish"].y + 1,
1351                          poses["finish"].x,
1352                          poses["finish"].y + 1,
1353                          CODE_LINER_PRECISION
1354                      )
1355  
1356                      points = [QPoint(int(pos[0]), int(pos[1])) for pos in poses]
1357  
1358                      painter.drawPolyline(QPolygon(points))
1359  
1360          # CONNECTOR
1361  
1362          if project.objects["main"]["liner"].start is not None:
1363              connector = project.objects["main"]["liner"].node[0]["connector"]
1364  
1365              painter.setPen(QPen(QColor(project.objects["main"]["config"]["connectors"]["colors"][connector]), 2))
1366  
1367              poses = bezierCurveWidth(
1368                  project.objects["main"]["liner"].start.x,
1369                  project.objects["main"]["liner"].start.y + 3,
1370                  (project.objects["main"]["liner"].start.x + project.objects["main"]["code"].point.x()) // 2,
1371                  project.objects["main"]["liner"].start.y + 3,
1372                  (project.objects["main"]["liner"].start.x + project.objects["main"]["code"].point.x()) // 2,
1373                  project.objects["main"]["code"].point.y() + 3,
1374                  project.objects["main"]["code"].point.x(),
1375                  project.objects["main"]["code"].point.y() + 3,
1376                  CODE_LINER_PRECISION
1377              )
1378  
1379              points = [QPoint(math.ceil(pos[0]), math.ceil(pos[1])) for pos in poses]
1380  
1381              painter.drawPolyline(QPolygon(points))
1382  
1383          painter.setPen(QPen(QColor("#cecac9"), 2))
1384  
1385          # SELECTED
1386  
1387          Code.selected(project)
1388  
1389          # PIXMAP
1390  
1391          painter.end()
1392  
1393          project.objects["main"]["code"].setPixmap(qpixmap)
1394  
1395      @staticmethod
1396      def selected(project) -> None:
1397          try:
1398              project.objects["main"]["replacer_select"].deleteLater()
1399  
1400          except AttributeError:
1401              pass
1402  
1403          except RuntimeError:
1404              pass
1405  
1406          except KeyError:
1407              pass
1408  
1409          try:
1410              project.objects["main"]["replacer_pos"].deleteLater()
1411  
1412          except AttributeError:
1413              pass
1414  
1415          except RuntimeError:
1416              pass
1417  
1418          except KeyError:
1419              pass
1420  
1421          if project.objects["main"]["replacer"].node is None:
1422              return 0
1423  
1424          # SELECTED
1425  
1426          nodeObj = project.objects["main"]["nodes"][int(project.objects["main"]["replacer"].node)]
1427          nodeType = project.objects["main"]["function"]["objects"][str(project.objects["main"]["replacer"].node)]
1428  
1429          project.objects["main"]["replacer_select"] = CodeNodeStroke(project.objects["main"]["code"])
1430          project.objects["main"]["replacer_select"].setGeometry(nodeObj.x(), nodeObj.y(), nodeObj.width(), nodeObj.height())
1431          project.objects["main"]["replacer_select"].show()
1432  
1433          # POS
1434  
1435          if project.objects["main"]["code"].nowPoint.x() == 0 and project.objects["main"]["code"].nowPoint.y() == 0:
1436              return 0
1437  
1438          x = (project.objects["main"]["code"].nowPoint.x() + project.cash["file"][project.selectFile].x) // CODE_GRID_CELL_SIZE * CODE_GRID_CELL_SIZE
1439          y = (project.objects["main"]["code"].nowPoint.y() + project.cash["file"][project.selectFile].y) // CODE_GRID_CELL_SIZE * CODE_GRID_CELL_SIZE
1440  
1441          project.objects["main"]["replacer_pos"] = CodeNodeStroke(project.objects["main"]["code"])
1442          project.objects["main"]["replacer_pos"].setGeometry(
1443              (x - project.cash["file"][project.selectFile].x) * CODE_GRID_CELL_SIZE // CODE_GRID_CELL_SIZE,
1444              (y - project.cash["file"][project.selectFile].y - nodeType["height"] - 1) * CODE_GRID_CELL_SIZE // CODE_GRID_CELL_SIZE + (nodeType["height"] - 2),
1445              nodeObj.width(),
1446              nodeObj.height()
1447          )
1448  
1449          project.objects["main"]["replacer_pos"].show()
1450  
1451      @staticmethod
1452      def nodes(project, create: bool = True) -> None:
1453          if create:
1454              for node in project.objects["main"]["nodes"].values():
1455                  for connector in node.connectors.values():
1456                      if connector.inputLeftText is not None:
1457                          try:
1458                              # connector.inputLeftText.save()
1459  
1460                              connector.inputLeftText.deleteLater()
1461                              connector.inputLeftRama.deleteLater()
1462  
1463                          except RuntimeError:
1464                              pass
1465  
1466                  try:
1467                      node.hide()
1468  
1469                  except AttributeError:
1470                      pass
1471  
1472                  except RuntimeError:
1473                      continue
1474  
1475                  try:
1476                      node.deleteLater()
1477  
1478                  except AttributeError:
1479                      pass
1480  
1481              project.objects["main"]["nodes"] = {}
1482  
1483              for id, node in project.objects["main"]["function"]["objects"].items():
1484                  project.objects["main"]["nodes"][node["id"]] = CodeNode(project, node)
1485  
1486          else:
1487              for id, node in project.objects["main"]["function"]["objects"].items():
1488                  project.objects["main"]["nodes"][node["id"]].updateObjectGeometry()
1489  
1490      @staticmethod
1491      def menu(project, position) -> None:
1492          x = position.x()
1493          y = position.y()
1494  
1495          project.objects["main"]["code_menu"] = QMenu()
1496  
1497          project.objects["main"]["code_menu_new_node"] = QAction(translate("Create"), project)
1498          project.objects["main"]["code_menu_new_node"].triggered.connect(lambda: Code.createNode(project, position))
1499  
1500          project.objects["main"]["code_menu_copy_node"] = QAction(translate("Copy"), project)
1501          project.objects["main"]["code_menu_copy_node"].triggered.connect(lambda: Code.copyNode(project, position))
1502  
1503          project.objects["main"]["code_menu_paste_node"] = QAction(translate("Paste"), project)
1504          project.objects["main"]["code_menu_paste_node"].triggered.connect(lambda: Code.pasteNode(project, position))
1505  
1506          project.objects["main"]["code_menu_delete_node"] = QAction(translate("Delete"), project)
1507          project.objects["main"]["code_menu_delete_node"].triggered.connect(lambda: Code.deleteNode(project, position))
1508  
1509          project.objects["main"]["code_menu"].addAction(project.objects["main"]["code_menu_new_node"])
1510          project.objects["main"]["code_menu"].addSeparator()
1511          project.objects["main"]["code_menu"].addAction(project.objects["main"]["code_menu_copy_node"])
1512          project.objects["main"]["code_menu"].addAction(project.objects["main"]["code_menu_paste_node"])
1513          project.objects["main"]["code_menu"].addSeparator()
1514          project.objects["main"]["code_menu"].addAction(project.objects["main"]["code_menu_delete_node"])
1515  
1516          for id, node in project.objects["main"]["function"]["objects"].items():
1517              if node["x"] * CODE_GRID_CELL_SIZE < x + project.cash["file"][project.selectFile].x < (node["x"] + node["width"]) * CODE_GRID_CELL_SIZE and node["y"] * CODE_GRID_CELL_SIZE < y + project.cash["file"][project.selectFile].y < (node["y"] + node["height"]) * CODE_GRID_CELL_SIZE:
1518                  break
1519  
1520          else:
1521              project.objects["main"]["code_menu_copy_node"].setDisabled(True)
1522              project.objects["main"]["code_menu_delete_node"].setDisabled(True)
1523  
1524          project.objects["main"]["code_menu"].popup(project.objects["main"]["code"].mapToGlobal(position))
1525  
1526          project.objects["main"]["liner"].start = None
1527  
1528      @staticmethod
1529      def createNode(project, position) -> None:
1530          project.dialog = CreateNode(project, position, project)
1531          project.dialog.exec_()
1532  
1533      @staticmethod
1534      def copyNode(project, position) -> None:
1535          x = position.x()
1536          y = position.y()
1537  
1538          for id, node in project.objects["main"]["function"]["objects"].items():
1539              if node["x"] * CODE_GRID_CELL_SIZE < x + project.cash["file"][project.selectFile].x < (node["x"] + node["width"]) * CODE_GRID_CELL_SIZE and node["y"] * CODE_GRID_CELL_SIZE < y + project.cash["file"][project.selectFile].y < (node["y"] + node["height"]) * CODE_GRID_CELL_SIZE:
1540                  pyperclip.copy(dumps(node))
1541  
1542                  break
1543  
1544          project.init()
1545  
1546      @staticmethod
1547      def pasteNode(project, position) -> None:
1548          try:
1549              node = loads(pyperclip.paste())
1550  
1551          except BaseException:
1552              MessageBox.error(translate("This text is not node"))
1553  
1554              return 0
1555  
1556          if not isCurrectNode(node):
1557              MessageBox.error(translate("This file is not node"))
1558  
1559              return 0
1560  
1561          node["id"] = random.randint(1, 1000000000)
1562          node["x"] = (position.x() + project.cash["file"][project.selectFile].x) // CODE_GRID_CELL_SIZE
1563          node["y"] = (position.y() + project.cash["file"][project.selectFile].y) // CODE_GRID_CELL_SIZE
1564  
1565          for name, connector in node["inputs"].items():
1566              connector["value"] = None
1567  
1568          project.objects["main"]["function"]["objects"][node["id"]] = node
1569  
1570          with open(project.selectFile, "w", encoding="utf-8") as file:
1571              dump(project.objects["main"]["function"], file, indent=4)
1572  
1573          project.init()
1574  
1575      @staticmethod
1576      def deleteNode(project, position) -> None:
1577          x = position.x()
1578          y = position.y()
1579  
1580          for id, node in project.objects["main"]["function"]["objects"].items():
1581              if node["x"] * CODE_GRID_CELL_SIZE < x + project.cash["file"][project.selectFile].x < (node["x"] + node["width"]) * CODE_GRID_CELL_SIZE and node["y"] * CODE_GRID_CELL_SIZE < y + project.cash["file"][project.selectFile].y < (node["y"] + node["height"]) * CODE_GRID_CELL_SIZE:
1582                  select = node
1583  
1584                  break
1585  
1586          else:
1587              return 0
1588  
1589          for id, node in project.objects["main"]["function"]["objects"].items():
1590              for i, name in enumerate(node["inputs"]):
1591                  connector = node["inputs"][name]
1592  
1593                  if connector["value"] is not None and connector["value"]["id"] == select["id"]:
1594                      project.objects["main"]["function"]["objects"][id]["inputs"][name]["value"] = None
1595  
1596          project.objects["main"]["function"]["objects"].pop(str(select["id"]))
1597  
1598          with open(project.selectFile, "w", encoding="utf-8") as file:
1599              dump(project.objects["main"]["function"], file, indent=4)
1600  
1601          project.init()
1602  
##### scr\modules\functions\main\files\collision.py #####
1     from PyQt5.QtWidgets import QTreeWidget, QPushButton, QHeaderView, QAbstractItemView
2     from PyQt5.Qt import QPixmap, Qt
3     
4     from scr.modules.widgets.collisionTable import CollisionTable
5     from scr.modules.widgets import FocusLineEdit
6     
7     from scr.modules.functions.project import *
8     
9     from scr.variables import *
10     
11    import json
12    
13    
14    class CollisionAdditions:
15        style = f"background-color: rgba(0, 0, 0, 0); border: 1px solid #{'3f4042' if SETTINGS['theme'] == 'dark' else 'dadce0'};"
16    
17        @staticmethod
18        def init(project) -> None:
19            project.objects["main"]["create"] = QTreeWidget(project)
20            project.objects["main"]["create"].header().setMaximumHeight(25)
21            project.objects["main"]["create"].setHeaderLabels([translate("Name"), ""])
22    
23            project.objects["main"]["create"].setGeometry(
24                project.objects["center_rama"].x() + project.objects["center_rama"].width() + 10,
25                40,
26                project.width() - (project.objects["center_rama"].x() + project.objects["center_rama"].width() + 10) - 10,
27                project.height() - 70
28            )
29    
30            project.objects["main"]["create"].setColumnCount(2)
31    
32            header = project.objects["main"]["create"].header()
33            header.setSectionResizeMode(1, QHeaderView.Fixed)
34            header.setMinimumSectionSize(24)
35    
36            # header.setDefaultAlignment(Qt.AlignCenter)
37    
38            project.objects["main"]["create"].setSelectionMode(QAbstractItemView.NoSelection)
39    
40            project.objects["main"]["create"].setColumnWidth(0, project.objects["main"]["create"].width() - 24 - 4)
41            project.objects["main"]["create"].setColumnWidth(1, 24)
42    
43            project.objects["main"]["create"].setRootIsDecorated(False)
44    
45            project.objects["main"]["create"].show()
46    
47            for name in project.objects["main"]["adds"]:
48                item = QTreeWidgetItem()
49    
50                project.objects["main"]["create"].addTopLevelItem(item)
51    
52                project.objects["main"][f"additions_element_name_{name}"] = FocusLineEdit(releasedFocusFunction=lambda empty=None, n=name: CollisionAdditions.rename(project, n))
53                project.objects["main"][f"additions_element_name_{name}"].setText(name)
54                project.objects["main"][f"additions_element_name_{name}"].setStyleSheet(f"background-color: rgba(0, 0, 0, 0); border: 1px solid #{'3f4042' if SETTINGS['theme'] == 'dark' else 'dadce0'}")
55    
56                project.objects["main"]["create"].setItemWidget(item, 0, project.objects["main"][f"additions_element_name_{name}"])
57    
58                project.objects["main"][f"additions_element_remove_{name}"] = QPushButton()
59    
60                if SETTINGS["theme"] == "dark":
61                    project.objects["main"][f"additions_element_remove_{name}"].setIcon(QIcon(QPixmap("scr/files/sprites/remove.png")))
62    
63                else:
64                    project.objects["main"][f"additions_element_remove_{name}"].setIcon(QIcon(QPixmap("scr/files/sprites/remove-light.png")))
65    
66                # project.objects["main"][f"additions_element_remove_{name}"].setIconSize(QSize(16, 16))
67    
68                project.objects["main"][f"additions_element_remove_{name}"].released.connect(lambda empty=None, n=name: CollisionAdditions.remove(project, n))
69                project.objects["main"][f"additions_element_remove_{name}"].setStyleSheet(f"background-color: rgba(0, 0, 0, 0); border: 1px solid #{'3f4042' if SETTINGS['theme'] == 'dark' else 'dadce0'}")
70    
71                project.objects["main"]["create"].setItemWidget(item, 1, project.objects["main"][f"additions_element_remove_{name}"])
72    
73            project.objects["main"]["plus"] = QPushButton(project.objects["main"]["create"])
74            project.objects["main"]["plus"].setGeometry(6, project.objects["main"]["create"].height() - 30, project.objects["main"]["create"].width() - 12, 25)
75            project.objects["main"]["plus"].setText(translate("Create object group"))
76            project.objects["main"]["plus"].show()
77    
78            project.objects["main"]["plus"].clicked.connect(lambda: CollisionAdditions.plus(project))
79    
80        @staticmethod
81        def rename(project, name: str) -> None:
82            if len(project.objects["main"][f"additions_element_name_{name}"].text().split()) > 1:
83                return
84    
85            if project.objects["main"][f"additions_element_name_{name}"].text() in project.objects["main"]["adds"]:
86                return
87    
88            project.objects["main"]["adds"].insert(project.objects["main"]["adds"].index(name), project.objects["main"][f"additions_element_name_{name}"].text())
89    
90            CollisionAdditions.remove(project, name)
91    
92            project.init()
93    
94        @staticmethod
95        def remove(project, name: str) -> None:
96            if name in project.objects["main"]["adds"]:
97                project.objects["main"]["adds"].remove(name)
98    
99            CollisionAdditions.save(project)
100    
101           project.init()
102   
103       @staticmethod
104       def plus(project) -> None:
105           number = 1
106   
107           while str(number) in project.objects["main"]["adds"]:
108               number += 1
109   
110           project.objects["main"]["adds"].append(str(number))
111   
112           CollisionAdditions.save(project)
113   
114           project.init()
115   
116       @staticmethod
117       def save(project) -> None:
118           with open(project.selectFile, "r", encoding="utf-8") as file:
119               config = file.read()
120   
121           config = config.split("\n")
122           config = config[1:]
123   
124           symbol = "\""
125   
126           config = f"$[{', '.join([symbol + element + symbol for element in project.objects['main']['adds']])}]$" + "\n" + "\n".join(config)
127   
128           # print(config)
129   
130           with open(project.selectFile, "w", encoding="utf-8") as file:
131               file.write(config)
132   
133           project.init()
134   
135   
136   class Collision:
137       @staticmethod
138       def init(project) -> None:
139           with open(project.selectFile, "r", encoding="utf-8") as file:
140               text = file.read().split("\n")[0].replace("$", "").replace("$", "")
141   
142           project.objects["main"]["adds"] = eval(text)
143   
144           project.objects["main"]["groups"] = project.objects["main"]["adds"]
145   
146           for path in getAllProjectObjects(project, onlyFileName=False):
147               with open(path, "r", encoding="utf-8") as file:
148                   obj = load(file)
149   
150               if obj["StaticObject"]["group"]["value"] not in project.objects["main"]["groups"]:
151                   project.objects["main"]["groups"].append(obj["StaticObject"]["group"]["value"])
152   
153           project.objects["main"]["table"] = CollisionTable(project, project.objects["main"]["groups"], Collision.function)
154           project.objects["main"]["table"].setGeometry(project.objects["center_rama"].x(), project.objects["center_rama"].y(), project.objects["center_rama"].width(), project.objects["center_rama"].height())
155           project.objects["main"]["table"].show()
156   
157           CollisionAdditions.init(project)
158   
159       @staticmethod
160       def function(project, x: int, y: int, state: bool) -> None:
161           with open(project.selectFile, "r", encoding="utf-8") as file:
162               config = file.read()
163   
164           first = project.objects["main"]["groups"][x]
165           second = project.objects["main"]["groups"][y]
166   
167           if state:
168               if len(config) != 0:
169                   config += f"\n{first} <-> {second} - collision"
170   
171               else:
172                   config += f"{first} <-> {second} - collision"
173   
174           else:
175               config = config.replace(f"\n{first} <-> {second} - collision", "")
176               config = config.replace(f"\n{second} <-> {first} - collision", "")
177   
178               config = config.replace(f"{first} <-> {second} - collision", "")
179               config = config.replace(f"{second} <-> {first} - collision", "")
180   
181           with open(project.selectFile, "w", encoding="utf-8") as file:
182               file.write(config)
183   
184           project.init()
185   
##### scr\modules\functions\main\files\config.py #####
1     from PyQt5.QtWidgets import QLabel, QCheckBox, QPushButton, QDialog, QComboBox, QTreeWidget
2     from PyQt5 import QtWidgets, QtCore
3     
4     from scr.modules.functions.main.files.code import CodeAdditionsVarsType as ConfigAdditionsVarsType
5     
6     from scr.modules.widgets import FocusLineEdit
7     
8     from scr.modules import functions
9     
10     from engine.vector.int import Vec4i
11    
12    from scr.variables import *
13    
14    import json
15    import os
16    import re
17    
18    
19    class ConfigButtonStartSceneFunctions:
20        @staticmethod
21        def create(project, dialog, event) -> None:
22            scenes = functions.project.getAllProjectScenes(project, False)
23    
24            if dialog.objects["choose_combobox"].currentText() == "":
25                project.init()
26    
27                dialog.close()
28    
29                return 0
30    
31            scene = scenes[dialog.objects["choose_combobox"].currentIndex()].replace(f"projects/{project.selectProject}/project/", "")
32    
33            with open(f"projects/{project.selectProject}/project/project.cfg", "r", encoding="utf-8") as file:
34                config = load(file)
35    
36            config["values"]["start_scene"]["value"] = scene
37    
38            with open(f"projects/{project.selectProject}/project/project.cfg", "w", encoding="utf-8") as file:
39                dump(config, file, indent=4)
40    
41            project.init()
42    
43            dialog.close()
44    
45    
46    class ConfigButtonStartScene(QDialog):
47        @staticmethod
48        def start(project, key, value) -> None:
49            project.dialog = ConfigButtonStartScene(project, key, value, parent=project)
50            project.dialog.exec_()
51    
52        def __init__(self, project, key, value, parent=None) -> None:
53            QDialog.__init__(self, parent)
54    
55            self.project = project
56    
57            self.key = key
58            self.value = value
59    
60            self.setWindowTitle(translate("Choose scene"))
61            self.setFixedSize(600, 400)
62    
63            desktop = QtWidgets.QApplication.desktop()
64            self.move((desktop.width() - self.width()) // 2, (desktop.height() - self.height() - PLUS) // 2)
65    
66            self.objects = {}
67    
68            self.init()
69    
70        def init(self) -> None:
71            self.objects["empty"] = QPushButton(parent=self)
72            self.objects["empty"].setGeometry(0, 0, 0, 0)
73    
74            # ALL PROJECTS -> COMBOBOX
75    
76            self.objects["choose_label"] = QLabel(parent=self, text=translate("Scene") + ":")
77            self.objects["choose_label"].setGeometry(10, 10, 200, 25)
78            self.objects["choose_label"].setFont(FONT)
79            self.objects["choose_label"].show()
80    
81            self.objects["choose_combobox"] = QComboBox(parent=self)
82            self.objects["choose_combobox"].setGeometry(210, 10, 300, 25)
83            self.objects["choose_combobox"].setFont(FONT)
84            self.objects["choose_combobox"].show()
85    
86            self.objects["choose_combobox"].addItems(
87                [re.sub("%.*?%", "", element) for element in functions.project.getAllProjectScenes(self.project, True)]
88            )
89    
90            # OPEN
91    
92            self.objects["create_button"] = QPushButton(parent=self, text=translate("Choose"))
93            self.objects["create_button"].setStyleSheet(BUTTON_BLUE_STYLE)
94    
95            self.objects["create_button"].released.connect(lambda: self.objects["empty"].setFocus())
96    
97            self.objects["create_button"].setGeometry(150, 340, 300, 40)
98            self.objects["create_button"].setFont(FONT)
99            self.objects["create_button"].show()
100    
101           self.objects["create_button"].clicked.connect(lambda event: ConfigButtonStartSceneFunctions.create(self.project, self, event))
102   
103   
104   class Config:
105       @staticmethod
106       def test(project) -> None:
107           with open(f"projects/{project.selectProject}/project/project.cfg", "r", encoding="utf-8") as file:
108               config = load(file)
109   
110           if os.path.exists(f"projects/{project.selectProject}/project/" + config["values"]["start_scene"]["value"]):
111               pass
112   
113           else:
114               config["values"]["start_scene"]["value"] = ""
115   
116           with open(f"projects/{project.selectProject}/project/project.cfg", "w", encoding="utf-8") as file:
117               dump(config, file, indent=4)
118   
119       @staticmethod
120       def get(file: dict) -> dict:
121           answer = {}
122   
123           for key, value in file["values"].items():
124               answer[key] = value["value"]
125   
126           return answer
127   
128       @staticmethod
129       def init(project) -> None:
130           with open(project.selectFile, "r", encoding="utf-8") as file:
131               config = load(file)
132   
133           project.objects["main"]["globals"] = ConfigAdditionsVarsType(
134               project,
135               Vec4i(
136                   project.objects["center_rama"].x() + project.objects["center_rama"].width() + 10,
137                   40,
138                   project.width() - (project.objects["center_rama"].x() + project.objects["center_rama"].width() + 10) - 10,
139                   project.height() - 70
140               ),
141               translate("Create global variable"),
142               f"projects/{project.selectProject}/project/project.cfg"
143           )
144   
145           x = (10 + 10 + Size.x(16) + 10) + 15
146           y = (40 + 30 + 10)
147   
148           for group in config["groups"]:
149               startY = y - 80
150               finishY = startY + (35 * len(group)) + 5
151   
152               y += 10
153   
154               project.objects["main"][f"{group}_rama"] = QTreeWidget(parent=project)
155               project.objects["main"][f"{group}_rama"].setGeometry(project.objects["center_rama"].x() + 10, project.objects["center_rama"].y() + startY + 10, project.objects["center_rama"].width() - 20, finishY - startY + 5)
156               project.objects["main"][f"{group}_rama"].setHeaderHidden(True)
157               project.objects["main"][f"{group}_rama"].show()
158   
159               for element in group:
160                   k = element
161                   v = config["values"][element]
162   
163                   if v["type"] == "none":
164                       continue
165   
166                   project.objects["main"][f"{k}_label"] = QLabel(parent=project, text=translate(v["name"]) + ":")
167                   project.objects["main"][f"{k}_label"].setGeometry(x, y, 200, 25)
168                   project.objects["main"][f"{k}_label"].setFont(FONT)
169                   project.objects["main"][f"{k}_label"].show()
170   
171                   if v["type"] == "str" or v["type"] == "int" or v["type"] == "path":
172                       project.objects["main"][f"{k}_entry"] = FocusLineEdit(parent=project, releasedFocusFunction=lambda empty=None, key=k, value=v: Config.function(project, f"{key}_entry", key, value))
173                       project.objects["main"][f"{k}_entry"].setGeometry(x + 200, y, project.objects["center_rama"].width() - (x + 400 + 20), 25)
174                       project.objects["main"][f"{k}_entry"].setFont(FONT)
175                       project.objects["main"][f"{k}_entry"].show()
176   
177                       project.objects["main"][f"{k}_entry"].setText(str(v["value"]))
178   
179                       project.objects["main"][f"{k}_entry"].saveAllValues = lambda self, proj, key=k, value=v, name=project.selectFile: Config.function(project, f"{key}_entry", key, value, name)
180   
181                   elif v["type"] == "bool":
182                       project.objects["main"][f"{k}_checkbox"] = QCheckBox(parent=project)
183                       project.objects["main"][f"{k}_checkbox"].setGeometry(x + 200, y, project.objects["center_rama"].width() - (x + 400 + 20), 25)
184                       project.objects["main"][f"{k}_checkbox"].setFont(FONT)
185                       project.objects["main"][f"{k}_checkbox"].show()
186   
187                       project.objects["main"][f"{k}_checkbox"].setChecked(v["value"])
188   
189                       project.objects["main"][f"{k}_checkbox"].clicked.connect(lambda empty=None, key=k, value=v: Config.function(project, f"{key}_checkbox", key, value))
190   
191                   elif v["type"] == "button-start-scene":
192                       project.objects["main"][f"{k}_button"] = QPushButton(parent=project)
193                       project.objects["main"][f"{k}_button"].setGeometry(x + 200, y, project.objects["center_rama"].width() - (x + 400 + 20), 25)
194                       project.objects["main"][f"{k}_button"].show()
195   
196                       project.objects["main"][f"{k}_button"].setText(re.sub("%.*?%", "", v["value"].replace(f"projects/{project.selectProject}/project/scenes/", "")) if v["value"] != "" else translate("Choose"))
197   
198                       project.objects["main"][f"{k}_button"].clicked.connect(lambda empty=None, key=k, value=v: ConfigButtonStartScene.start(project, key, value))
199   
200                   else:
201                       raise NameError(f"type {v['type']} is not defined")
202   
203                   y += 35
204   
205               y += 10
206   
207       @staticmethod
208       def save(project, key: str, value: dict, name: str = None) -> None:
209           if name is None:
210               name = project.selectFile
211   
212           try:
213               with open(name, "r", encoding="utf-8") as file:
214                   config = load(file)
215   
216               config["values"][key] = value
217   
218               with open(name, "w", encoding="utf-8") as file:
219                   dump(config, file, indent=4)
220   
221           except PermissionError:
222               pass
223   
224       @staticmethod
225       def function(project, obj: str, key: str, value: dict, name: str = None) -> None:
226           if obj == f"{key}_entry":
227               answer = ""
228   
229               try:
230                   if value["type"] == "str":
231                       answer = str(project.objects['main'][obj].text())
232   
233                   elif value["type"] == "path":
234                       if os.path.exists(f"projects/{project.selectProject}/project/{project.objects['main'][obj].text()}") and any([project.objects['main'][obj].text().endswith(element) for element in IMAGE_FORMATES]):
235                           answer = project.objects["main"][obj].text()
236   
237                       else:
238                           if project.objects["main"][obj].text() != "":
239                               MessageBox.error("The path does not exist or this isn't a image")
240   
241                           project.objects["main"][obj].setText(str(value["value"]))
242   
243                   elif value["type"] == "int":
244                       answer = int(project.objects['main'][obj].text())
245   
246                   else:
247                       answer = ""
248   
249               except BaseException:
250                   project.objects["main"][obj].setText(str(value["value"]))
251   
252               else:
253                   value["value"] = answer
254   
255                   Config.save(project, key, value, name)
256   
257           elif obj == f"{key}_checkbox":
258               value["value"] = project.objects["main"][obj].isChecked()
259   
260               Config.save(project, key, value, name)
261   
262           else:
263               pass
264   
##### scr\modules\functions\main\files\image.py #####
1     from PyQt5.QtWidgets import QLabel
2     from PyQt5.QtGui import QPixmap, QImage
3     
4     from PIL import Image as PImage
5     
6     from scr.variables import *
7     
8     import numpy
9     import math
10     import os
11    
12    
13    class Image:
14        @staticmethod
15        def replaceTransparentColor(image, color):
16            image = image.convert("RGBA")
17            data = numpy.array(image)
18    
19            r, g, b, a = data.T
20            transparent_areas = (a == 0)
21            data[..., :-1][transparent_areas.T] = color
22            data[..., -1][transparent_areas.T] = 255
23    
24            return PImage.fromarray(data)
25    
26        @staticmethod
27        def pillowToQImage(image):
28            data = image.tobytes("raw", "RGB")
29            qimage = QImage(data, image.width, image.height, QImage.Format_RGB888)
30    
31            return qimage
32    
33        @staticmethod
34        def getPixmap(project, maxWidth, maxHeight, file):
35            try:
36                image = PImage.open(file)
37    
38            except BaseException:
39                MessageBox.error(translate("Can not open this image"))
40    
41                project.objects["tab_file_bar"].pop(len(project.objects["tab_file_bar"].objects) - 1)
42    
43                return 0
44    
45            capacity = 1
46    
47            while image.width * capacity > maxWidth or image.height * capacity > maxHeight:
48                capacity /= 2
49    
50            while image.width * capacity * 2 < maxWidth and image.height * capacity * 2 < maxHeight:
51                capacity *= 2
52    
53            if capacity > project.engine.FLOAT_PRECISION:
54                image = image.resize((math.trunc(image.width * capacity) + (math.trunc(image.width * capacity) < 1), math.trunc(image.height * capacity) + (math.trunc(image.height * capacity) < 1)), resample=PImage.NEAREST)
55    
56            else:
57                return 0
58    
59            x = (maxWidth - image.width) // 2
60            y = (maxHeight - image.height) // 2
61    
62            image = Image.replaceTransparentColor(image, (32, 33, 36) if SETTINGS["theme"] == 'dark' else (248, 249, 250))
63            image.save("scr/files/cash/image.png")
64    
65            pixmap = QPixmap()
66            pixmap.load("scr/files/cash/image.png")
67    
68            return x, y, pixmap
69    
70        @staticmethod
71        def init(project) -> None:
72            if os.path.isdir(project.selectFile):
73                return 0
74    
75            if project.selectFile == "":
76                return 0
77    
78            maxWidth = project.objects["center_rama"].width()
79            maxHeight = project.objects["center_rama"].height()
80    
81            try:
82                image = PImage.open(project.selectFile)
83    
84            except BaseException:
85                MessageBox.error(translate("Can not open this image"))
86    
87                project.objects["tab_file_bar"].pop(len(project.objects["tab_file_bar"].objects) - 1)
88    
89                return 0
90    
91            capacity = 1
92    
93            while image.width * capacity > maxWidth or image.height * capacity > maxHeight:
94                capacity /= 2
95    
96            while image.width * capacity * 2 < maxWidth and image.height * capacity * 2 < maxHeight:
97                capacity *= 2
98    
99            if capacity > project.engine.FLOAT_PRECISION:
100                image = image.resize((math.trunc(image.width * capacity) + (math.trunc(image.width * capacity) < 1), math.trunc(image.height * capacity) + (math.trunc(image.height * capacity) < 1)), resample=PImage.NEAREST)
101   
102           else:
103               return 0
104   
105           x = (maxWidth - image.width) // 2
106           y = (maxHeight - image.height) // 2
107   
108           image = Image.replaceTransparentColor(image, (32, 33, 36) if SETTINGS["theme"] == 'dark' else (248, 249, 250))
109           image.save("scr/files/cash/image.png")
110   
111           pixmap = QPixmap()
112           pixmap.load("scr/files/cash/image.png")
113   
114           project.objects["main"]["image"] = QLabel(parent=project)
115           project.objects["main"]["image"].setGeometry(project.objects["center_rama"].x() + x, project.objects["center_rama"].y() + y, image.width, image.height)
116           project.objects["main"]["image"].setPixmap(pixmap)
117           project.objects["main"]["image"].show()
118   
##### scr\modules\functions\main\files\object.py #####
1     from PyQt5.QtWidgets import QLabel, QCheckBox, QTreeWidget, QTreeWidgetItem, QWidget, QHBoxLayout, QSizePolicy, QSpacerItem, QPushButton
2     
3     from scr.modules.widgets import FocusLineEdit, FocusComboBox
4     
5     from scr.modules.functions.main.files.code import CodeAdditionsVarsType
6     from scr.modules.dialogs import animatorCreateDialog
7     
8     from engine.vector.int import Vec4i
9     
10     from scr.variables import *
11    
12    import math
13    import json
14    import os
15    
16    SORTING_OBJECT_TYPES = {
17        "StaticObject": 1,
18        "DynamicObject": 2
19    }
20    
21    
22    class Object:
23        class ObjectTreeWidgetItem(QWidget):
24            def __init__(self, project, obj: dict, temp: dict, path: str, parent=None) -> None:
25                QWidget.__init__(self, parent)
26    
27                self.project = project
28    
29                self.complited = 0
30    
31                layout = QHBoxLayout()
32    
33                self.label = QLabel(translate(temp["name"]) + ":")
34                self.label.setFont(FONT)
35    
36                self.label.setFixedWidth(Size.x(20))
37    
38                save = project.selectFile
39    
40                if temp["type"] == "str" or temp["type"] == "path" or temp["type"] == "int":
41                    self.value = FocusLineEdit(project, releasedFocusFunction=lambda: Object.function(self.value, project, save, temp, path))
42                    self.value.setText(str(temp["value"]))
43    
44                    self.value.saveAllValues = lambda: Object.function(self.value, project, save, temp, path, init=False)
45    
46                elif temp["type"] == "bool":
47                    self.value = QCheckBox(project)
48                    self.value.setFixedHeight(20)
49                    self.value.setChecked(bool(temp["value"]))
50    
51                    self.value.clicked.connect(lambda: Object.function(self.value, project, save, temp, path, init=False))
52    
53                elif temp["type"] == "choose":
54                    self.value = FocusComboBox(releasedFocusFunction=lambda: Object.function(self.value, project, save, temp, path))
55                    self.value.currentIndexChanged.connect(lambda: self.value.clearFocus())
56                    self.value.addItems([translate(element) for element in temp["choose"]["input"]])
57                    self.value.setCurrentIndex([temp["value"] == element for i, element in enumerate(temp["choose"]["output"])].index(True))
58    
59                    self.value.saveAllValues = lambda: Object.function(self.value, project, save, temp, path, init=False)
60    
61                elif temp["type"] == "animator":
62                    self.value = QPushButton(self)
63                    self.value.setText(translate("Animation"))
64                    self.value.setFixedHeight(20)
65    
66                    self.value.clicked.connect(lambda: animatorCreateDialog(self.project))
67    
68                    self.value.saveAllValues = lambda: Object.function(self.value, project, save, temp, path, init=False)
69    
70                elif temp["type"] == "dict":
71                    project.objects["main"]["object_tree_objects"][path] = QTreeWidgetItem(project.objects["main"]["object_tree_objects"][path[:path.rfind("/")]])
72                    project.objects["main"]["object_tree_objects"][path].setText(0, translate(temp["name"]))
73                    project.objects["main"]["object_tree_objects"][path].setExpanded(True)
74                    project.objects["main"]["object_tree_objects"][path].setFont(0, FONT)
75    
76                    self.complited = 2
77    
78                    return
79    
80                else:
81                    raise TypeError(f"type {temp['type']} is not defined")
82    
83                self.value.setFont(FONT)
84                self.value.setFixedWidth(Size.x(25))
85    
86                layout.addWidget(self.label)
87                layout.addSpacerItem(QSpacerItem(20, 0, QSizePolicy.Expanding, QSizePolicy.Minimum))
88    
89                layout.addWidget(self.value)
90    
91                layout.setContentsMargins(0, 0, 10, 0)
92    
93                self.setLayout(layout)
94    
95                self.complited = 1
96    
97        @staticmethod
98        def get(obj, path) -> dict:
99            temp = obj
100    
101           for element in path.split("/"):
102               try:
103                   temp = temp[element]
104   
105               except KeyError:
106                   temp = temp["value"][element]
107   
108           return temp
109   
110       @staticmethod
111       def init(project, class_=ObjectTreeWidgetItem, file=None, pos=None, type: str = "object", variables: bool = True, bottom: bool = False) -> None:
112           def include(project, obj: dict, path: str, class_) -> None:
113               temp = Object.get(obj, path)
114   
115               try:
116                   widget = class_(project, obj, temp, path, project, type=type)
117   
118               except:
119                   widget = class_(project, obj, temp, path, project)
120   
121               if widget.complited == -1:
122                   return -1
123   
124               if widget.complited == 2:
125                   for key, value in temp["value"].items():
126                       include(project, obj, f"{path}/{key}", class_)
127   
128                   return 0
129   
130               else:
131                   project.objects["main"]["widgets"].append(widget)
132   
133               if path.count("/") == 0:
134                   project.objects["main"]["object_tree_objects"][path] = QTreeWidgetItem(project.objects["main"]["object_tree_main"])
135   
136               else:
137                   project.objects["main"]["object_tree_objects"][path] = QTreeWidgetItem(project.objects["main"]["object_tree_objects"][path[:path.rfind("/")]])
138   
139               project.objects["main"]["object_tree"].setItemWidget(
140                   project.objects["main"]["object_tree_objects"][path], 0, widget
141               )
142   
143           if file is None:
144               file = project.selectFile
145   
146           else:
147               pass
148   
149           try:
150               with open(file, "r", encoding="utf-8") as f:
151                   obj = load(f)
152   
153           except FileNotFoundError:
154               return 0
155   
156           if "object_variables" in project.objects["main"]:
157               try:
158                   project.objects["main"]["object_variables"].hide()
159   
160                   project.objects["main"]["object_variables"].deleteLater()
161   
162               except RuntimeError:
163                   pass
164   
165           project.objects["main"]["object_tree_objects"] = {}
166   
167           project.objects["main"]["object_tree"] = QTreeWidget(parent=project)
168   
169           if "variables" not in project.objects["main"]:
170               project.objects["main"]["variables"] = {}
171   
172           if variables:
173               if bottom:
174                   project.objects["main"]["object_variables"] = CodeAdditionsVarsType(
175                       project,
176                       Vec4i(
177                           project.objects["center_rama"].x() + project.objects["center_rama"].width() + 10,
178                           40 + 10 + (project.height() - 80) // 2,
179                           project.width() - (project.objects["center_rama"].x() + project.objects["center_rama"].width() + 10) - 10,
180                           (project.height() - 80) // 2
181                       ),
182                       translate("Create object variable"),
183                       file
184                   )
185   
186               else:
187                   project.objects["main"]["object_variables"] = CodeAdditionsVarsType(
188                       project,
189                       Vec4i(
190                           project.objects["center_rama"].x() + project.objects["center_rama"].width() + 10,
191                           40,
192                           project.width() - (project.objects["center_rama"].x() + project.objects["center_rama"].width() + 10) - 10,
193                           project.height() - 70
194                       ),
195                       translate("Create object variable"),
196                       file
197                   )
198   
199           project.objects["main"]["widgets"] = []
200   
201           if pos is None:
202               project.objects["main"]["object_tree"].setGeometry(project.objects["center_rama"].x(), project.objects["center_rama"].y(), project.objects["center_rama"].width(), project.objects["center_rama"].height())
203   
204           else:
205               project.objects["main"]["object_tree"].setGeometry(*pos)
206   
207           project.objects["main"]["object_tree"].header().hide()
208           project.objects["main"]["object_tree"].setFont(LFONT)
209           project.objects["main"]["object_tree"].show()
210   
211           project.objects["main"]["object_tree"].saveAllValues = lambda self, project: Object.saveAllValues(project)
212   
213           project.objects["main"]["object_tree_main"] = QTreeWidgetItem(project.objects["main"]["object_tree"])
214           project.objects["main"]["object_tree_main"].setText(0, file[file.rfind("/") + 1:])
215           project.objects["main"]["object_tree_main"].setExpanded(True)
216           project.objects["main"]["object_tree_main"].setFont(0, FONT)
217   
218           if include(project, obj, "type", class_) == -1:
219               pass
220   
221           obj = dict(sorted(obj.items(), key=lambda x: -1 if x[0] not in SORTING_OBJECT_TYPES else SORTING_OBJECT_TYPES[x[0]]))
222   
223           for key, value in obj.items():
224               if key == "type":
225                   continue
226   
227               if key not in obj["dependence"] + [obj["type"]["value"]]:
228                   continue
229   
230               project.objects["main"]["object_tree_objects"][key] = QTreeWidgetItem(project.objects["main"]["object_tree_main"])
231               project.objects["main"]["object_tree_objects"][key].setText(0, translate(key))
232               project.objects["main"]["object_tree_objects"][key].setExpanded(True)
233               project.objects["main"]["object_tree_objects"][key].setFont(0, FONT)
234   
235               for k1, v1 in value.items():
236                   include(project, obj, f"{key}/{k1}", class_)
237   
238       @staticmethod
239       def function(obj, project, save: str, last: dict, path: str, init: bool = True) -> None:
240           with open(f"engine/files/objects.json", "r", encoding="utf-8") as file:
241               objects = load(file)
242   
243           try:
244               with open(save, "r", encoding="utf-8") as f:
245                   file = load(f)
246   
247           except BaseException:
248               return 0
249   
250           if last["type"] == "bool":
251               text = obj.isChecked()
252   
253           else:
254               try:
255                   text = obj.text()
256   
257               except AttributeError:
258                   text = objects["specials"]["choose"][path[path.rfind("/") + 1:]]["output"][obj.currentIndex()]
259   
260           doing = False
261   
262           temp = Object.get(file, path)
263   
264           if last["type"] == "str":
265               temp["value"] = text
266   
267               doing = True
268   
269           if last["type"] == "bool":
270               temp["value"] = text
271   
272               doing = True
273   
274           if last["type"] == "path":
275               if text == "" or (os.path.exists(f"projects/{project.selectProject}/project/{text}") and any([text.endswith(element) for element in IMAGE_FORMATES])):
276                   temp["value"] = text
277   
278                   doing = True
279   
280               else:
281                   MessageBox.error("The path does not exist or this isn't a image")
282   
283           if last["type"] == "int":
284               try:
285                   float(text)
286   
287               except BaseException:
288                   pass
289   
290               else:
291                   doing = True
292   
293                   if abs(math.trunc(float(text)) - float(text)) < project.engine.FLOAT_PRECISION:
294                       temp["value"] = round(float(text))
295   
296                   else:
297                       temp["value"] = float(text)
298   
299           if last["type"] == "choose":
300               temp["value"] = text
301               file["dependence"] = file["dependences"][temp["value"]]
302   
303               doing = True
304   
305               for element in objects["dependences"][file["type"]["value"]] + [file["type"]["value"]]:
306                   for value in objects["objects"][element]:
307                       if element not in file:
308                           file[element] = {}
309   
310                       if value in file[element]:
311                           continue
312   
313                       if objects["type"] == "choose":
314                           file[element][value] = {
315                               "name": objects["name"][value],
316                               "value": objects["standard"][value],
317                               "type": objects["type"][value],
318                               "choose": objects["specials"]["choose"][value]
319                           }
320   
321                       else:
322                           file[element][value] = {
323                               "name": objects["name"][value],
324                               "value": objects["standard"][value],
325                               "type": objects["type"][value]
326                           }
327   
328           if not doing:
329               obj.setText(str(last["value"]))
330   
331           if doing and temp["value"] != last["value"]:
332               with open(save, "w", encoding="utf-8") as f:
333                   dump(file, f, indent=4)
334   
335               if init:
336                   project.init()
337   
338       @staticmethod
339       def saveAllValues(project):
340           for widget in project.objects["main"]["widgets"]:
341               if hasattr(widget, "value") and hasattr(widget.value, "saveAllValues"):
342                   widget.value.saveAllValues()
343   
##### scr\modules\functions\main\files\scene.py #####
1     from PyQt5.QtWidgets import QTreeWidget, QPushButton, QWidget, QSpacerItem, QSizePolicy, QHBoxLayout, QLabel, QTreeWidgetItem, QCheckBox, QMenu, QAction
2     from PyQt5.QtGui import QPixmap, QImage, QCursor, QPainter, QPen, QColor
3     from PyQt5.Qt import Qt, QTimer, QPoint
4     
5     from scr.modules.dialogs import CreateSceneObject, animatorCreateDialog
6     
7     from scr.modules.dialogs.tree.create_object import CreateObjectFunctions
8     from scr.modules.functions.main.files import Object
9     from scr.modules.functions.main.files.object import Object as ObjectTypingClass
10     
11    from scr.modules.widgets import FocusLineEdit, FocusComboBox
12    
13    from scr.modules import functions
14    
15    from engine.vector.float import Vec2f
16    
17    from scr.variables import *
18    
19    from PIL import Image
20    
21    import dataclasses
22    import pyperclip
23    import shutil
24    import typing
25    import json
26    import math
27    import re
28    
29    
30    def isCurrectObject(obj: dict):
31        def func(obj, path):
32            if len(path) == 0:
33                return obj, []
34    
35            var = obj[path[0]]
36            path.pop(0)
37    
38            return var, path
39    
40        for element in OBJECT_CURRECT_TEST:
41            try:
42                func(obj, element.split("/"))
43    
44            except BaseException:
45                return False
46    
47        return True
48    
49    
50    @dataclasses.dataclass
51    class SceneHash:
52        type: str = "scene"
53    
54        screen: Image.Image = None
55        camera: typing.Any = None
56    
57        selectObject: str = None
58        selectLink: id = -1
59    
60        settings: str = ""
61    
62        size: int = 1
63    
64    
65    class SceneLabel(QLabel):
66        def __init__(self, parent=None, draggingFunction: typing.Callable = None, pressFunction: typing.Callable = None, releasedFunction: typing.Callable = None) -> None:
67            QLabel.__init__(self, parent)
68    
69            self.draggingFunction = draggingFunction
70    
71            self.pressFunction = pressFunction
72            self.releasedFunction = releasedFunction
73    
74            self.project = parent
75    
76            self.lastPoint = QPoint()
77    
78            self.position = None
79    
80            self.drawing = False
81    
82            self.pos = Vec2f()
83    
84            self.setMouseTracking(True)
85    
86            if "scene_timer" in self.project.objects["main"]:
87                try:
88                    self.project.objects["main"]["scene_timer"].stop()
89    
90                except RuntimeError:
91                    pass
92    
93            with open(self.project.cash["file"][self.project.selectFile].settings, "r", encoding="utf-8") as file:
94                self.sceneSettings = load(file)
95    
96        def updateCameraObject(self) -> None:
97            if self.x() < QCursor.pos().x() - self.project.x() < self.x() + self.width() and self.y() < QCursor.pos().y() - self.project.y() - 40 < self.y() + self.height():
98                self.position = Vec2f(QCursor.pos().x() - self.project.x() - self.x(), QCursor.pos().y() - self.project.y() - self.y() - 40)
99    
100            else:
101               self.position = None
102   
103           if self.draggingFunction is None:
104               return 0
105   
106           if self.sceneSettings["Scene"]["camera_acceleration"]["value"]:
107               speed = math.sqrt(self.pos.x ** 2 + self.pos.y ** 2) / 15
108   
109               pos = Vec2f(*self.pos.get())
110   
111               while abs(pos.x) > speed or abs(pos.y) > speed:
112                   pos /= 2
113   
114               pos.x = int(pos.x)
115               pos.y = int(pos.y)
116   
117               self.pos.x -= pos.x
118               self.pos.y -= pos.y
119   
120               self.draggingFunction(pos.x, pos.y)
121   
122           else:
123               self.draggingFunction(self.pos.x, self.pos.y)
124   
125               self.pos = Vec2f()
126   
127       def mousePressEvent(self, event) -> None:
128           if event.button() == Qt.LeftButton:
129               self.lastPoint = event.pos()
130   
131               self.pressFunction(event.pos().x() - self.project.objects["main"]["scene"].width() // 2, event.pos().y() - self.project.objects["main"]["scene"].height() // 2)
132   
133               self.drawing = True
134   
135           try:
136               self.setFocus()
137   
138           except RuntimeError:
139               pass
140   
141       def mouseReleaseEvent(self, event) -> None:
142           if event.button() == Qt.LeftButton:
143               if self.releasedFunction is not None:
144                   self.releasedFunction(event.pos().x() - self.project.objects["main"]["scene"].width() // 2, event.pos().y() - self.project.objects["main"]["scene"].height() // 2)
145   
146               self.drawing = False
147   
148       def mouseMoveEvent(self, event) -> None:
149           self.updateCameraObject()
150   
151           if event.buttons() & Qt.LeftButton and self.drawing:
152               x = event.pos().x() - self.lastPoint.x()
153               y = event.pos().y() - self.lastPoint.y()
154   
155               self.lastPoint = event.pos()
156   
157               if self.draggingFunction is not None:
158                   self.pos.x += x
159                   self.pos.y += y
160   
161               try:
162                   self.update()
163   
164               except RuntimeError:
165                   pass
166   
167   
168   class SceneAdditions:
169       class SceneAdditionWidgetItem(QWidget):
170           def __init__(self, project, obj: dict, temp: dict, path: str, file: str, type: str = "object", parent=None) -> None:
171               QWidget.__init__(self, parent)
172   
173               self.project = project
174   
175               self.complited = 0
176   
177               layout = QHBoxLayout()
178   
179               try:
180                   self.label = QLabel(translate(temp["name"]) + ":")
181                   self.label.setFont(FONT)
182   
183               except KeyError:
184                   self.complited = -1
185   
186                   return
187   
188               self.label.setFixedWidth(Size.x(8))
189   
190               if type == "object":
191                   save = project.cash["file"][project.selectFile].selectObject.variables["file"]
192   
193               else:
194                   save = project.cash["file"][project.selectFile].settings
195   
196               if temp["type"] == "str" or temp["type"] == "path" or temp["type"] == "int":
197                   self.value = FocusLineEdit(parent=project, releasedFocusFunction=lambda: self.focusOutLabel(project, save, temp, path))
198                   self.value.setText(str(temp["value"]))
199   
200                   self.value.saveAllValues = lambda: ObjectTypingClass.function(self.value, project, save, temp, path, init=False)
201   
202               elif temp["type"] == "choose":
203                   self.value = FocusComboBox(releasedFocusFunction=lambda: ObjectTypingClass.function(self.value, project, save, temp, path))
204                   self.value.currentIndexChanged.connect(lambda: self.value.clearFocus())
205                   self.value.addItems([translate(element) for element in temp["choose"]["input"]])
206                   self.value.setCurrentIndex([temp["value"] == element for i, element in enumerate(temp["choose"]["output"])].index(True))
207   
208               elif temp["type"] == "dict":
209                   project.objects["main"]["object_tree_objects"][path] = QTreeWidgetItem(project.objects["main"]["object_tree_objects"][path[:path.rfind("/")]])
210                   project.objects["main"]["object_tree_objects"][path].setText(0, translate(temp["name"]))
211                   project.objects["main"]["object_tree_objects"][path].setExpanded(True)
212                   project.objects["main"]["object_tree_objects"][path].setFont(0, FONT)
213   
214                   self.complited = 2
215   
216                   return
217   
218               elif temp["type"] == "bool":
219                   self.value = QCheckBox(parent=project)
220                   self.value.setChecked(bool(temp["value"]))
221   
222                   self.value.stateChanged.connect(lambda: self.focusOutCheckBox(project, save, temp, path))
223   
224               elif temp["type"] == "animator":
225                   self.value = QPushButton(self)
226                   self.value.setText(translate("Animation"))
227                   self.value.setFixedHeight(20)
228   
229                   self.value.clicked.connect(lambda: animatorCreateDialog(self.project, save))
230   
231                   self.value.saveAllValues = lambda: ObjectTypingClass.function(self.value, project, save, temp, path, init=False)
232   
233               elif temp["type"] == "none":
234                   pass
235   
236               else:
237                   raise TypeError(f"type {temp['type']} is not defined")
238   
239               if temp["type"] == "none":
240                   self.complited = -1
241   
242                   return
243   
244               self.value.setFont(FONT)
245               self.value.setFixedWidth(Size.x(3))
246   
247               layout.addWidget(self.label)
248               layout.addSpacerItem(QSpacerItem(20, 0, QSizePolicy.Expanding, QSizePolicy.Minimum))
249   
250               layout.addWidget(self.value)
251   
252               layout.setContentsMargins(0, 0, 10, 0)
253   
254               self.setLayout(layout)
255   
256               self.complited = 1
257   
258           def focusOutLabel(self, project, save, temp, path) -> None:
259               ObjectTypingClass.function(self.value, project, save, temp, path)
260   
261               self.focusOut(project)
262   
263           def focusOutCheckBox(self, project, save, temp, path) -> None:
264               ObjectTypingClass.function(self.value, project, save, temp, path)
265   
266               self.focusOut(project)
267   
268           def focusOut(self, project) -> None:
269               try:
270                   select = project.application[project.selectFile].objects.getByGroup("__debug_select__")[0]
271   
272               except KeyError:
273                   return
274   
275               except IndexError:
276                   pass
277   
278               else:
279                   obj = project.cash["file"][project.selectFile].selectObject
280   
281                   select.hitbox = obj.hitbox
282                   select.pos = obj.pos
283   
284                   Scene.select(project, obj.pos.x + 1, obj.pos.y + 1)
285   
286       @staticmethod
287       def init(project) -> None:
288           try:
289               project.objects["main"]["settings"].hide()
290               project.objects["main"]["settings"].deleteLater()
291   
292               project.objects["main"]["object_tree"].hide()
293               project.objects["main"]["object_tree"].deleteLater()
294   
295           except BaseException:
296               pass
297   
298           project.objects["main"]["settings"] = QTreeWidget(parent=project)
299           project.objects["main"]["settings"].setGeometry(10 + 10 + Size.x(16) + Size.x(68) - 40 + 10, 40, Size.x(16), Size.y(100) - 70)
300           project.objects["main"]["settings"].setHeaderHidden(True)
301           project.objects["main"]["settings"].header().setFont(FONT)
302   
303           if project.cash["file"][project.selectFile].selectObject is not None:
304               file = project.cash["file"][project.selectFile].selectObject.variables["file"]
305   
306               ObjectTypingClass.init(
307                   project, SceneAdditions.SceneAdditionWidgetItem, file,
308                   (
309                       project.objects["center_rama"].x() + project.objects["center_rama"].width() + 10,
310                       40,
311                       project.width() - (project.objects["center_rama"].x() + project.objects["center_rama"].width() + 10) - 10,
312                       (project.height() - 80) // 2
313                   ), type="object", bottom=True
314               )
315   
316               project.objects["main"]["settings"].hide()
317   
318           else:
319               file = project.cash["file"][project.selectFile].settings
320   
321               ObjectTypingClass.init(
322                   project, SceneAdditions.SceneAdditionWidgetItem, file,
323                   (
324                       project.objects["main"]["settings"].x(),
325                       project.objects["main"]["settings"].y(),
326                       project.objects["main"]["settings"].width(),
327                       project.objects["main"]["settings"].height()
328                   ), type="scene", variables=False
329               )
330   
331               project.objects["main"]["settings"].show()
332   
333   
334   class Scene:
335       updating = False
336   
337       @staticmethod
338       def init(project, call: str = "") -> None:
339           project.cash["file"][project.selectFile].settings = f"projects/{project.selectProject}/project/cash/{'-'.join(project.selectFile.split('/')[3:])}-setting.json"
340   
341           with open(f"projects/{project.selectProject}/project/project.cfg", "r", encoding="utf-8") as file:
342               project.objects["main"]["project_settings"] = load(file)
343   
344           if not os.path.exists(project.cash["file"][project.selectFile].settings):
345               CreateObjectFunctions.create(project, None, None, "", False, "engine/files/scene.json", project.cash["file"][project.selectFile].settings)
346   
347           with open(project.cash["file"][project.selectFile].settings, "r", encoding="utf-8") as file:
348               project.objects["main"]["scene_settings"] = load(file)
349   
350           try:
351               if project.selectFile not in project.application:
352                   project.application[project.selectFile] = project.engine.Application(usingWidth=project.desktop.width(), usingHeight=project.desktop.height(), visiable=False, debug=False, autoUpdateScreen=False, forcedViewObject=True)
353   
354                   project.cash["file"][project.selectFile].camera = project.engine.objects.DynamicObject(project.application[project.selectFile], (0, 0), (0, 0, 1, 1), group="__mouse__", gravity=0, layer=int(1e9))
355   
356                   project.application[project.selectFile].objects.add(project.cash["file"][project.selectFile].camera)
357   
358                   project.application[project.selectFile].objects.add(project.engine.objects.StaticObject(project.application[project.selectFile], (0, -100000), (0, 0, 1, 200000), group="__debug__", layer=int(1e9)))
359                   project.application[project.selectFile].objects.add(project.engine.objects.StaticObject(project.application[project.selectFile], (-100000, 0), (0, 0, 200000, 1), group="__debug__", layer=int(1e9)))
360   
361                   project.application[project.selectFile].setCamera(project.engine.camera.FocusCamera(project.application[project.selectFile], project.cash["file"][project.selectFile].camera))
362   
363           except TypeError as e:
364               print(e)
365   
366           else:
367               try:
368                   if "scene" in project.objects["main"]:
369                       project.objects["main"]["scene"].deleteLater()
370   
371               except RuntimeError:
372                   pass
373   
374               project.objects["main"]["scene"] = SceneLabel(
375                   parent=project, draggingFunction=lambda x, y: Scene.move(project, x, y), pressFunction=lambda x, y: Scene.select(project, x, y), releasedFunction=lambda x, y: Scene.update(project)
376               )
377   
378               project.objects["main"]["scene"].setGeometry(project.objects["center_rama"].x() + 2, project.objects["center_rama"].y() + 2, project.objects["center_rama"].width() - 4, project.objects["center_rama"].height() - 4)
379               project.objects["main"]["scene"].show()
380   
381               project.objects["main"]["scene"].setContextMenuPolicy(Qt.CustomContextMenu)
382   
383               project.objects["main"]["scene"].customContextMenuRequested.connect(
384                   lambda pos: Scene.menu(project, pos)
385               )
386   
387               project.objects["main"]["scene"].saveAllValues = lambda self, project: Scene.saveAllValues(project)
388   
389               Scene.update(project)
390   
391           SceneAdditions.init(project)
392   
393           def update_():
394               try:
395                   Scene.update(project, call="auto")
396   
397               except AttributeError:
398                   pass
399   
400           # project.objects["main"]["timer"] = QTimer(project)
401           # project.objects["main"]["timer"].timeout.connect(lambda: update_())
402           # project.objects["main"]["timer"].start(1000 // 30)
403   
404       @staticmethod
405       def objects(project) -> None:
406           application = project.application[project.selectFile]
407   
408           for obj in application.objects.objects:
409               if not obj.group.startswith("__") or not obj.group.endswith("__"):
410                   application.objects.remove(obj)
411   
412           var = []
413   
414           for file in os.listdir(project.selectFile):
415               var.append(file)
416   
417           var.sort()
418   
419           id = 0
420   
421           for file in var:
422               with open(f"{project.selectFile}/{file}", "r") as f:
423                   type, variables = Scene.loadObjectFile(project, file[:file.rfind(".")][file.rfind("-") + 1:], load(f))
424   
425                   obj = getattr(project.engine.objects, type)(application, **variables, id=id, variables={"file": f"{project.selectFile}/{file}"})
426   
427                   if hasattr(obj, "gravity"):
428                       obj.gravity = 0
429   
430                   application.objects.add(obj)
431   
432               id += 1
433   
434           if application.objects.getById(project.cash["file"][project.selectFile].selectLink) is None and project.cash["file"][project.selectFile].selectObject is not None:
435               Scene.objectReleased(project)
436   
437       @staticmethod
438       def select(project, x, y) -> None:
439           application = project.application[project.selectFile]
440   
441           project.objects["main"]["scene"].setFocus()
442   
443           select = []
444   
445           if project.selectFile not in project.application:
446               return 0
447   
448           for obj in application.objects.objects:
449               if obj.group.startswith("__") and obj.group.endswith("__"):
450                   continue
451   
452               if obj.pos.x + obj.hitbox.x < x + project.cash["file"][project.selectFile].camera.pos.x < obj.pos.x + obj.hitbox.x + obj.hitbox.width and obj.pos.y + obj.hitbox.y < y + project.cash["file"][project.selectFile].camera.pos.y < obj.pos.y + obj.hitbox.y + obj.hitbox.height:
453                   select.append(obj)
454   
455           if len(select) > 0:
456               application.objects.removeByGroup("__debug_select__")
457   
458           else:
459               return 0
460   
461           # print(select)
462   
463           for obj in application.objects.objects:
464               if obj.group.find("debug") != -1 and obj.group.startswith("__") and obj.group.endswith("__"):
465                   continue
466   
467               if obj.pos.x + obj.hitbox.x < x + project.cash["file"][project.selectFile].camera.pos.x < obj.pos.x + obj.hitbox.x + obj.hitbox.width and obj.pos.y + obj.hitbox.y < y + project.cash["file"][project.selectFile].camera.pos.y < obj.pos.y + obj.hitbox.y + obj.hitbox.height:
468                   project.cash["file"][project.selectFile].selectObject = obj
469                   project.cash["file"][project.selectFile].selectLink = obj.id
470   
471                   application.objects.add(project.engine.objects.StaticObject(
472                       application, obj.pos, obj.hitbox, group="__debug_select__"
473                   ))
474   
475                   # print("create")
476   
477                   Scene.update(project)
478   
479                   break
480   
481       @staticmethod
482       def menu(project, position) -> None:
483           application = project.application[project.selectFile]
484   
485           x = position.x() - project.objects["main"]["scene"].width() // 2
486           y = position.y() - project.objects["main"]["scene"].height() // 2
487   
488           project.objects["main"]["scene_menu"] = QMenu()
489   
490           project.objects["main"]["scene_menu_new_action"] = QAction(translate("Create object"), project)
491           project.objects["main"]["scene_menu_new_action"].triggered.connect(lambda: Scene.createSceneObject(project, position))
492   
493           project.objects["main"]["scene_menu_copy_action"] = QAction(translate("Copy"), project)
494           project.objects["main"]["scene_menu_copy_action"].triggered.connect(lambda: Scene.copyObject(project))
495   
496           project.objects["main"]["scene_menu_paste_action"] = QAction(translate("Paste"), project)
497           project.objects["main"]["scene_menu_paste_action"].triggered.connect(lambda: Scene.pasteObject(project))
498   
499           project.objects["main"]["scene_menu_delete_action"] = QAction(translate("Delete"), project)
500           project.objects["main"]["scene_menu_delete_action"].triggered.connect(lambda: Scene.deleteSceneObject(project, position))
501   
502           for obj in application.objects.objects:
503               if obj.group.find("debug") != -1 and obj.group.startswith("__") and obj.group.endswith("__"):
504                   continue
505   
506               if obj.pos.x + obj.hitbox.x < x + project.cash["file"][project.selectFile].camera.pos.x < obj.pos.x + obj.hitbox.x + obj.hitbox.width and obj.pos.y + obj.hitbox.y < y + project.cash["file"][project.selectFile].camera.pos.y < obj.pos.y + obj.hitbox.y + obj.hitbox.height:
507                   break
508   
509           else:
510               project.objects["main"]["scene_menu_copy_action"].setDisabled(True)
511               project.objects["main"]["scene_menu_delete_action"].setDisabled(True)
512   
513           project.objects["main"]["scene_menu"].addAction(project.objects["main"]["scene_menu_new_action"])
514           project.objects["main"]["scene_menu"].addSeparator()
515           project.objects["main"]["scene_menu"].addAction(project.objects["main"]["scene_menu_copy_action"])
516           project.objects["main"]["scene_menu"].addAction(project.objects["main"]["scene_menu_paste_action"])
517           project.objects["main"]["scene_menu"].addSeparator()
518           project.objects["main"]["scene_menu"].addAction(project.objects["main"]["scene_menu_delete_action"])
519   
520           project.objects["main"]["scene_menu"].popup(project.objects["main"]["scene"].mapToGlobal(position))
521   
522       @staticmethod
523       def update(project, call: str = "") -> None:
524           try:
525               application = project.application[project.selectFile]
526   
527           except KeyError:
528               return 0
529   
530           if Scene.updating:
531               return 0
532   
533           Scene.updating = True
534   
535           Scene.objects(project)
536   
537           if call not in ("move", "auto"):
538               SceneAdditions.init(project)
539   
540           x = project.cash["file"][project.selectFile].camera.pos.x
541           y = project.cash["file"][project.selectFile].camera.pos.y
542   
543           # STATUS BAR
544   
545           if call not in ("auto", ):
546               if project.cash["file"][project.selectFile].selectObject is not None:
547                   project.objects["status_bar"].showMessage(project.cash["file"][project.selectFile].selectObject.variables["file"])
548   
549               else:
550                   project.objects["status_bar"].showMessage(project.selectFile)
551   
552           # GRID
553   
554           sceneSettings = project.objects["main"]["scene_settings"]
555   
556           gridWidth = sceneSettings["Scene"]["grid"]["value"]["x"]["value"]
557           gridHeight = sceneSettings["Scene"]["grid"]["value"]["y"]["value"]
558   
559           gridX = x // gridWidth * gridWidth
560           gridY = y // gridHeight * gridHeight
561   
562           lastDrawing = []
563   
564           if SETTINGS["theme"] == "light":
565               lastDrawing.append(["rect", [application.screen, (248, 249, 250), (0, 0, project.desktop.width(), project.desktop.height())]])
566   
567           if sceneSettings["Scene"]["visiable_grid"]["value"]:
568               for px in range(-project.objects["main"]["scene"].width() // 2 // gridWidth - 2, project.objects["main"]["scene"].width() // 2 // gridWidth + 2):
569                   for py in range(-project.objects["main"]["scene"].height() // 2 // gridHeight - 2, project.objects["main"]["scene"].height() // 2 // gridHeight + 2):
570                       lastDrawing.append(["rect", [application.screen, (63, 64, 66) if SETTINGS["theme"] == "dark" else (218, 220, 224), (
571                           (project.desktop.width() // 2 + gridX - (x - gridX) - (gridWidth * (gridX // gridWidth))) + px * gridWidth,
572                           (project.desktop.height() // 2 + gridY - (y - gridY) - (gridHeight * (gridY // gridHeight))) + py * gridHeight,
573                           gridWidth,
574                           gridHeight
575                       ), 1]])
576   
577           # CENTER RAMA
578   
579           application.objects.removeByGroup("__debug_center_rama__")
580   
581           projectSettings = project.objects["main"]["project_settings"]
582   
583           if sceneSettings["Scene"]["visiable_screen"]["value"]:
584               application.objects.add(project.engine.objects.StaticObject(
585                   application, [x - projectSettings["values"]["width"]["value"] // 2, y - projectSettings["values"]["height"]["value"] // 2],
586                   [0, 0, projectSettings["values"]["width"]["value"], projectSettings["values"]["height"]["value"]],
587                   group="__debug_center_rama__", layer=int(1e9 + 2)
588               ))
589   
590           # VISIABLE
591   
592           try:
593               project.cash["file"][project.selectFile].screen = application.frame(image=True, screenFillColor=(32, 33, 36), lastDrawing=lastDrawing)
594   
595           except KeyError:
596               project.objects["tab_file_bar"].updateSelectFile()
597   
598               print("error")
599   
600               return 0
601   
602           qpixmap = QPixmap(Scene.getVisiableScreen(QImage(project.application[project.selectFile].screen.get_buffer(), project.desktop.width(), project.desktop.height(), QImage.Format_RGB32), project.objects["center_rama"].width(), project.objects["center_rama"].height()))
603   
604           # UI
605   
606           painter = QPainter(qpixmap)
607           painter.setFont(SFONT)
608   
609           painter.setPen(QPen(QColor(255, 255, 255) if SETTINGS["theme"] == "dark" else QColor(70, 70, 70), 1))
610   
611           painter.drawText(
612               5, project.objects["center_rama"].height() - 8, f"X, Y: {int(project.cash['file'][project.selectFile].camera.pos.x)}  {int(project.cash['file'][project.selectFile].camera.pos.y)}"
613           )
614   
615           painter.end()
616   
617           project.objects["main"]["scene"].setPixmap(qpixmap)
618   
619           Scene.updating = False
620   
621       @staticmethod
622       def move(project, x, y) -> None:
623           if project.selectFile == "":
624               return 0
625   
626           project.cash["file"][project.selectFile].camera.pos.x -= x
627           project.cash["file"][project.selectFile].camera.pos.y -= y
628   
629           try:
630               Scene.update(project, "move")
631   
632           except BaseException:
633               pass
634   
635       @staticmethod
636       def test(project) -> None:
637           # FOCUS OBJECT
638   
639           for scene in functions.project.getAllProjectScenes(project, False):
640               path = f"projects/{project.selectProject}/project/cash/{'-'.join(scene.split('/')[3:])}-setting.json"
641   
642               if not os.path.exists(path):
643                   continue
644   
645               with open(path, "r") as file:
646                   sceneSettings = load(file)
647   
648               name = sceneSettings["Scene"]["focus"]["value"]
649   
650               if name == "":
651                   continue
652   
653               if not name.endswith(".objc"):
654                   name += ".objc"
655   
656               if name not in os.listdir(scene):
657                   if True:
658                       pass
659   
660                   else:
661                       name = ""
662   
663               sceneSettings["Scene"]["focus"]["value"] = name
664   
665               with open(path, "w") as file:
666                   dump(sceneSettings, file, indent=4)
667   
668       @staticmethod
669       def createSceneObject(project, position) -> None:
670           project.dialog = CreateSceneObject(project, position, parent=project)
671           project.dialog.exec_()
672   
673       @staticmethod
674       def deleteSceneObject(project, position) -> None:
675           application = project.application[project.selectFile]
676   
677           x = position.x() - project.objects["main"]["scene"].width() // 2
678           y = position.y() - project.objects["main"]["scene"].height() // 2
679   
680           for obj in application.objects.objects:
681               if obj.group.find("debug") != -1 and obj.group.startswith("__") and obj.group.endswith("__"):
682                   continue
683   
684               if obj.pos.x + obj.hitbox.x < x + project.cash["file"][project.selectFile].camera.pos.x < obj.pos.x + obj.hitbox.x + obj.hitbox.width and obj.pos.y + obj.hitbox.y < y + project.cash["file"][project.selectFile].camera.pos.y < obj.pos.y + obj.hitbox.y + obj.hitbox.height:
685                   try:
686                       os.remove(obj.variables["file"])
687   
688                   except OSError:
689                       pass
690   
691                   project.init()
692   
693                   break
694   
695       @staticmethod
696       def copyObject(project) -> None:
697           if project.objects["main"]["scene"].position is None:
698               return 0
699   
700           if project.cash["file"][project.selectFile].selectObject is not None:
701               pyperclip.copy(project.cash["file"][project.selectFile].selectObject.variables["file"])
702   
703       @staticmethod
704       def pasteObject(project) -> None:
705           if project.objects["main"]["scene"].position is None:
706               return 0
707   
708           pos = Vec2f(
709               project.objects["main"]["scene"].position.x + project.cash["file"][project.selectFile].camera.pos.x,
710               project.objects["main"]["scene"].position.y + project.cash["file"][project.selectFile].camera.pos.y
711           )
712   
713           copyName = pyperclip.paste()
714   
715           name = copyName[copyName.rfind("/") + 1:]
716   
717           if bool(re.search(r"\d+$", name[:name.rfind(".")])):
718               ext = name[name.rfind(".") + 1:]
719               name = name.replace(f".{ext}", "")
720   
721               name = name.replace(name[name.rfind(" "):], "")
722               name = f"{name}.{ext}"
723   
724           index = 1
725   
726           while True:
727               newName = f"{name[:name.rfind('.')]}{index}.{name[name.rfind('.') + 1:]}"
728   
729               if os.path.exists(f"{project.selectFile}/{newName}"):
730                   index += 1
731   
732               else:
733                   break
734   
735           path = f"{copyName[:copyName.rfind('/')]}/{newName}"
736   
737           # TODO: проверять что файл являеться объектом
738   
739           try:
740               with open(copyName, "r") as file:
741                   obj = load(file)
742   
743           except FileNotFoundError or OSError:
744               MessageBox.error(translate("Path is not difined (object must was copyed on scene)"))
745   
746               return 0
747   
748           if not isCurrectObject(obj):
749               MessageBox.error(translate("This text is not object"))
750   
751               return 0
752   
753           shutil.copyfile(copyName, path)
754   
755           with open(path, "r") as file:
756               obj = load(file)
757   
758           width = project.objects["main"]["scene_settings"]["Scene"]["grid"]["value"]["x"]["value"]
759           height = project.objects["main"]["scene_settings"]["Scene"]["grid"]["value"]["y"]["value"]
760   
761           if project.objects["main"]["scene_settings"]["Scene"]["snap"]["value"]:
762               obj["StaticObject"]["pos"]["value"]["x"]["value"] = (pos.x - project.objects["main"]["scene"].width() // 2) // width * width
763               obj["StaticObject"]["pos"]["value"]["y"]["value"] = (pos.y - project.objects["main"]["scene"].height() // 2) // height * height
764   
765           else:
766               obj["StaticObject"]["pos"]["value"]["x"]["value"] = pos.x - project.objects["main"]["scene"].width() // 2
767               obj["StaticObject"]["pos"]["value"]["y"]["value"] = pos.y - project.objects["main"]["scene"].height() // 2
768   
769           with open(path, "w") as file:
770               dump(obj, file, indent=4)
771   
772           project.init()
773   
774       @staticmethod
775       def deleteObject(project) -> None:
776           if project.objects["main"]["scene"].position is None:
777               return 0
778   
779           if project.cash["file"][project.selectFile].selectObject is not None:
780               try:
781                   os.remove(project.cash["file"][project.selectFile].selectObject.variables["file"])
782   
783                   Scene.objectReleased(project)
784   
785               except FileNotFoundError:
786                   pass
787   
788           project.init()
789   
790       @staticmethod
791       def objectReleased(project) -> None:
792           if project.selectFile.find("%scene%") == -1:
793               return 0
794   
795           project.application[project.selectFile].objects.removeByGroup("__debug_select__")
796   
797           project.cash["file"][project.selectFile].selectObject = None
798           project.cash["file"][project.selectFile].selectLink = -1
799   
800           Scene.update(project)
801   
802       @staticmethod
803       def loadObjectFile(project, id: int, obj: dict) -> dict:
804           answer = {}
805   
806           for element in obj["dependence"] + [obj["type"]["value"]]:
807               for key, value in obj[element].items():
808                   if value["type"] == "dict":
809                       answer[key] = [elem["value"] for elem in value["value"].values()]
810   
811                   else:
812                       answer[key] = value["value"]
813   
814           if "sprite" in answer and answer["sprite"] != "":
815               answer["sprite"][0] = f"projects/{project.selectProject}/project/{answer['sprite'][0]}"
816   
817           # print(answer["sprite"])
818   
819           return obj["type"]["value"], answer
820   
821       @staticmethod
822       def toObjectMove(project, direction) -> None:
823           application = project.application[project.selectFile]
824   
825           directions = {
826               "right": (1, 0),
827               "left": (-1, 0),
828               "up": (0, -1),
829               "down": (0, 1)
830           }
831   
832           if project.selectFile not in project.cash["file"]:
833               return 0
834   
835           if project.cash["file"][project.selectFile] is None or project.cash["file"][project.selectFile].type != "scene":
836               return 0
837   
838           if project.cash["file"][project.selectFile].selectObject is None:
839               return 0
840   
841           with open(project.cash["file"][project.selectFile].selectObject.variables["file"], "r") as file:
842               obj = load(file)
843   
844           obj["StaticObject"]["pos"]["value"]["x"]["value"] += directions[direction][0]
845           obj["StaticObject"]["pos"]["value"]["y"]["value"] += directions[direction][1]
846   
847           with open(project.cash["file"][project.selectFile].selectObject.variables["file"], "w") as file:
848               dump(obj, file, indent=4)
849   
850           select = project.application[project.selectFile].objects.getByGroup("__debug_select__")[0]
851   
852           obj = project.cash["file"][project.selectFile].selectObject
853   
854           select.hitbox = obj.hitbox
855   
856           select.pos = obj.pos
857   
858           for i in range(2):
859               Scene.select(project, obj.pos.x + obj.hitbox.width // 2, obj.pos.y + obj.hitbox.height // 2)
860   
861               Scene.update(project)
862   
863       @staticmethod
864       def saveAllValues(project) -> None:
865           pass
866   
867       @staticmethod
868       def getVisiableScreen(image, width, height) -> Image.Image:
869           def center(image: QImage, newWidth: int, newHeight: int) -> QImage:
870               width = image.width()
871               height = image.height()
872   
873               left = (width - newWidth) // 2
874               top = (height - newHeight) // 2
875               right = left + newWidth
876               bottom = top + newHeight
877   
878               return image.copy(left, top, newWidth, newHeight)
879   
880           return center(image, width, height)
881   
##### scr\modules\functions\main\files\text.py #####
1     from PyQt5.QtWidgets import QTextEdit
2     from PyQt5 import QtGui
3     
4     from scr.variables import *
5     
6     import os
7     
8     
9     class Text:
10         @staticmethod
11        def init(project) -> None:
12            if os.path.isdir(project.selectFile):
13                return 0
14    
15            if project.selectFile == "":
16                return 0
17    
18            with open(project.selectFile, "r") as file:
19                text = file.read()
20    
21            project.objects["main"]["editor_textedit"] = QTextEdit(parent=project)
22            project.objects["main"]["editor_textedit"].setGeometry(project.objects["center_rama"].x(), project.objects["center_rama"].y(), project.objects["center_rama"].width(), project.objects["center_rama"].height())
23            project.objects["main"]["editor_textedit"].setFont(LFONT)
24            project.objects["main"]["editor_textedit"].show()
25    
26            project.objects["main"]["editor_textedit"].setWordWrapMode(QtGui.QTextOption.NoWrap)
27    
28            project.objects["main"]["editor_textedit"].textChanged.connect(lambda: Text.function(project))
29    
30            project.objects["main"]["editor_textedit"].setText(text)
31    
32        @staticmethod
33        def function(project):
34            with open(project.selectFile, "w") as file:
35                file.write(project.objects["main"]["editor_textedit"].toPlainText())
36    
##### scr\modules\functions\main\files\__init__.py #####
1     from .config import Config
2     from .object import Object
3     
4     from .scene import Scene, SceneHash, SceneAdditions
5     from .code import Code, CodeHash
6     
7     from .text import Text
8     
9     from .image import Image
10     
11    from .collision import Collision
12    
##### scr\modules\functions\main\__init__.py #####
1     from ..main import files
2     
##### scr\modules\functions\menu\compile.py #####
1     from PyQt5.QtWidgets import QDialog, QPushButton, QTextEdit, QFileDialog, QLineEdit
2     from PyQt5.QtCore import pyqtSignal, QTimer
3     from PyQt5 import QtWidgets, QtCore, Qt
4     
5     from scr.modules import functions
6     
7     from scr.variables import *
8     
9     import subprocess
10     import threading
11    import socket
12    import shutil
13    import json
14    import sys
15    import os
16    
17    PROGRAM = \
18    """# MADE BY GAME ENGINE %ENGINE_VERSION%
19    
20    import tkinter
21    import engine
22    import socket
23    import sys
24    import os
25                
26    root = tkinter.Tk()
27    
28    width = root.winfo_screenwidth()
29    height = root.winfo_screenheight()
30    
31    root.destroy()
32    
33    SOCKET_ID = %SOCKET_ID%
34    
35    VARIABLES = {
36        "globals": %PROJECT_GLOBAL_VARIABLES%,
37        "locals": %PROJECT_LOCAL_VARIABLES%,
38        "objects": %PROJECT_OBJECTS_VARIABLES%
39    }
40    
41    SETTINGS = %PROJECT_SETTINGS%
42    PROGRAMS = %PROJECT_PROGRAMS%
43    OBJECTS = %PROJECT_OBJECTS%
44    SCENES = %PROJECT_SCENES%
45    
46    DEBUG = %DEBUG%
47    
48    %COMPILER%
49    
50    class Tps:
51        def __init__(self, maxTps: int = 20, function: typing.Callable = None):
52            self.maxTps = maxTps
53    
54            self.function = function
55    
56            self.start()
57    
58        def start(self):
59            clock = pygame.time.Clock()
60    
61            while True:
62                clock.tick(self.maxTps)
63    
64                self.function(round(clock.get_fps()))
65    
66    
67    class Game(engine.Application):
68        def __init__(self):
69            global width, height
70        
71            engine.Application.__init__(self)
72    
73            self.objects.collisions = engine.Collision("collision.cfg")
74    
75            self.setDebug(SETTINGS["debug"])
76    
77            self.setSize(SETTINGS["width"], SETTINGS["height"])
78    
79            if SETTINGS["full_screen_mode"]:
80                self.setDisplaySize(width, height)
81            
82            self.setName(SETTINGS["name"])
83            self.setIcon(SETTINGS["icon"])
84    
85            self.setFps(SETTINGS["fps"])
86            self.setTps(SETTINGS["tps"])
87    
88            self.setCamera(engine.camera.StaticCamera(self, 0, 0))
89    
90            self.objectIDByName = {}
91            self.objectNameByID = {}
92    
93            self.scene = None
94    
95            self.loadScene(SETTINGS["start_scene"])
96    
97            self.programs = {}
98    
99            self.allObjects = OBJECTS
100            self.linkEngine = engine
101   
102           self.settings = {"settings": SETTINGS, "programs": PROGRAMS, "scenes": SCENES, "variables": VARIABLES}
103   
104           try:
105               self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
106               self.socket.connect(("localhost", SOCKET_ID))
107           
108           except BaseException:
109               self.socket = None
110           
111           for key, value in PROGRAMS.items():
112               self.programs[key] = Compiler(self, key, value, self.settings, DEBUG)
113   
114           self.counter = threading.Thread(target=lambda: self.tpsStart())
115           self.counter.daemon = True
116           self.counter.start()
117   
118           self.setMouseEvent(0, lambda: self.mouseLeftClick())
119           self.setMouseEvent(2, lambda: self.mouseRightClick())
120   
121           keys = {"click": [], "press": []}
122   
123           for name, program in PROGRAMS.items():
124               for id in self.programs[name].get("keyboardClick"):
125                   node = PROGRAMS[name]["objects"][id]
126   
127                   self.setKeyEvent(["KEYDOWN", node["inputs"]["key"]["standard"]], lambda temp=id: self.programs[name].start(temp))
128   
129           for name, program in PROGRAMS.items():
130               for id in self.programs[name].get("keyboardPress"):
131                   node = PROGRAMS[name]["objects"][id]
132   
133                   self.setKeyEvent(["PRESS", node["inputs"]["key"]["standard"]], lambda temp=id: self.programs[name].start(temp))
134   
135       def print(self, text: str) -> None:
136           if self.socket is not None:
137               self.socket.sendall(text.encode())
138   
139           else:
140               print(text)
141   
142       def update(self) -> None:
143           super().update()
144   
145           for key, value in self.programs.items():
146               if self.programs[key].error:
147                   info = self.programs[key].information
148   
149                   self.print(f"FATAL ERROR: {info['message']}\\n")
150                   self.print(f"Name: {info['display']['name']}\\nX, Y: {info['pos'][0]}, {info['pos'][1]}\\n")
151                   self.print("Inputs:\\n")
152   
153                   text = ""
154   
155                   for code, ivalue in info["inputs"].items():
156                       line = f"{info['display']['text'][ivalue['name']]} = {ivalue['standard'] if ivalue['value'] is None else ivalue['value']}"
157   
158                       text = text + line + "\\n"
159   
160                   self.print(text)
161   
162                   exit(0)
163   
164               self.programs[key].update()
165       
166       def tpsStart(self):
167           def function(tps):
168               for key, value in PROGRAMS.items():
169                   self.programs[key].tps(tps)
170   
171           tps = Tps(SETTINGS["tps"], lambda tps: function(tps))
172   
173       def mouseLeftClick(self):
174           for key, value in PROGRAMS.items():
175               self.programs[key].event("mouseLeftClick")
176               
177       def mouseRightClick(self):
178           for key, value in PROGRAMS.items():
179               self.programs[key].event("mouseRightClick")
180   
181       def loadScene(self, scene):
182           self.objects.empty()
183   
184           self.scene = scene
185   
186           for key, value in SCENES[scene]["objects"].items():
187               type = value["type"]
188               variables = value["variables"]
189               
190               variables["animator"] = engine.Animator(self, None, variables["animation"])
191   
192               obj = getattr(engine.objects, type)(self, **variables)
193               
194               obj.animator.obj = obj
195               
196               obj.animator.init()
197   
198               if scene not in self.objectIDByName:
199                   self.objectIDByName[scene] = {}
200   
201               if scene not in self.objectNameByID:
202                   self.objectNameByID[scene] = {}
203   
204               self.objectIDByName[scene][key] = obj.id
205               self.objectNameByID[scene][str(obj.id)] = key
206   
207               self.objects.add(obj)
208   
209               if SCENES[scene]["focus"] is not None and key == SCENES[scene]["focus"]:
210                   self.setCamera(engine.camera.FocusCamera(self, obj))
211   
212   
213   if __name__ == "__main__":
214       game = Game()
215       game.start()
216   """
217   
218   
219   class LoggerTextEdit(QTextEdit):
220       def __init__(self, project):
221           QTextEdit.__init__(self, project)
222   
223           self.project = project
224   
225       def focusInEvent(self, event):
226           self.project.objects["text"].clearFocus()
227   
228   
229   class Logger(QDialog):
230       logSignal = pyqtSignal(str)
231   
232       def __init__(self, project, name: str) -> None:
233           super().__init__(project)
234   
235           self.project = project
236           self.name = name
237   
238           self.setWindowTitle(translate(name))
239           self.setFixedSize(1000, 625)
240   
241           desktop = QtWidgets.QApplication.desktop()
242           self.move((desktop.width() - self.width()) // 2, (desktop.height() - self.height() - PLUS) // 2)
243   
244           self.objects = {}
245   
246           self.init()
247   
248           self.host = None
249   
250           self.conn = None
251           self.addr = None
252   
253           thr = threading.Thread(target=lambda: self.connect())
254           thr.daemon = True
255           thr.start()
256   
257           self.logSignal.connect(self.send)
258   
259           self.project.objects["main"]["timer"] = QTimer(project)
260           self.project.objects["main"]["timer"].timeout.connect(lambda: self.text())
261           self.project.objects["main"]["timer"].start(1000 // 24)
262   
263       def connect(self) -> None:
264           try:
265               self.host = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
266               self.host.bind(("localhost", SOCKET_ID))
267               self.host.listen(1)
268   
269           except OSError:
270               print("ERROR: can't create socket")
271   
272           try:
273               self.conn, self.addr = self.host.accept()
274   
275           except BaseException:
276               return 0
277   
278           print("LOG: program connected")
279   
280       def init(self) -> None:
281           self.objects["empty"] = QPushButton(parent=self)
282           self.objects["empty"].setGeometry(0, 0, 0, 0)
283   
284           self.objects["text"] = LoggerTextEdit(self)
285           self.objects["text"].setGeometry(10, 10, self.width() - 20, self.height() - 55)
286           self.objects["text"].setTextColor(Qt.Qt.red)
287           self.objects["text"].setFont(FONT)
288           self.objects["text"].show()
289   
290           self.objects["entry"] = QLineEdit(self)
291           self.objects["entry"].setGeometry(10, self.height() - 37, self.width() - 20, 29)
292           self.objects["entry"].setStyleSheet(f"background-color: #{'1c1d1f' if SETTINGS['theme'] == 'dark' else 'ffffff'};")
293           self.objects["entry"].setFont(FONT)
294           self.objects["entry"].show()
295   
296       def text(self) -> None:
297           if self.conn is None:
298               return 0
299   
300           try:
301               data = self.conn.recv(1024)
302   
303           except ConnectionResetError:
304               return 0
305   
306           self.send(data.decode().rstrip())
307   
308       def send(self, text: str) -> None:
309           text = text.replace("FATAL ERROR", translate("FATAL ERROR"))
310   
311           self.objects["text"].append(text)
312   
313       def closeEvent(self, event):
314           self.host.close()
315   
316           event.accept()
317   
318   
319   class Compile:
320       @staticmethod
321       def run(project) -> None:
322           project.compiling = False
323   
324           with open(f"projects/{project.selectProject}/project/project.cfg", "r", encoding="utf-8") as file:
325               projectSettings = load(file)
326   
327           if Compile.compile(project, executable=False):
328               return 1
329   
330           with open(f"projects/{project.selectProject}/scr/{projectSettings['values']['name']['value']}.py", "r", encoding="utf-8") as file:
331               text = file.read()
332   
333           """
334           name = "game"
335           spec = importlib.util.spec_from_loader(name, loader=None)
336   
337           program = importlib.util.module_from_spec(spec)
338   
339           exec(text, program.__dict__)
340   
341           os.chdir(f"projects/{project.selectProject}/scr")
342   
343           game = program.Game()
344           game.start()
345           """
346   
347           # """
348           pathProject = f"projects/{project.selectProject}/scr"
349   
350           pathPython = os.path.abspath(os.path.abspath(sys.argv[0]))
351           pathPython = pathPython[:pathPython.rfind('\\')]
352           pathPython = f"{pathPython}/python/Scripts/python.exe"
353   
354           print(f"LOG: python path: {pathPython}")
355   
356           thr = threading.Thread(target=lambda: os.system(f"cd \"{pathProject}\" && \"{pathPython}\" \"{projectSettings['values']['name']['value']}.py\""))
357           thr.daemon = True
358           thr.start()
359   
360           # """
361   
362           return 0
363   
364       @staticmethod
365       def compile(project, executable: bool = True) -> bool:
366           engine = f"projects/{project.selectProject}/scr/engine"
367   
368           with open(f"projects/{project.selectProject}/project/project.cfg", "r", encoding="utf-8") as file:
369               projectSettings = load(file)
370   
371           names = {
372               "function": f"projects/{project.selectProject}/scr/functions",
373               "assets": f"projects/{project.selectProject}/scr/assets",
374               "files": f"projects/{project.selectProject}/scr/files",
375               "code": f"projects/{project.selectProject}/scr/code",
376               "build": f"projects/{project.selectProject}/scr/build",
377               "dist": f"projects/{project.selectProject}/scr/dict",
378               "collision": f"projects/{project.selectProject}/scr/collision.cfg",
379               "spec": f"projects/{project.selectProject}/scr/{projectSettings['values']['name']['value']}.spec"
380           }
381   
382           if os.path.exists(engine):
383               shutil.rmtree(engine)
384   
385           for name, path in names.items():
386               if os.path.exists(path):
387                   if os.path.isfile(path):
388                       os.remove(path)
389   
390                   else:
391                       shutil.rmtree(path)
392   
393           shutil.copytree("engine", engine)
394   
395           shutil.copytree(f"projects/{project.selectProject}/project/functions", names["function"])
396           shutil.copytree(f"projects/{project.selectProject}/project/assets", names["assets"])
397           shutil.copytree(f"projects/{project.selectProject}/project/files", names["files"])
398           shutil.copytree(f"scr/code", names["code"])
399   
400           shutil.copyfile(f"projects/{project.selectProject}/project/collision.cfg", names["collision"])
401   
402           with open(f"projects/{project.selectProject}/project/project.cfg", "r", encoding="utf-8") as file:
403               projectSettingsCfg = load(file)
404   
405           if f"projects/{project.selectProject}/project/" + projectSettingsCfg["values"]["start_scene"]["value"] == "":
406               MessageBox.error("Project start scene is empty")
407   
408               project.compiling = False
409   
410               return 0
411   
412           output = f"projects/{project.selectProject}/scr/{projectSettingsCfg['values']['name']['value']}.py"
413   
414           # LOAD PROGRAMS AND LOCAL VARIABLES
415   
416           programs = {}
417           locals_variables = {}
418   
419           for program in functions.project.getAllProjectPrograms(project, False):
420               with open(program, "r", encoding="utf-8") as file:
421                   programs[program] = load(file)
422   
423                   locals_variables[program] = programs[program]["variables"]
424   
425           # LOAD SCENES
426   
427           scenes = {}
428           objects_variables = {}
429   
430           for scene in functions.project.getAllProjectScenes(project, False):
431               scenePath = f"projects/{project.selectProject}/project/cash/{'-'.join(scene.split('/')[3:])}-setting.json"
432   
433               objects = {}
434   
435               objects_variables[scene] = {}
436   
437               for element in os.listdir(scene):
438                   objectPath = f"{scene}/{element}"
439   
440                   type, variables = functions.main.files.Scene.loadObjectFile(project, objectPath[:objectPath.rfind(".")][objectPath.rfind("-") + 1:], load(open(objectPath, "r", encoding="utf-8")))
441   
442                   variables["sprite"][0] = variables["sprite"][0].replace(f"projects/{project.selectProject}/project/", "")
443   
444                   objects[element] = {
445                       "type": type,
446                       "variables": variables
447                   }
448   
449                   objects_variables[scene][element] = load(open(objectPath, "r", encoding="utf-8"))["variables"]
450   
451               if os.path.exists(scenePath):
452                   focus = load(open(scenePath, "r", encoding="utf-8"))["Scene"]["focus"]["value"]
453   
454               else:
455                   focus = None
456   
457               if focus is None or focus == "":
458                   project.dialog.send(
459                       translate("WARNING") + ": " + translate("Scene") + f" ({scene}) " + translate("can not download:") + " " + translate("name focus object is not defined")
460                   )
461   
462               else:
463                   scenes[scene] = {
464                       "objects": objects,
465                       "focus": focus
466                   }
467   
468           # LOAD OBJECTS
469   
470           allObjects = {}
471   
472           for obj in functions.project.getAllProjectObjects(project, False):
473               if obj.endswith(".txt"):
474                   continue
475                   
476               type, variables = functions.main.files.Scene.loadObjectFile(project, -1, load(open(obj, "r", encoding="utf-8")))
477   
478               variables["sprite"][0] = variables["sprite"][0].replace(f"projects/{project.selectProject}/project/", "")
479   
480               name = obj.replace(f"projects/{project.selectProject}/project/objects/", "")
481   
482               allObjects[name] = {
483                   "type": type,
484                   "variables": variables
485               }
486   
487           # CAN RUN PROJECT
488   
489           projectSettingsStandard = projectSettings
490           projectSettings = functions.main.files.Config.get(projectSettings)
491   
492           if not any([scene == f"projects/{project.selectProject}/project/" + projectSettings["start_scene"] for scene in scenes.keys()]):
493               project.dialog.logSignal.emit(
494                   translate("ERROR") + ": " + translate("project start scene is not found") + "\n"
495               )
496   
497               project.dialog.logSignal.emit(
498                   translate("LOG") + ": " + translate("can not run project")
499               )
500   
501               project.compiling = False
502   
503               return 1
504   
505           # MAKE PROJECT
506   
507           useProjectSettings = dict(projectSettings)
508           useProjectSettings["start_scene"] = f"projects/{project.selectProject}/project/" + useProjectSettings["start_scene"]
509   
510           program = PROGRAM
511   
512           program = program.replace("%SOCKET_ID%", str(SOCKET_ID))
513   
514           program = program.replace("%PROJECT_GLOBAL_VARIABLES%", str(projectSettingsStandard["variables"]))
515           program = program.replace("%PROJECT_LOCAL_VARIABLES%", str(locals_variables))
516           program = program.replace("%PROJECT_OBJECTS_VARIABLES%", str(objects_variables))
517   
518           program = program.replace("%PROJECT_SETTINGS%", str(useProjectSettings))
519           program = program.replace("%PROJECT_PROGRAMS%", str(programs))
520           program = program.replace("%PROJECT_SCENES%", str(scenes))
521           program = program.replace("%PROJECT_OBJECTS%", str(allObjects))
522   
523           program = program.replace("%ENGINE_VERSION%", str(load(open("scr/files/version.json", encoding="utf-8"))["version"]))
524   
525           program = program.replace("%COMPILER%", str(open("scr/code/compiler.py", "r", encoding="utf-8").read()))
526   
527           program = program.replace("%DEBUG%", str(DIVELOP))
528   
529           with open(output, "w", encoding="utf-8") as file:
530               file.write(program)
531   
532           try:
533               project.dialog.logSignal.emit(
534                   translate("LOG") + ": " + translate("the project has been successfully created")
535               )
536   
537           except AttributeError:
538               pass
539   
540           if executable:
541               try:
542                   project.dialog.logSignal.emit(
543                       translate("LOG") + ": " + translate("compiling...")
544                   )
545   
546               except AttributeError:
547                   pass
548   
549               pathProject = f"projects/{project.selectProject}/scr"
550   
551               pathPython = os.path.abspath(os.path.abspath(sys.argv[0]))
552               pathPython = pathPython[:pathPython.rfind("\\")]
553   
554               pathPythonExecutable = f"{pathPython}/python/Scripts/python.exe"
555               pathPyInstaller = f"{pathPython}/python/Scripts/pyinstaller.exe"
556               pathProgram = os.path.abspath(sys.argv[0])
557   
558               pathProgram = pathProgram[:pathProgram.rfind("\\")]
559   
560               # os.system(f"cd \"{pathProject}\" && {pathPythonExecutable} {pathPyInstaller} -F -w -y \"{projectSettingsCfg['values']['name']['value']}.py\"")
561   
562               command = f"cd \"{pathProgram}\" && cd \"{pathProject}\" && \"{pathPythonExecutable}\" \"{pathPyInstaller}\" -F -w -y \"{projectSettingsCfg['values']['name']['value']}.py\""
563   
564               result = subprocess.run(command, shell=True, capture_output=True, check=True, text=True)
565   
566               project.dialog.logSignal.emit(result.stdout)
567               project.dialog.logSignal.emit(result.stderr)
568   
569               if os.path.exists(f"{pathProject}/{projectSettingsCfg['values']['name']['value']}.exe"):
570                   os.remove(f"{pathProject}/{projectSettingsCfg['values']['name']['value']}.exe")
571   
572               shutil.copy2(f"{pathProject}/dist/{projectSettingsCfg['values']['name']['value']}.exe", f"{pathProject}/{projectSettingsCfg['values']['name']['value']}.exe")
573   
574               try:
575                   project.dialog.logSignal.emit(
576                       translate("LOG") + ": " + translate("the project has been successfully compile")
577                   )
578   
579               except AttributeError:
580                   pass
581   
582           project.compiling = False
583   
584           return 0
585   
586       @staticmethod
587       def compileAndRun(project) -> None:
588           Compile.compile(project)
589   
590           with open(f"projects/{project.selectProject}/project/project.cfg", "r", encoding="utf-8") as file:
591               projectSettings = load(file)
592   
593           path = f"projects/{project.selectProject}/scr"
594   
595           os.system(f"cd {path} && \"{projectSettings['values']['name']['value']}.exe\"")
596   
597           project.compiling = False
598   
599       @staticmethod
600       def saveProject(project) -> None:
601           Compile.compile(project, executable=False)
602   
603           with open(f"projects/{project.selectProject}/project/project.cfg", "r", encoding="utf-8") as file:
604               projectSettings = load(file)
605   
606           path = f"projects/{project.selectProject}"
607   
608           folder = QFileDialog.getExistingDirectory(project, translate("Choose path"), "/home")
609   
610           name = projectSettings["values"]["name"]["value"]
611           index = None
612   
613           if not folder:
614               project.dialog.logSignal.emit(
615                   translate("LOG") + ": " + translate("the path to save the project is not selected")
616               )
617   
618               return 0
619   
620           while os.path.exists(f"{folder}/{name}" if index is None else f"{folder}/{name} ({index})"):
621               if index is None:
622                   index = 1
623   
624               index += 1
625   
626           shutil.copytree(path, f"{folder}/{name}" if index is None else f"{folder}/{name} ({index})")
627   
628           project.dialog.logSignal.emit(
629               translate("LOG") + ": " + translate("project save") + " " + f"({name} ({index}))" if index is not None else f"({name})"
630           )
631   
632       @staticmethod
633       def saveExecutableProject(project) -> None:
634           Compile.compile(project)
635   
636           with open(f"projects/{project.selectProject}/project/project.cfg", "r", encoding="utf-8") as file:
637               projectSettings = json.load(file)
638   
639           path = f"projects/{project.selectProject}/scr"
640   
641           loads = ["functions", "assets", "engine", "files", "code", f"{projectSettings['values']['name']['value']}.py", f"{projectSettings['values']['name']['value']}.exe", "collision.cfg"]
642   
643           folder = QFileDialog.getExistingDirectory(project, translate("Choose path"), "/home")
644   
645           name = projectSettings["values"]["name"]["value"]
646           index = None
647   
648           if not folder:
649               project.dialog.logSignal.emit(
650                   translate("LOG") + ": " + translate("the path to save the project is not selected")
651               )
652   
653               return 0
654   
655           while os.path.exists(f"{folder}/{name}" if index is None else f"{folder}/{name} ({index})"):
656               if index is None:
657                   index = 1
658   
659               index += 1
660   
661           name = f"{folder}/{name}" if index is None else f"{folder}/{name} ({index})"
662   
663           os.mkdir(name)
664   
665           for load in loads:
666               var = f"{path}/{load}"
667   
668               if os.path.isfile(var):
669                   shutil.copyfile(var, f"{name}/{load}")
670   
671               else:
672                   shutil.copytree(var, f"{name}/{load}")
673   
674           project.dialog.logSignal.emit(
675               translate("LOG") + ": " + translate("project save")
676           )
677   
678   
679   def logger(project, name) -> None:
680       try:
681           project.dialog.close()
682   
683       except BaseException:
684           pass
685   
686       project.dialog = Logger(project, name)
687       project.dialog.show()
688   
689   
690   def run(project) -> None:
691       project.compiling = True
692   
693       logger(project, "Run")
694   
695       thr = threading.Thread(target=lambda: Compile.run(project))
696       thr.start()
697   
698   
699   def compile(project) -> None:
700       project.compiling = True
701   
702       logger(project, "Compiling")
703   
704       thr = threading.Thread(target=lambda: Compile.compile(project))
705       thr.start()
706   
707   
708   def compileAndRun(project) -> None:
709       project.compiling = True
710   
711       logger(project, "Compiling")
712   
713       thr = threading.Thread(target=lambda: Compile.compileAndRun(project))
714       thr.start()
715   
716   
717   def saveProject(project) -> None:
718       project.compiling = True
719   
720       logger(project, "Creating")
721   
722       thr = threading.Thread(target=lambda: Compile.saveProject(project))
723       thr.start()
724   
725   
726   def saveExecutableProject(project) -> None:
727       project.compiling = True
728   
729       logger(project, "Compiling")
730   
731       thr = threading.Thread(target=lambda: Compile.saveExecutableProject(project))
732       thr.start()
733   
##### scr\modules\functions\menu\file.py #####
1     from scr.modules.dialogs import CreateProject, CreateFromTemplateProject, OpenProject, Settings
2     
3     from scr.modules import functions
4     
5     
6     def create(project) -> None:
7         project.dialog = CreateProject(project, parent=project)
8         project.dialog.exec_()
9     
10     
11    def createFromTemplate(project) -> None:
12        project.dialog = CreateFromTemplateProject(project, parent=project)
13        project.dialog.exec_()
14    
15    
16    def open(project) -> None:
17        project.dialog = OpenProject(project, parent=project)
18        project.dialog.exec_()
19    
20    
21    def close(project) -> None:
22        for key, value in project.objects.items():
23            try:
24                value.hide()
25    
26            except BaseException:
27                pass
28    
29        if "main" in project.objects:
30            for key, value in project.objects["main"].items():
31                try:
32                    value.hide()
33    
34                except BaseException:
35                    pass
36    
37        else:
38            pass
39    
40        functions.project.projectClose(project)
41    
42        project.menues["project_menu"].setDisabled(True)
43    
44        project.initialization()
45    
46    
47    def settings(project) -> None:
48        project.dialog = Settings(project, parent=project)
49        project.dialog.exec_()
50    
##### scr\modules\functions\menu\help.py #####
1     from PyQt5.QtWidgets import QMessageBox
2     
3     from scr.modules.dialogs import About
4     
5     from scr.variables import *
6     
7     import webbrowser
8     import threading
9     
10     
11    def help_(project) -> None:
12        msg = QMessageBox()
13        msg.setIcon(QMessageBox.Information)
14        msg.setText(translate("Go to the project website?"))
15        msg.setWindowTitle(translate("Go to the site"))
16        msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
17    
18        result = msg.exec_()
19    
20        if result == QMessageBox.Yes:
21            thr = threading.Thread(target=lambda: webbrowser.open("https://artyom7774.github.io"))
22            thr.daemon = True
23            thr.start()
24    
25    
26    def about(project) -> None:
27        project.dialog = About(project, parent=project)
28        project.dialog.exec_()
29    
##### scr\modules\functions\menu\__init__.py #####
1     from ..menu import file
2     from ..menu import help
3     from ..menu import compile
4     
##### scr\modules\functions\project.py #####
1     from PyQt5.Qt import QIcon, QTreeWidgetItem, QMenu, QAction
2     from PyQt5 import QtWidgets
3     
4     from scr.modules import functions
5     
6     from scr.variables import *
7     
8     import requests
9     import typing
10     import shutil
11    import os
12    import re
13    
14    
15    def getAllProjectObjects(project, onlyFileName: bool = False) -> typing.List[str]:
16        answer = []
17    
18        queue = os.listdir(f"projects/{project.selectProject}/project/objects/")
19    
20        while len(queue) > 0:
21            path = f"projects/{project.selectProject}/project/objects/{queue[0]}"
22    
23            if os.path.isfile(path):
24                if not path.endswith("EMPTY.txt"):
25                    answer.append(path)
26    
27            else:
28                for element in os.listdir(path):
29                    queue.append(queue[0] + "/" + element)
30    
31            queue.pop(0)
32    
33        return answer if not onlyFileName else [element[element.rfind("/") + 1:] for element in answer]
34    
35    
36    def getAllProjectScenes(project, onlyFileName: bool = False) -> typing.List[str]:
37        answer = []
38    
39        queue = os.listdir(f"projects/{project.selectProject}/project/scenes/")
40    
41        while len(queue) > 0:
42            path = f"projects/{project.selectProject}/project/scenes/{queue[0]}"
43    
44            if queue[0].endswith("EMPTY.txt"):
45                queue.pop(0)
46    
47                continue
48    
49            if path[path.rfind("/"):].find("%scene%") != -1:
50                answer.append(path)
51    
52            else:
53                for element in os.listdir(path):
54                    queue.append(queue[0] + "/" + element)
55    
56            queue.pop(0)
57    
58        return answer if not onlyFileName else [element[element.rfind("/") + 1:] for element in answer]
59    
60    
61    def getAllProjectPrograms(project, onlyFileName: bool = False) -> typing.List[str]:
62        answer = []
63    
64        queue = os.listdir(f"projects/{project.selectProject}/project/functions/")
65    
66        while len(queue) > 0:
67            path = f"projects/{project.selectProject}/project/functions/{queue[0]}"
68    
69            if os.path.isfile(path):
70                if not path.endswith("EMPTY.txt"):
71                    try:
72                        load(open(path, "r", encoding="utf-8"))
73    
74                    except BaseException:
75                        pass
76    
77                    else:
78                        answer.append(path)
79    
80            else:
81                for element in os.listdir(path):
82                    queue.append(queue[0] + "/" + element)
83    
84            queue.pop(0)
85    
86        return answer if not onlyFileName else [element[element.rfind("/") + 1:] for element in answer]
87    
88    
89    def createProjectDirecroryByTemplate(project, name: str, template: str) -> None:
90        shutil.copytree(f"scr/files/templates/{template}", f"projects/{name}/")
91    
92        shutil.copytree("engine/", f"projects/{name}/engine/")
93    
94        queue = os.listdir(f"projects/{name}/")
95    
96        while len(queue) > 0:
97            path = f"projects/{name}/{queue[0]}"
98    
99            if os.path.isfile(path):
100                if path.endswith("EMPTY.txt"):
101                   pass
102   
103           else:
104               for element in os.listdir(path):
105                   queue.append(queue[0] + "/" + element)
106   
107           queue.pop(0)
108   
109       project.selectProject = name
110   
111       project.init()
112   
113   
114   def createProjectDirectory(project, name: str) -> None:
115       shutil.copytree("scr/base/", f"projects/{name}/")
116   
117       shutil.copytree("engine/", f"projects/{name}/engine/")
118   
119       queue = os.listdir(f"projects/{name}/")
120   
121       while len(queue) > 0:
122           path = f"projects/{name}/{queue[0]}"
123   
124           if os.path.isfile(path):
125               if path.endswith("EMPTY.txt"):
126                   pass
127   
128           else:
129               for element in os.listdir(path):
130                   queue.append(queue[0] + "/" + element)
131   
132           queue.pop(0)
133   
134       project.selectProject = name
135   
136       project.init()
137   
138   
139   def haveInternet():
140       try:
141           response = requests.get('http://www.google.com', timeout=1)
142   
143       except:
144           return False
145   
146       return True
147   
148   
149   def projectTreeGetPath(obj, path: list = None, deep: int = 0) -> list:
150       if path is None:
151           path = []
152   
153       if obj.parent() is not None:
154           path = projectTreeGetPath(obj.parent(), path + [obj.parent().text(0)], deep + 1)
155   
156       if deep == 0:
157           path = path[::-1] + [obj.text(0)]
158   
159           answer = []
160   
161           for element in path:
162               if os.path.exists(projectTreeGetFilePath(answer + [element])):
163                   answer.append(element)
164   
165               else:
166                   for name in os.listdir(projectTreeGetFilePath(answer)):
167                       if re.sub("%.*?%", "", name) == element:
168                           answer.append(name)
169                           break
170   
171           return answer
172   
173       else:
174           return path
175   
176   
177   def projectTreeGetFilePath(path: list) -> str:
178       return "projects/" + path[0] + "/project/" + "/".join(path[1:])
179   
180   
181   def projectTreeOpenDir(project, obj) -> None:
182       path = projectTreeGetPath(obj)
183   
184       if len(path) == 1:
185           return 0
186   
187       project.objects["project_tree_file_opened"]["/".join(path[1:])] = True
188   
189   
190   def projectTreeCloseDir(project, obj) -> None:
191       path = projectTreeGetPath(obj)
192   
193       if len(path) == 1:
194           return 0
195   
196       project.objects["project_tree_file_opened"]["/".join(path[1:])] = False
197   
198   
199   def projectTreeProjectMenuInit(project) -> typing.Dict[str, bool]:
200       answer = {
201           "open": True,
202           "copy": True,
203           "paste": True,
204           "rename": True,
205           "remove": True
206       }
207   
208       if len(project.objects["tree_project"].selectedItems()) == 0:
209           for key, value in answer.items():
210               answer[key] = False
211   
212           return answer
213   
214       path = projectTreeGetPath(project.objects["tree_project"].selectedItems()[0])
215   
216       if os.path.isdir(projectTreeGetFilePath(path)):
217           answer["open"] = False
218   
219       if len(path) <= 1 or os.path.isfile(projectTreeGetFilePath(path)):
220           answer["paste"] = False
221   
222       if len(path) <= 2:
223           answer["rename"] = False
224           answer["remove"] = False
225   
226       return answer
227   
228   
229   def getColor(name: str) -> str:
230       return SPRITES[name] if ((SETTINGS["theme"] == "dark") or (f"{name}-light" not in SPRITES)) else SPRITES[f"{name}-light"]
231   
232   
233   def projectTreeProjectMenuOpen(project, position) -> None:
234       if len(project.objects["tree_project"].selectedItems()) > 0:
235           path = projectTreeGetPath(project.objects["tree_project"].selectedItems()[0])
236   
237           # CREATE MENU
238   
239           project.objects["tree_project_menu"] = QMenu()
240   
241           project.objects["tree_project_menu_new_menu"] = QMenu(translate("New"), project)
242   
243           if len(path) > 1:
244               project.objects["tree_project_menu_new_menu_dir_action"] = QAction(translate("Directory"), project)
245               project.objects["tree_project_menu_new_menu_dir_action"].setIcon(QIcon(getColor("dir")))
246               project.objects["tree_project_menu_new_menu_dir_action"].triggered.connect(lambda: functions.tree.createDir(project))
247               project.objects["tree_project_menu_new_menu"].addAction(project.objects["tree_project_menu_new_menu_dir_action"])
248   
249               project.objects["tree_project_menu_new_menu"].addSeparator()
250   
251           if len(path) > 1 and path[1] == "scenes":
252               if "/".join(path).find("%scene%") == -1:
253                   project.objects["tree_project_menu_new_menu_scene_action"] = QAction(translate("Scene"), project)
254                   project.objects["tree_project_menu_new_menu_scene_action"].setIcon(QIcon(getColor("scene")))
255                   project.objects["tree_project_menu_new_menu_scene_action"].triggered.connect(lambda: functions.tree.createScene(project))
256                   project.objects["tree_project_menu_new_menu"].addAction(project.objects["tree_project_menu_new_menu_scene_action"])
257   
258           if len(path) > 1 and path[1] == "functions":
259               project.objects["tree_project_menu_new_menu_function_action"] = QAction(translate("Function"), project)
260               project.objects["tree_project_menu_new_menu_function_action"].setIcon(QIcon(getColor("func")))
261               project.objects["tree_project_menu_new_menu_function_action"].triggered.connect(lambda: functions.tree.createFunction(project))
262               project.objects["tree_project_menu_new_menu"].addAction(project.objects["tree_project_menu_new_menu_function_action"])
263   
264           if len(path) > 1 and path[1] == "objects":
265               project.objects["tree_project_menu_new_menu_object_action"] = QAction(translate("Object"), project)
266               project.objects["tree_project_menu_new_menu_object_action"].setIcon(QIcon(getColor("obj")))
267               project.objects["tree_project_menu_new_menu_object_action"].triggered.connect(lambda: functions.tree.createObject(project))
268               project.objects["tree_project_menu_new_menu"].addAction(project.objects["tree_project_menu_new_menu_object_action"])
269   
270           if len(path) > 1:
271               project.objects["tree_project_menu_new_menu_file_action"] = QAction(translate("File"), project)
272               project.objects["tree_project_menu_new_menu_file_action"].setIcon(QIcon(getColor("file")))
273               project.objects["tree_project_menu_new_menu_file_action"].triggered.connect(lambda: functions.tree.createFile(project))
274               project.objects["tree_project_menu_new_menu"].addAction(project.objects["tree_project_menu_new_menu_file_action"])
275   
276           if "/".join(path).find("%scene%") != -1:
277               project.objects["tree_project_menu_new_menu"].setDisabled(True)
278   
279           project.objects["tree_project_menu_open_action"] = QAction(translate("Open"), project)
280           project.objects["tree_project_menu_copy_action"] = QAction(translate("Copy"), project)
281           project.objects["tree_project_menu_paste_action"] = QAction(translate("Paste"), project)
282           project.objects["tree_project_menu_rename_action"] = QAction(translate("Rename"), project)
283           project.objects["tree_project_menu_remove_action"] = QAction(translate("Delete"), project)
284   
285           project.objects["tree_project_menu_open_action"].triggered.connect(lambda: functions.tree.open(project))
286           project.objects["tree_project_menu_copy_action"].triggered.connect(lambda: functions.tree.copy(project))
287           project.objects["tree_project_menu_paste_action"].triggered.connect(lambda: functions.tree.paste(project))
288           project.objects["tree_project_menu_rename_action"].triggered.connect(lambda: functions.tree.rename(project))
289           project.objects["tree_project_menu_remove_action"].triggered.connect(lambda: functions.tree.remove(project))
290   
291           project.objects["tree_project_menu"].addAction(project.objects["tree_project_menu_open_action"])
292           project.objects["tree_project_menu"].addAction(project.objects["tree_project_menu_copy_action"])
293           project.objects["tree_project_menu"].addAction(project.objects["tree_project_menu_paste_action"])
294           project.objects["tree_project_menu"].addSeparator()
295           project.objects["tree_project_menu"].addMenu(project.objects["tree_project_menu_new_menu"])
296           project.objects["tree_project_menu"].addSeparator()
297           project.objects["tree_project_menu"].addAction(project.objects["tree_project_menu_rename_action"])
298           project.objects["tree_project_menu"].addAction(project.objects["tree_project_menu_remove_action"])
299   
300           # DISABLE BUTTONS
301   
302           if len(path) <= 1 or ("/".join(path).find("%scene%") == -1 and not os.path.isdir(projectTreeGetFilePath(path))):
303               project.objects["tree_project_menu_new_menu"].setDisabled(True)
304   
305           if os.path.isdir(projectTreeGetFilePath(path)) and "/".join(path).find("%scene%") == -1:
306               project.objects["tree_project_menu_open_action"].setDisabled(True)
307   
308           if len(path) <= 1 or os.path.isfile(projectTreeGetFilePath(path)):
309               project.objects["tree_project_menu_paste_action"].setDisabled(True)
310   
311           if len(path) <= 2:
312               if not os.path.isdir(projectTreeGetFilePath(path)):
313                   project.objects["tree_project_menu_new_menu"].setDisabled(True)
314   
315               project.objects["tree_project_menu_rename_action"].setDisabled(True)
316               project.objects["tree_project_menu_remove_action"].setDisabled(True)
317   
318           project.cash["tree_menu_focus"] = project.objects["tree_project"].selectedItems()[0]
319           project.objects["tree_project_menu"].popup(project.objects["tree_project"].mapToGlobal(position)) if project.objects["tree_project"].selectedItems() else None
320   
321   
322   def SaveAllObjectsValues(project) -> None:
323       for key, value in project.objects["main"].items():
324           try:
325               if hasattr(value, "saveAllValues"):
326                   value.saveAllValues(value, project)
327   
328           except RuntimeError:
329               pass
330   
331   
332   def centerMenuInit(project, update: bool = False) -> None:
333       if "main" not in project.objects:
334           project.objects["main"] = {}
335   
336       try:
337           if "main" in project.objects and "object_variables" in project.objects["main"]:
338               try:
339                   project.objects["main"]["object_variables"].hide()
340   
341                   project.objects["main"]["object_variables"].deleteLater()
342   
343               except RuntimeError:
344                   pass
345   
346           if "main" in project.objects and "variables" in project.objects["main"]:
347               for element in project.objects["main"]["variables"].values():
348                   try:
349                       element.hide()
350   
351                       element.deleteLater()
352   
353                   except RuntimeError:
354                       pass
355   
356       except BaseException:
357           pass
358   
359       # if "main" in project.objects and "code" in project.objects["main"]:
360       #     project.objects["main"]["code"].hide()
361       #
362       #     project.objects["main"]["code"].deleteLater()
363   
364       if project.selectFile != "" or update:
365           SaveAllObjectsValues(project)
366   
367           for key, value in project.objects["main"].items():
368               if key.find("timer") != -1:
369                   try:
370                       value.stop()
371   
372                   except BaseException:
373                       pass
374   
375               try:
376                   value.deleteLater()
377   
378               except BaseException:
379                   pass
380   
381           """
382           rem = []
383   
384           for key, value in project.cash["file"].items():
385               if key == project.selectFile:
386                   continue
387   
388               else:
389   
390                   rem.append(key)
391   
392           for element in rem:
393               project.cash["file"].pop(element)
394           """
395   
396           if os.path.isdir(project.selectFile) and project.selectFile.find("%scene%") != -1:
397               if project.selectFile not in project.cash["file"]:
398                   project.cash["file"][project.selectFile] = functions.main.files.SceneHash()
399   
400           if project.selectFile.endswith(".func"):
401               if project.selectFile not in project.cash["file"]:
402                   project.cash["file"][project.selectFile] = functions.main.files.CodeHash()
403   
404           # TESTS
405   
406           functions.main.files.Config.test(project)
407           functions.main.files.Scene.test(project)
408   
409           # OPEN
410   
411           if project.selectFile.endswith(".cfg") and not project.selectFile.endswith("collision.cfg"):
412               functions.main.files.Config.init(project)
413   
414           elif project.selectFile.endswith("collision.cfg"):
415               functions.main.files.Collision.init(project)
416   
417           elif project.selectFile.endswith(".obj") or project.selectFile.endswith(".objc"):
418               functions.main.files.Object.init(project)
419   
420           elif any([project.selectFile.endswith(element) for element in IMAGE_FORMATES]):
421               functions.main.files.Image.init(project)
422   
423           elif os.path.isdir(project.selectFile) and project.selectFile[project.selectFile.rfind("/"):].find("%scene%") != -1:
424               functions.main.files.Scene.init(project)
425   
426           elif project.selectFile.endswith(".func"):
427               functions.main.files.Code.init(project)
428   
429           else:
430               functions.main.files.Text.init(project)
431   
432   
433   def projectTreeInit(project) -> None:
434       project.objects["tree_project"].clear()
435   
436       project.objects["tree_project_main"] = QTreeWidgetItem(project.objects["tree_project"])
437       project.objects["tree_project_main"].setIcon(0, QIcon(getColor("dir")))
438       project.objects["tree_project_main"].setText(0, project.selectProject)
439       project.objects["tree_project_main"].setExpanded(True)
440   
441       project.objects["project_tree_file_objects"] = {}
442   
443       directory = "projects/" + project.selectProject + "/project/"
444   
445       queue = [[file, "file" if os.path.isfile(directory + file) else "dir"] for file in os.listdir(directory)]
446       queue.sort(key=lambda x: x[1] == "dir", reverse=True)
447   
448       while len(queue) > 0:
449           path = f"{queue[0][0].replace(directory, '')}"
450   
451           if not os.path.isfile(directory + queue[0][0]):
452               for file in os.listdir(directory + queue[0][0]):
453                   queue.append([queue[0][0] + "/" + file, "file" if os.path.isfile(directory + "/" + queue[0][0] + "/" + file) else "dir"])
454   
455               queue.pop(0)
456               queue.sort(key=lambda x: x[1] == "dir", reverse=True)
457   
458               if path not in project.objects["project_tree_file_opened"]:
459                   project.objects["project_tree_file_opened"][path] = False
460   
461               project.objects["project_tree_file_objects"][path] = QtWidgets.QTreeWidgetItem(project.objects["project_tree_file_objects"][path[:path.rfind("/")]] if project.objects["project_tree_file_objects"].get(path[:path.rfind("/")]) is not None else project.objects["tree_project_main"])
462               project.objects["project_tree_file_objects"][path].setFlags(project.objects["project_tree_file_objects"][path].flags())
463               project.objects["project_tree_file_objects"][path].setText(0, re.sub(r"%.*?%", "", path[path.rfind("/"):].replace("/", "") if path.find("/") != -1 else path))
464   
465               if path[path.rfind("/") + 1:].find("%scene%") != -1:
466                   project.objects["project_tree_file_objects"][path].setIcon(0, QIcon(getColor("scene")))
467   
468               else:
469                   project.objects["project_tree_file_objects"][path].setIcon(0, QIcon(getColor("dir")))
470   
471               project.objects["project_tree_file_objects"][path].setExpanded(project.objects["project_tree_file_opened"][path])
472   
473               project.objects["tree_project"].addTopLevelItem(project.objects["project_tree_file_objects"][path])
474   
475           else:
476               queue.pop(0)
477   
478               if path[path.rfind("/") + 1:] in ("NULL.txt", "NOTHING.txt", "EMPTY.txt"):
479                   continue
480   
481               if path not in project.objects["project_tree_file_opened"]:
482                   project.objects["project_tree_file_opened"][path] = False
483   
484               if path[:path.rfind("/")] not in project.objects["project_tree_file_objects"]:
485                   project.objects["project_tree_file_objects"][path] = QtWidgets.QTreeWidgetItem(project.objects["tree_project_main"])
486   
487               else:
488                   project.objects["project_tree_file_objects"][path] = QtWidgets.QTreeWidgetItem(project.objects["project_tree_file_objects"][path[:path.rfind('/')]])
489   
490               project.objects["project_tree_file_objects"][path].setFlags(project.objects["project_tree_file_objects"][path].flags())
491               project.objects["project_tree_file_objects"][path].setText(0, path.split("/")[-1])
492   
493               if path[path.rfind(".") + 1:] in SPRITES:
494                   project.objects["project_tree_file_objects"][path].setIcon(0, QIcon(getColor(path[path.rfind(".") + 1:])))
495   
496               else:
497                   project.objects["project_tree_file_objects"][path].setIcon(0, QIcon(getColor("file")))
498   
499               project.objects["project_tree_file_objects"][path].setExpanded(project.objects["project_tree_file_opened"][path])
500   
501               project.objects["tree_project"].addTopLevelItem(project.objects["project_tree_file_objects"][path])
502   
503   
504   def projectOpen(project) -> None:
505       project.menues["project_menu"].setDisabled(False)
506   
507       project.variables = {}
508       project.cash = {"file": {}}
509   
510       project.objects["tab_file_bar"].removeAll()
511   
512       project.application = {}
513   
514       project.engine = loader(f"engine/__init__.py")
515   
516   
517   def projectClose(project) -> None:
518       project.menues["project_menu"].setDisabled(True)
519   
520       project.initialization()
521   
522   
##### scr\modules\functions\tree.py #####
1     from PyQt5.Qt import QIcon
2     
3     from scr.modules.dialogs import CreateDir, CreateScene, CreateFunction, CreateFile, RenameObject, CreateObject
4     
5     from scr.modules.functions.project import projectTreeGetPath, projectTreeGetFilePath, getColor
6     
7     from scr.variables import *
8     
9     try:
10         import win32clipboard
11    
12    except BaseException:
13        win32clipboard = None
14    
15    import subprocess
16    import shutil
17    import typing
18    import os
19    import re
20    
21    
22    def createDir(project) -> None:
23        project.dialog = CreateDir(project, parent=project)
24        project.dialog.exec_()
25    
26    
27    def createScene(project) -> None:
28        project.dialog = CreateScene(project, parent=project)
29        project.dialog.exec_()
30    
31    
32    def createFunction(project) -> None:
33        project.dialog = CreateFunction(project, parent=project)
34        project.dialog.exec_()
35    
36    
37    def createFile(project) -> None:
38        project.dialog = CreateFile(project, parent=project)
39        project.dialog.exec_()
40    
41    
42    def createObject(project) -> None:
43        project.dialog = CreateObject(project, parent=project)
44        project.dialog.exec_()
45    
46    
47    def open(project, path: str = None) -> None:
48        update = True
49    
50        if path is None:
51            path = projectTreeGetFilePath(projectTreeGetPath(project.objects["tree_project"].selectedItems()[0]))
52    
53        else:
54            update = False
55    
56        if os.path.isdir(path) and path.find("%scene%") == -1:
57            return 0
58    
59        if any([path.endswith(element) for element in DONT_OPEN_FORMATES]):
60            MessageBox.imposiable("Can't open this file")
61    
62            return 0
63    
64        icon = (getColor("scene") if path.find("%scene%") != -1 else getColor("dir")) if os.path.isdir(path) else (getColor(path[path.rfind(".") + 1:]) if path[path.rfind(".") + 1:] in SPRITES else getColor("file"))
65    
66        if update:
67            project.objects["tab_file_bar"].add(path, re.sub("%.*?%", "", path[path.rfind("/") + 1:]), QIcon(icon))
68    
69        project.selectFile = path
70    
71        project.init()
72    
73    
74    def rename(project) -> None:
75        project.dialog = RenameObject(project, parent=project)
76        project.dialog.exec_()
77    
78    
79    def remove(project) -> None:
80        path = projectTreeGetFilePath(projectTreeGetPath(project.objects["tree_project"].selectedItems()[0]))
81    
82        if path == project.selectFile:
83            project.selectFile = ""
84    
85        if any([element["name"] == path for element in project.objects["tab_file_bar"].objects]):
86            project.objects["tab_file_bar"].remove(path)
87    
88        # DELETE
89    
90        if os.path.isfile(path):
91            os.remove(path)
92    
93        else:
94            shutil.rmtree(path)
95    
96        project.init()
97    
98    
99    def copy(project) -> None:
100        path = projectTreeGetFilePath(projectTreeGetPath(project.objects["tree_project"].selectedItems()[0]))
101   
102       if SYSTEM == "Windows":
103           os.system(f"powershell -command \"Get-Item \"{os.getcwd()}/{path}\" | Set-Clipboard\"")
104   
105       elif SYSTEM == "Linux":
106           os.system(f"echo -n '{os.path.join(os.getcwd(), path)}' | xclip -selection clipboard")
107   
108       else:
109           print("ERROR: system (Unknown) not supported this operation")
110   
111   
112   def paste(project) -> None:
113       def WindowsGetPath() -> typing.Any:
114           try:
115               win32clipboard.OpenClipboard()
116   
117               if win32clipboard.IsClipboardFormatAvailable(win32clipboard.CF_HDROP):
118                   return win32clipboard.GetClipboardData(win32clipboard.CF_HDROP)[0]
119   
120               else:
121                   return None
122   
123           finally:
124               win32clipboard.CloseClipboard()
125   
126       def LinuxGetPath() -> typing.Any:
127           try:
128               result = subprocess.check_output("xclip -o -selection clipboard", shell=True).decode('utf-8').strip()
129   
130               if os.path.exists(result):
131                   return result
132   
133               else:
134                   return None
135   
136           except Exception as e:
137               print(f"ERROR: can't getting clipboard data: {e}")
138   
139               return None
140   
141       def createCopyFile(path) -> str:
142           index = 1
143   
144           name = path[:path.rfind(".")]
145           extension = path.replace(f"{name}.", "")
146   
147           while True:
148               if not os.path.exists(name + f" ({index})" + "." + extension):
149                   return name + f" ({index})" + "." + extension
150   
151               index += 1
152   
153       if SYSTEM == "Windows":
154           input = WindowsGetPath()
155   
156       elif SYSTEM == "Linux":
157           input = LinuxGetPath()
158   
159           print("ERROR: system (Linux) not supported this operation")
160           return 0
161   
162       else:
163           print("ERROR: system (Unknown) not supported this operation")
164           return 0
165   
166       output = projectTreeGetFilePath(projectTreeGetPath(project.objects["tree_project"].selectedItems()[0]))
167   
168       if input is None:
169           MessageBox.imposiable("copy is not found")
170   
171           return 0
172   
173       else:
174           pass
175   
176       path = output + "/" + input[input.rfind("\\") + 1:]
177   
178       if os.path.isfile(input):
179           try:
180               if not os.path.exists(path):
181                   shutil.copyfile(input, path)
182   
183               else:
184                   shutil.copyfile(input, createCopyFile(path))
185   
186           except shutil.SameFileError:
187               print(createCopyFile(path))
188   
189               shutil.copyfile(input, createCopyFile(path))
190   
191           except BaseException as e:
192               MessageBox.imposiable(e)
193   
194       else:
195           try:
196               if not os.path.exists(path):
197                   shutil.copytree(input, path)
198   
199               else:
200                   shutil.copytree(input, createCopyFile(path))
201   
202           except shutil.SameFileError:
203               shutil.copytree(input, createCopyFile(path))
204   
205           except RecursionError:
206               MessageBox.imposiable("The target directory is inside the source directory")
207   
208               shutil.rmtree(path)
209   
210           except BaseException as e:
211               MessageBox.imposiable(e)
212   
213       project.init()
214   
##### scr\modules\functions\__init__.py #####
1     from ..functions import project
2     from .project import *
3     
4     from .tree import *
5     
6     from .menu import *
7     from .main import *
8     
##### scr\modules\translate.py #####
1     import hjson
2     import os
3     
4     
5     class Translate:
6         def __init__(self, lang: str) -> None:
7             self.lang = lang
8     
9             self.out = {}
10     
11        def __call__(self, *args) -> None:
12            return self.translate(args[0])
13    
14        def update(self, lang: str) -> None:
15            self.lang = lang
16    
17        def translate(self, word: str) -> str:
18            if len(word) == 0:
19                return ""
20    
21            point = False
22    
23            if word[0] == "-":
24                word = word[1:]
25    
26                point = True
27    
28            spaces = 0
29    
30            while word[0] == " ":
31                word = word[1:]
32    
33                spaces += 1
34    
35            if not os.path.exists(f"scr/files/bundles/{self.lang.lower()}.hjson") and self.lang == "EN":
36                return word
37    
38            if self.lang not in self.out:
39                self.out[self.lang] = hjson.load(open(f"scr/files/bundles/{self.lang.lower()}.hjson", encoding="utf-8"))
40    
41            if " " * spaces + word in self.out[self.lang]:
42                return self.out[self.lang][" " * spaces + word]
43    
44            elif word in self.out[self.lang]:
45                answer = self.out[self.lang][word]
46    
47            else:
48                answer = word
49    
50            return ("•" if point else "") + " " * spaces + answer
51    
##### scr\modules\widgets\collisionTable.py #####
1     from PyQt5.QtWidgets import QTableWidget, QTableWidgetItem, QCheckBox, QWidget, QVBoxLayout, QHeaderView, QLabel
2     from PyQt5.QtCore import Qt
3     from PyQt5.QtGui import QFontMetrics, QPixmap, QPainter, QPen, QColor
4     
5     from engine.functions.loads import loadCollisionFile
6     
7     from scr.variables import *
8     
9     import typing
10     
11    
12    class CollisionTable(QTableWidget):
13        def __init__(self, parent, groups: typing.List[str], function: typing.Callable) -> None:
14            QTableWidget.__init__(self, len(groups), len(groups), parent)
15    
16            self.project = parent
17    
18            var = loadCollisionFile(self.project.selectFile)
19    
20            collisions = {}
21    
22            for key, value in var.items():
23                collisions[key] = list(value.keys())
24    
25            self.setHorizontalHeaderLabels(groups)
26            self.setVerticalHeaderLabels(groups)
27    
28            header = self.horizontalHeader()
29            header.setSectionResizeMode(QHeaderView.Fixed)
30    
31            self.widths = {}
32    
33            metrics = QFontMetrics(self.font())
34    
35            width = 0
36    
37            for col, group in enumerate(groups):
38                width = max(width, metrics.width(group) + 40)
39    
40            for col, group in enumerate(groups):
41                self.setColumnWidth(col, width)
42    
43                self.widths[str(col)] = width
44    
45            for row in range(len(groups)):
46                for col in range(len(groups)):
47                    check = QCheckBox()
48    
49                    check.setChecked(groups[row] in collisions and groups[col] in collisions[groups[row]])
50    
51                    check.stateChanged.connect(lambda state="", empty=None, x=row, y=col: function(self.project, x, y, 0 if state == 0 else 1))
52    
53                    check.setMinimumSize(24, 24)
54                    check.setMaximumSize(24, 24)
55    
56                    widget = QWidget()
57    
58                    layout = QVBoxLayout()
59    
60                    if row == col and False:
61                        cross = QLabel()
62                        cross.setPixmap(CollisionTable.createСrossPixMap(self.widths[str(col)] - 1, 40 - 1))
63    
64                        layout.addWidget(cross)
65    
66                    else:
67                        layout.addWidget(check)
68    
69                    layout.setAlignment(Qt.AlignCenter)
70                    layout.setContentsMargins(0, 0, 0, 0)
71    
72                    widget.setLayout(layout)
73    
74                    self.setCellWidget(row, col, widget)
75    
76                    self.setItem(row, col, QTableWidgetItem())
77    
78            self.setStyleSheet(f"background-color: #{'202124' if SETTINGS['theme'] == 'dark' else 'f8f9fa'};")
79    
80        @staticmethod
81        def createСrossPixMap(width: int, height: int) -> QPixmap:
82            pixmap = QPixmap(width, height)
83            pixmap.fill(QColor(f"#{'202124' if SETTINGS['theme'] == 'dark' else 'f8f9fa'}"))
84    
85            # painter = QPainter(pixmap)
86            # pen = QPen(QColor("#3f4042"), 1)
87            # painter.setPen(pen)
88    
89            # painter.drawLine(-2, 0, width + 3, height)
90            # painter.drawLine(width, 0, -5, height)
91    
92            # painter.end()
93    
94            return pixmap
95    
##### scr\modules\widgets\focusComboBox.py #####
1     from PyQt5.QtWidgets import QComboBox
2     
3     import typing
4     
5     
6     class FocusComboBox(QComboBox):
7         def __init__(
8             self, parent=None, connectFocusFunction: typing.Callable = None, releasedFocusFunction: typing.Callable = None
9         ) -> None:
10             QComboBox.__init__(self, parent)
11    
12            self.connectFocusFunction = connectFocusFunction
13            self.releasedFocusFunction = releasedFocusFunction
14    
15        def focusOutEvent(self, event) -> None:
16            super().focusOutEvent(event)
17    
18            if self.releasedFocusFunction is not None:
19                self.releasedFocusFunction()
20    
21        def focusInEvent(self, event) -> None:
22            super().focusInEvent(event)
23    
24            if self.connectFocusFunction is not None:
25                self.connectFocusFunction()
26    
##### scr\modules\widgets\focusLineEdit.py #####
1     from PyQt5.QtWidgets import QLineEdit
2     
3     import typing
4     
5     
6     class FocusLineEdit(QLineEdit):
7         def __init__(
8             self, parent=None, connectFocusFunction: typing.Callable = None, releasedFocusFunction: typing.Callable = None
9         ) -> None:
10             QLineEdit.__init__(self, parent)
11    
12            self.connectFocusFunction = connectFocusFunction
13            self.releasedFocusFunction = releasedFocusFunction
14    
15        def focusOutEvent(self, event) -> None:
16            super().focusOutEvent(event)
17    
18            if self.releasedFocusFunction is not None:
19                self.releasedFocusFunction()
20    
21        def focusInEvent(self, event) -> None:
22            super().focusInEvent(event)
23    
24            if self.connectFocusFunction is not None:
25                self.connectFocusFunction()
26    
##### scr\modules\widgets\tabFileBar.py #####
1     from PyQt5.QtWidgets import QTabBar
2     from PyQt5.QtGui import QIcon
3     
4     from scr.modules import functions
5     
6     from scr.variables import *
7     
8     import typing
9     
10     
11    class TabFileBar(QTabBar):
12        def __init__(self, project, parent=None) -> None:
13            super().__init__(parent)
14    
15            self.project = project
16    
17            self.setTabsClosable(True)
18            self.setExpanding(False)
19    
20            self.setFont(FONT)
21    
22            self.objects = []
23    
24            self.tabCloseRequested.connect(self.pop)
25    
26        def get(self) -> typing.Dict[str, typing.Dict[str, typing.Union[int, str]]]:
27            return self.objects
28    
29        def getNameByIndex(self, index: int):
30            try:
31                return self.objects[index]["name"]
32    
33            except IndexError:
34                return -1
35    
36        def add(self, name: str, visiable: str, icon: QIcon = None) -> int:
37            if any([element["name"] == name for element in self.objects]):
38                self.setCurrentIndex([element["name"] == name for element in self.objects].index(True))
39    
40                return 0
41    
42            index = super().addTab(visiable)
43    
44            self.objects.append({
45                "name": name,
46                "visiable": visiable
47            })
48    
49            self.updateSelectFile()
50    
51            self.setTabIcon(index, icon if icon else QIcon())
52            self.setTabText(index, visiable)
53    
54            self.setCurrentIndex([element["name"] == name for element in self.objects].index(True))
55    
56            return index
57    
58        def remove(self, name: str) -> None:
59            for i, value in enumerate(self.objects):
60                if value["name"] == name:
61                    self.pop(i)
62    
63                    return 0
64    
65        def removeAll(self) -> None:
66            for _ in range(len(self.objects)):
67                self.pop(0)
68    
69        def updateSelectFile(self) -> None:
70            if self.count() == 0:
71                self.project.objects["status_bar"].showMessage("")
72    
73                self.project.selectFile = ""
74    
75            elif self.count() == 1:
76                self.project.selectFile = self.objects[0]["name"]
77    
78            else:
79                self.project.selectFile = self.objects[self.currentIndex()]["name"]
80    
81        def pop(self, index: int) -> None:
82            self.objects.pop(index)
83    
84            super().removeTab(index)
85    
86            # if self.currentIndex() + 1 >= index:
87            #     self.setCurrentIndex(index - 1)
88    
89            self.updateSelectFile()
90    
91            functions.project.centerMenuInit(self.project, True)
92    
##### scr\modules\widgets\versionLogScrollArea.py #####
1     from PyQt5.QtWidgets import QWidget, QLabel, QScrollArea, QVBoxLayout, QFrame
2     
3     from scr.variables import *
4     
5     
6     class VersionLogScrollArea(QWidget):
7         def __init__(self, parent, information: dict):
8             QWidget.__init__(self, parent)
9     
10             self.information = information
11    
12            self.area = QScrollArea(parent)
13            self.area.setGeometry(10, 40, Size.x(100) - 20, Size.y(100) - 70)
14    
15            container = QFrame()
16            layout = QVBoxLayout(container)
17    
18            layout.setContentsMargins(0, 0, 0, 0)
19            layout.setSpacing(0)
20    
21            for version in information["sorted"][::-1]:
22                update = information["updates"][version]
23    
24                name = QLabel()
25                name.setStyleSheet("padding-bottom: 4px; padding-top: 4px;")
26                name.setFont(BIG_HELP_FONT)
27                name.setText(update["name"])
28    
29                layout.addWidget(name)
30    
31                text = QLabel()
32                text.setFont(HELP_FONT)
33                text.setContentsMargins(0, 4, 0, 4)
34                text.setMinimumWidth(Size.x(100) - 100)
35                text.setMinimumHeight(20)
36                text.setWordWrap(True)
37    
38                text.setText(update["text"])
39    
40                layout.addWidget(text)
41    
42            container.setLayout(layout)
43    
44            self.area.setWidget(container)
45            self.area.setStyleSheet("border: 0px")
46            # self.area.setWidgetResizable(True)
47    
48            self.area.show()
49    
50        def show(self):
51            self.area.setGeometry(10, 40, Size.x(100) - 20, Size.y(100) - 70)
52    
53            self.area.show()
54    
55        def hide(self):
56            self.area.hide()
57    
##### scr\modules\widgets\__init__.py #####
1     from .focusLineEdit import FocusLineEdit
2     from .focusComboBox import FocusComboBox
3     
4     from .tabFileBar import TabFileBar
5     
6     from .versionLogScrollArea import VersionLogScrollArea
7     
8     from .collisionTable import CollisionTable
9     
##### scr\modules\__init__.py #####
1     
##### scr\tests\1.py #####
1     import sys
2     from PyQt5.QtWidgets import QApplication, QTabBar, QWidget
3     
4     from PyQt5.QtGui import QIcon
5     import qdarktheme
6     
7     
8     class FileTabBar(QTabBar):
9         def __init__(self, parent=None) -> None:
10             super().__init__(parent)
11    
12            self.setTabsClosable(True)
13            self.setExpanding(False)
14    
15            self.objects = {}
16    
17            self.tabCloseRequested.connect(self.pop)
18    
19        def add(self, name: str, visiable: str, icon: QIcon = None) -> int:
20            index = super().addTab(visiable)
21    
22            self.objects[name] = {
23                "index": index,
24                "visiable": visiable
25            }
26    
27            self.setTabIcon(index, icon if icon else QIcon())
28            self.setTabText(index, visiable)
29    
30            return index
31    
32        def remove(self, name: str) -> None:
33            find = False
34    
35            for key, value in self.objects.items():
36                if key == name:
37                    self.objects.pop(key)
38                    find = True
39    
40                    super().removeTab(value["index"])
41    
42                    continue
43    
44                if find:
45                    value["index"] -= 1
46    
47        def pop(self, index: int) -> None:
48            find = False
49    
50            for key, value in self.objects.items():
51                if value["index"] == index:
52                    self.objects.pop(key)
53                    find = True
54    
55                    continue
56    
57                if find:
58                    value["index"] -= 1
59    
60            super().removeTab(index)
61    
62    
63    class MainWindow(QWidget):
64        def __init__(self):
65            super().__init__()
66            self.initUI()
67    
68            qdarktheme.setup_theme()
69    
70        def initUI(self):
71            self.tab_bar = FileTabBar(parent=self)
72    
73            self.addTab("Tab 1")
74            self.addTab("Tab 2")
75    
76            self.tab_bar.setGeometry(0, 0, 500, 500)
77            self.tab_bar.show()
78    
79        def addTab(self, text="New Tab"):
80            index = self.tab_bar.addTab(text)
81    
82        def removeTab(self, index):
83            self.tab_widget.removeTab(index)
84    
85    
86    if __name__ == "__main__":
87        app = QApplication(sys.argv)
88        window = MainWindow()
89        window.show()
90        sys.exit(app.exec_())
91    
##### scr\tests\10.py #####
1     import subprocess
2     
3     
4     def handle_output(output):
5         # Ваша функция для обработки вывода
6         print("Handling output:")
7         print(output)
8     
9     
10     commands = [
11        "echo Hello",
12        "echo World",
13        "ls -l"
14    ]
15    
16    for command in commands:
17        result = subprocess.run(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
18    
19        # Проверка на ошибки
20        if result.returncode != 0:
21            print(f"Error executing {command}: {result.stderr}")
22        else:
23            handle_output(result.stdout)
24    
##### scr\tests\11.py #####
1     import sys
2     from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QFileDialog, QVBoxLayout
3     
4     class FolderSelector(QWidget):
5         def __init__(self):
6             super().__init__()
7     
8             self.initUI()
9     
10         def initUI(self):
11            self.setWindowTitle('Выбор папки')
12    
13            layout = QVBoxLayout()
14    
15            self.button = QPushButton('Выбрать папку', self)
16            self.button.clicked.connect(self.showDialog)
17    
18            layout.addWidget(self.button)
19    
20            self.setLayout(layout)
21    
22        def showDialog(self):
23            folder = QFileDialog.getExistingDirectory(self, 'Выбрать папку', '/home')
24    
25            if folder:
26                print(f'Выбранная папка: {folder}')
27    
28    if __name__ == '__main__':
29        app = QApplication(sys.argv)
30        ex = FolderSelector()
31        ex.show()
32        sys.exit(app.exec_())
33    
##### scr\tests\12.py #####
1     from math import sqrt
2     
3     
4     def bezierСurve(x0, y0, x1, y1, x2, y2, x3, y3, d):
5         answer = []
6     
7         def function(x0, y0, x1, y1, x2, y2, x3, y3, d):
8             px = (x3 - x0) / 3
9             py = (y3 - y0) / 3
10             mx1 = x1 - x0 - px
11            my1 = y1 - y0 - py
12            mx2 = x2 - x3 + px
13            my2 = y2 - y3 + py
14            d1 = sqrt(mx1 ** 2 + my1 ** 2)
15            d2 = sqrt(mx2 ** 2 + my2 ** 2)
16            if d1 < d and d2 < d:
17                answer.append([x3, y3])
18    
19            else:
20                x01 = (x0 + x1) / 2
21                y01 = (y0 + y1) / 2
22                x12 = (x1 + x2) / 2
23                y12 = (y1 + y2) / 2
24                x23 = (x2 + x3) / 2
25                y23 = (y2 + y3) / 2
26                x012 = (x01 + x12) / 2
27                y012 = (y01 + y12) / 2
28                x123 = (x12 + x23) / 2
29                y123 = (y12 + y23) / 2
30                x0123 = (x012 + x123) / 2
31                y0123 = (y012 + y123) / 2
32                bezierСurve(x0, y0, x01, y01, x012, y012, x0123, y0123, d)
33                bezierСurve(x0123, y0123, x123, y123, x23, y23, x3, y3, d)
34    
35        function(x0, y0, x1, y1, x2, y2, x3, y3, d)
36    
37        return answer
38    
39    
40    # d - точность
41    print(bezierСurve(0, 200, 200, 200, 200, 0, 400, 0, 0.0001))
42    
##### scr\tests\13.py #####
1     
2     import sys
3     from PyQt5.QtWidgets import QApplication, QWidget, QToolTip
4     from PyQt5.QtCore import Qt
5     from PyQt5.QtGui import QFont
6     
7     
8     class Example(QWidget):
9         def __init__(self):
10             super().__init__()
11            self.initUI()
12    
13        def initUI(self):
14            # Устанавливаем шрифт для всплывающего текста
15    
16            self.setMouseTracking(True)
17    
18            QToolTip.setFont(QFont('SansSerif', 10))
19    
20            self.setGeometry(300, 300, 400, 300)
21            self.setWindowTitle('Всплывающий текст при наведении')
22            self.show()
23    
24        # Переопределяем событие движения мыши
25        def mouseMoveEvent(self, event):
26            x, y = event.x(), event.y()
27    
28            # Если курсор находится на заданных координатах, выводим всплывающую подсказку
29            if abs(x - 100) < 10 and abs(y - 100) < 10:
30                QToolTip.showText(event.globalPos(), 'Вы находитесь на (100, 100)')
31    
32            else:
33                QToolTip.hideText()
34    
35    
36    if __name__ == '__main__':
37        app = QApplication(sys.argv)
38        ex = Example()
39        sys.exit(app.exec_())
40    
41    
##### scr\tests\14.py #####
1     from PyQt5.QtWidgets import QApplication, QLineEdit
2     
3     app = QApplication([])
4     
5     # Создаем поле для ввода текста
6     line_edit = QLineEdit()
7     
8     # Устанавливаем фоновый цвет через стиль
9     line_edit.setStyleSheet("QLineEdit { background-color: yellow; }")
10     
11    line_edit.show()
12    app.exec_()
##### scr\tests\15.py #####
1     import sys
2     from PyQt5.QtWidgets import QApplication, QWidget, QToolTip, QPushButton
3     from PyQt5.QtGui import QFont, QPalette, QColor, QCursor
4     
5     
6     class Example(QWidget):
7         def __init__(self):
8             super().__init__()
9     
10             # Устанавливаем шрифт для QToolTip
11            QToolTip.setFont(QFont('SansSerif', 10))
12    
13            # Настройка палитры для QToolTip
14            palette = QPalette()
15            palette.setColor(QPalette.ToolTipBase, QColor('yellow'))  # Цвет фона
16            palette.setColor(QPalette.ToolTipText, QColor('black'))   # Цвет текста
17            QApplication.setPalette(palette)
18    
19            # Создаем кнопку
20            btn = QPushButton('Наведите на меня', self)
21            btn.resize(btn.sizeHint())
22            btn.move(100, 100)
23    
24            # Связываем событие нажатия с кастомной подсказкой
25            btn.clicked.connect(self.show_custom_tooltip)
26    
27            self.setGeometry(300, 300, 300, 200)
28            self.setWindowTitle('QToolTip.showText пример')
29    
30        def show_custom_tooltip(self):
31            # Показываем текст подсказки в точке под курсором
32            QToolTip.showText(QCursor.pos(), "Это кастомная подсказка")
33    
34    if __name__ == '__main__':
35        app = QApplication(sys.argv)
36        ex = Example()
37        ex.show()
38        sys.exit(app.exec_())
39    
##### scr\tests\16.py #####
1     import sys
2     from PyQt5.QtWidgets import QApplication, QWidget, QLabel, QScrollArea, QVBoxLayout, QFrame
3     
4     class ScrollableLabels(QWidget):
5         def __init__(self):
6             super().__init__()
7     
8             # Создаем QScrollArea
9             scroll_area = QScrollArea(self)
10             scroll_area.setGeometry(10, 10, 280, 380)  # Задаем размеры и позицию
11    
12            # Создаем фрейм, который будет содержать все QLabel
13            container_widget = QFrame()
14            layout = QVBoxLayout(container_widget)
15    
16            # Создаем 100 QLabel и добавляем их в layout
17            for i in range(100):
18                label = QLabel(f"Label {i + 1}", container_widget)
19                layout.addWidget(label)
20    
21            # Устанавливаем layout для контейнера
22            container_widget.setLayout(layout)
23    
24            # Устанавливаем контейнер в scroll area
25            scroll_area.setWidget(container_widget)
26            scroll_area.setWidgetResizable(True)
27    
28            # Устанавливаем заголовок и размеры окна
29            self.setWindowTitle("Scrollable QLabel Example")
30            self.setGeometry(100, 100, 300, 400)  # Задаем размеры основного окна
31    
32    if __name__ == "__main__":
33        app = QApplication(sys.argv)
34        window = ScrollableLabels()
35        window.show()
36        sys.exit(app.exec_())
##### scr\tests\2.py #####
1     import sys
2     from PyQt5.QtWidgets import QApplication, QMainWindow, QTabWidget, QWidget, QVBoxLayout, QLabel, QMessageBox
3     
4     
5     class MainWindow(QMainWindow):
6         def __init__(self):
7             super().__init__()
8     
9             self.setWindowTitle("QTabWidget Example")
10             self.setGeometry(100, 100, 600, 400)
11    
12            self.tab_widget = QTabWidget()
13            self.setCentralWidget(self.tab_widget)
14    
15            # Добавляем вкладки
16            for i in range(3):
17                self.add_tab(f"Tab {i + 1}")
18    
19            # Разрешаем закрытие вкладок
20            self.tab_widget.setTabsClosable(True)
21    
22            # Подключаем сигнал для обработки закрытия вкладок
23            self.tab_widget.tabCloseRequested.connect(self.handle_tab_close_requested)
24    
25        def add_tab(self, title):
26            tab = QWidget()
27            layout = QVBoxLayout()
28            label = QLabel(f"Content of {title}")
29            layout.addWidget(label)
30            tab.setLayout(layout)
31            self.tab_widget.addTab(tab, title)
32    
33        def handle_tab_close_requested(self, index):
34            # Логика для отмены закрытия
35            reply = QMessageBox.question(
36                self,
37                'Close Tab',
38                f"Are you sure you want to close {self.tab_widget.tabText(index)}?",
39                QMessageBox.Yes | QMessageBox.No,
40                QMessageBox.No
41            )
42    
43            if reply == QMessageBox.Yes:
44                self.tab_widget.removeTab(index)
45            else:
46                # Отмена закрытия, ничего не делаем
47                pass
48    
49    
50    if __name__ == "__main__":
51        app = QApplication(sys.argv)
52        main_window = MainWindow()
53        main_window.show()
54        sys.exit(app.exec_())
55    
##### scr\tests\3.py #####
1     import sys
2     from PyQt5.QtWidgets import QApplication, QTreeWidget, QTreeWidgetItem, QWidget, QHBoxLayout, QLabel, QLineEdit, \
3         QSpacerItem, QSizePolicy
4     
5     
6     class CustomWidget(QWidget):
7         def __init__(self, parent=None):
8             super(CustomWidget, self).__init__(parent)
9     
10             # Создаем горизонтальный layout
11            layout = QHBoxLayout()
12    
13            # Создаем QLabel с фиксированным размером
14            self.label = QLabel("Label:")
15            self.label.setFixedWidth(50)
16    
17            # Создаем QLineEdit с фиксированным размером
18            self.line_edit = QLineEdit()
19            self.line_edit.setFixedWidth(200)
20    
21            # Добавляем QLabel и SpacerItem
22            layout.addWidget(self.label)
23            layout.addSpacerItem(QSpacerItem(20, 0, QSizePolicy.Expanding, QSizePolicy.Minimum))
24    
25            # Добавляем QLineEdit
26            layout.addWidget(self.line_edit)
27    
28            # Убираем внешние отступы
29            layout.setContentsMargins(0, 0, 0, 0)
30    
31            # Устанавливаем layout для виджета
32            self.setLayout(layout)
33    
34    
35    class TreeWidgetExample(QTreeWidget):
36        def __init__(self):
37            super(TreeWidgetExample, self).__init__()
38    
39            # Скрыть заголовок
40            self.header().hide()
41            self.show()
42    
43            # Создаем корневой элемент
44            root = QTreeWidgetItem(self)
45            root.setText(0, 'Root')
46    
47            # Создаем дочерний элемент
48            child = QTreeWidgetItem(root)
49    
50            # Создаем экземпляр кастомного виджета
51            custom_widget = CustomWidget()
52    
53            # Вставляем виджет в элемент дерева
54            self.setItemWidget(child, 0, custom_widget)
55    
56    
57    if __name__ == '__main__':
58        app = QApplication(sys.argv)
59        tree = TreeWidgetExample()
60        sys.exit(app.exec_())
61    
##### scr\tests\4.py #####
1     import sys
2     from PyQt5.QtWidgets import QApplication, QWidget
3     from PyQt5.QtCore import Qt, QPoint
4     from PyQt5.QtGui import QPainter, QPen
5     
6     class MyWidget(QWidget):
7         def __init__(self):
8             super().__init__()
9             self.initUI()
10             self.setMouseTracking(True)
11            self.drawing = False
12            self.lastPoint = QPoint()
13    
14        def initUI(self):
15            self.setGeometry(100, 100, 800, 600)
16            self.setWindowTitle('Mouse Drag Event Example')
17    
18        def mousePressEvent(self, event):
19            if event.button() == Qt.LeftButton:
20                self.drawing = True
21                self.lastPoint = event.pos()
22    
23        def mouseMoveEvent(self, event):
24            if event.buttons() & Qt.LeftButton and self.drawing:
25                painter = QPainter(self)
26                pen = QPen(Qt.black, 2, Qt.SolidLine)
27                painter.setPen(pen)
28                painter.drawLine(self.lastPoint, event.pos())
29                self.lastPoint = event.pos()
30    
31                print(self.lastPoint)
32    
33                self.update()
34    
35        def mouseReleaseEvent(self, event):
36            if event.button() == Qt.LeftButton:
37                self.drawing = False
38    
39        def paintEvent(self, event):
40            canvasPainter = QPainter(self)
41            canvasPainter.setPen(QPen(Qt.black, 2, Qt.SolidLine))
42    
43    if __name__ == '__main__':
44        app = QApplication(sys.argv)
45        ex = MyWidget()
46        ex.show()
47        sys.exit(app.exec_())
48    
##### scr\tests\5.py #####
1     import sys
2     from PyQt5.QtCore import QTimer
3     from PyQt5.QtWidgets import QApplication, QLabel, QVBoxLayout, QWidget
4     
5     
6     class MyWidget(QWidget):
7         def __init__(self):
8             super().__init__()
9     
10             self.initUI()
11    
12            # Создание таймера
13            self.timer = QTimer(self)
14            # Подключение таймера к функции обновления
15            self.timer.timeout.connect(self.updateLabel)
16            # Установка интервала таймера (в миллисекундах)
17            self.timer.start(1000)  # Интервал 1000 мс = 1 секунда
18    
19        def initUI(self):
20            self.layout = QVBoxLayout()
21    
22            self.label = QLabel('0', self)
23            self.layout.addWidget(self.label)
24    
25            self.setLayout(self.layout)
26    
27            self.counter = 0
28    
29        def updateLabel(self):
30            # Код, который будет выполняться постоянно
31            self.counter += 1
32            self.label.setText(str(self.counter))
33    
34    
35    if __name__ == '__main__':
36        app = QApplication(sys.argv)
37    
38        widget = MyWidget()
39        widget.show()
40    
41        sys.exit(app.exec_())
42    
##### scr\tests\6.py #####
1     import sys
2     import traceback
3     
4     # Открываем файл для записи вывода
5     with open('output.log', 'w') as log_file:
6         try:
7             # Перенаправляем стандартный вывод и стандартный поток ошибок в файл
8             sys.stderr = log_file
9     
10             # Ваш код здесь
11            print("This is a message to the log file.")
12            x = 1 / 0  # Пример ошибки
13    
14        except Exception as e:
15            # Записываем трассировку стека в файл
16            traceback.print_exc(file=log_file)
17    
18        finally:
19            # Восстанавливаем стандартные потоки
20            sys.stderr = sys.__stderr__
21    
22    print("Программа завершена.")
23    
##### scr\tests\7.py #####
1     from PIL import Image
2     
3     # Открываем изображение
4     image = Image.open('grass.png')
5     
6     # Устанавливаем новые размеры, кратные оригиналу (например, в два раза больше)
7     width, height = image.size
8     new_width = width * 2
9     new_height = height * 2
10     
11    # Используем метод resize с различными методами интерполяции
12    resized_image_nearest = image.resize((new_width, new_height), resample=Image.NEAREST)
13    resized_image_bilinear = image.resize((new_width, new_height), resample=Image.BILINEAR)
14    resized_image_bicubic = image.resize((new_width, new_height), resample=Image.BICUBIC)
15    resized_image_lanczos = image.resize((new_width, new_height), resample=Image.LANCZOS)
16    
17    # Сохраняем или отображаем результаты
18    resized_image_nearest.save('resized_image_nearest.png')
19    resized_image_bilinear.save('resized_image_bilinear.png')
20    resized_image_bicubic.save('resized_image_bicubic.png')
21    resized_image_lanczos.save('resized_image_lanczos.png')
22    
23    resized_image_nearest.show()
24    resized_image_bilinear.show()
25    resized_image_bicubic.show()
26    resized_image_lanczos.show()
27    
##### scr\tests\8.py #####
1     from PyQt5.QtCore import QPropertyAnimation, QRect
2     from PyQt5.QtGui import QPixmap
3     from PyQt5.QtWidgets import QApplication, QLabel, QWidget, QVBoxLayout
4     
5     
6     class AnimatedLabel(QWidget):
7         def __init__(self):
8             super().__init__()
9     
10             self.label = QLabel(self)
11            pixmap = QPixmap("image.png")
12            self.label.setPixmap(pixmap)
13            self.label.setGeometry(50, 50, pixmap.width(), pixmap.height())
14    
15            self.animation = QPropertyAnimation(self.label, b"geometry")
16            self.animation.setDuration(1000)  # Длительность анимации в миллисекундах
17            self.animation.setStartValue(QRect(50, 50, pixmap.width(), pixmap.height()))
18            self.animation.setEndValue(QRect(50, 50, pixmap.width() * 2, pixmap.height() * 2))
19            self.animation.start()
20    
21            layout = QVBoxLayout(self)
22            layout.addWidget(self.label)
23            self.setLayout(layout)
24    
25    
26    if __name__ == "__main__":
27        import sys
28    
29        app = QApplication(sys.argv)
30        window = AnimatedLabel()
31        window.show()
32        sys.exit(app.exec_())
33    
##### scr\tests\9.py #####
1     from PyQt5.QtWidgets import QApplication, QLabel, QWidget, QVBoxLayout
2     from PyQt5.QtCore import QPropertyAnimation, QSize
3     from PyQt5.QtGui import QPixmap
4     
5     
6     class ImageWidget(QWidget):
7         def __init__(self):
8             super().__init__()
9     
10             self.label = QLabel(self)
11            self.pixmap1 = QPixmap('air.png')
12            self.pixmap2 = QPixmap('fire.png')
13            self.label.setPixmap(self.pixmap1)
14    
15            self.animation = QPropertyAnimation(self.label, b"size")
16            self.animation.setDuration(1000)
17            self.animation.setStartValue(self.pixmap1.size())
18            self.animation.setEndValue(self.pixmap2.size())
19            self.animation.valueChanged.connect(self.on_value_changed)
20    
21            layout = QVBoxLayout(self)
22            layout.addWidget(self.label)
23    
24        def on_value_changed(self, size):
25            scaled_pixmap = self.pixmap1.scaled(size)
26            self.label.setPixmap(scaled_pixmap)
27    
28        def start_animation(self):
29            self.animation.start()
30    
31    
32    app = QApplication([])
33    window = ImageWidget()
34    window.show()
35    window.start_animation()
36    app.exec_()
37    
##### scr\tests\project\Main.py #####
1     import engine
2     import random
3     import pygame
4     
5     
6     class Functions:
7         @staticmethod
8         def reset(self):
9             self.objects.add(engine.objects.DynamicObject(self, [20 + random.randint(1, 200), 20 + random.randint(1, 200)], [0, 0, 80, 110], self.player_animation, "player", speed=5, gravity=300, jumpPower=10, slidingStep=1))
10     
11            self.player = self.objects.getByGroup("player")[0]
12    
13            self.focus = self.player.id
14    
15            self.camera.setFocus(self.player)
16            
17        @staticmethod
18        def test(game, dynamicObject=None, staticObject=None):
19            print("hello world!")
20    
21    
22    class Game(engine.Application):
23        def __init__(self):
24            engine.Application.__init__(self, "project/project.property")
25    
26            self.sprite = engine.Sprite(self, "project/sprite.png", [32, 32])
27    
28            self.particle_sprite = engine.Sprite(self, "project/particle.png")
29    
30            self.player_animation = engine.Animation(
31                self, "project/project.animation", {
32                    "move": ["project/player/player_run_1.png", "project/player/player_run_2.png"] * 2,
33                    "jump": ["project/player/player_jump.png"],
34                    "fall": ["project/player/player_fall.png"],
35                    "idle": ["project/player/player_idle.png"]
36                }
37            )
38    
39            self.objects.collisions = engine.Collision("project/project.collision")
40    
41            for i in range(100):
42                var = random.randint(1, 4)
43    
44                if i % var == 0 or i < 15 or True:
45                    self.objects.add(engine.objects.StaticObject(self, [0 + i * 32, 400], [0, 0, 32, 32], self.sprite, "block"))
46    
47            self.objects.add(engine.objects.DynamicObject(self, [20 + random.randint(1, 200), 20 + random.randint(1, 200)], [0, 0, 80, 110], self.player_animation, "player", speed=5, gravity=300, jumpPower=10, slidingStep=1))
48    
49            self.player = self.objects.getByGroup("player")[0]
50    
51            self.focus = self.player.id
52    
53            self.setCamera(engine.camera.FocusCamera(self, self.player))
54            self.setFunctionClass(Functions)
55    
56            self.setKeyEvent(["PRESS", "d"], lambda: self.player.typeMove("right"))
57            self.setKeyEvent(["PRESS", "a"], lambda: self.player.typeMove("left"))
58            self.setKeyEvent(["KEYDOWN", "SPACE"], lambda: self.player.typeMove("jump"))
59            self.setKeyEvent(["KEYDOWN", "r"], lambda: Functions.reset(self))
60    
61            self.sprites = [
62                engine.Sprite(self, "project/button/base.png"),
63                engine.Sprite(self, "project/button/mouse.png"),
64                engine.Sprite(self, "project/button/click.png")
65            ]
66    
67            self.button = engine.Button(
68                self, [300, 20, 200, 100], *self.sprites, None, engine.Label(self, [300, 20, 200, 100], "Hello world!"),
69                function=lambda: Functions.reset(self)
70            )
71    
72        def update(self) -> None:
73            super().update()
74    
75            for _ in range(5):
76                particle_function = engine.ParticleFunction(self, {
77                    "x": lambda variables, pos, step: pos.x + (step / 10) * variables["speed"],
78                    "y": lambda variables, pos, step: pos.y + (step / 1000) * variables["var"],
79    
80                    "resize": lambda variables, pos, step: (step > 50, 10 - ((step - 40) / 5), 10 - ((step - 40) / 5)),
81                    "death": lambda variables, pos, step: step > 75
82                }, variables={"var": random.randint(-10, 10), "speed": random.randint(10, 12) / 10})
83    
84                particle = engine.ImageParticle(self, [random.randint(0, 50), 100], self.particle_sprite, particle_function, "p1")
85    
86                self.particles.add(particle)
87    
88        def render(self) -> None:
89            super().render()
90    
91            self.button.draw()
92    
93    
94    if __name__ == "__main__":
95        game = Game()
96        game.start()
97    
##### scr\variables.py #####
1     from PyQt5.Qt import QMessageBox
2     from PyQt5.QtGui import QFont
3     
4     from scr.modules.translate import Translate
5     
6     import importlib.util
7     import platform
8     import random
9     import pygame
10     import ujson
11    import json
12    import os
13    
14    DIVELOP = False
15    
16    pygame.init()
17    
18    
19    with open("scr/files/settings/settings.json", "r", encoding="utf-8") as file:
20        SETTINGS = json.load(file)
21    
22    PLUS = 64 + 8 - 1
23    
24    # MINI FONT
25    
26    MFONT = QFont("scr/files/fonts/mini.ttf")
27    MFONT.setPointSize(7)
28    
29    # BASE FONT
30    
31    FONT = QFont()
32    FONT.setPointSize(9)
33    
34    # LARGE FONT
35    
36    LFONT = QFont()
37    LFONT.setPointSize(10)
38    
39    # LARGE BOLD FONT
40    
41    LBFONT = QFont()
42    LBFONT.setPointSize(8)
43    LBFONT.setBold(True)
44    
45    # BASE BIG FONT
46    
47    BBFONT = QFont()
48    BBFONT.setPointSize(18)
49    
50    # BIG FONT
51    
52    BFONT = QFont("Georgia")
53    BFONT.setPointSize(18)
54    
55    # SYSTEM FONT
56    
57    SFONT = QFont("Courier", weight=16)
58    SFONT.setPointSize(13)
59    
60    # BIG HELP FONT
61    
62    BIG_HELP_FONT = QFont("Consolas")
63    BIG_HELP_FONT.setPointSize(14)
64    
65    # HELP FONT
66    
67    HELP_FONT = QFont("Courier")
68    HELP_FONT.setPointSize(10)
69    
70    # TRANSLATE
71    
72    translate = Translate(SETTINGS["language"])
73    
74    
75    class MessageBox:
76        @staticmethod
77        def imposiable(detail):
78            title = translate.translate("Impossible operation")
79    
80            msg = QMessageBox()
81            msg.setIcon(QMessageBox.Information)
82            msg.setText(translate(str(detail)))
83            msg.setWindowTitle(title)
84            msg.setStandardButtons(QMessageBox.Ok)
85            msg.exec_()
86    
87        @staticmethod
88        def error(detail):
89            title = translate.translate("Error")
90    
91            msg = QMessageBox()
92            msg.setIcon(QMessageBox.Information)
93            msg.setText(translate(str(detail)))
94            msg.setWindowTitle(title)
95            msg.setStandardButtons(QMessageBox.Ok)
96            msg.exec_()
97    
98        @staticmethod
99        def special(name, detail):
100            title = translate.translate(name)
101   
102           msg = QMessageBox()
103           msg.setIcon(QMessageBox.Information)
104           msg.setText(translate(str(detail)))
105           msg.setWindowTitle(title)
106           msg.setStandardButtons(QMessageBox.Ok)
107           msg.exec_()
108   
109   
110   class Size:
111       @staticmethod
112       def x(var) -> int:
113           return round(size["width"] * (var / 100))
114   
115       @staticmethod
116       def y(var) -> int:
117           return round((size["height"] + PLUS) * (var / 100))
118   
119   
120   def load(fp, *args, **kwargs):
121       return ujson.loads(fp.read())
122   
123   
124   def loads(s, *args, **kwargs):
125       return ujson.loads(s)
126   
127   
128   def dump(obj, fp, *args, **kwargs):
129       fp.write(ujson.dumps(obj, *args, **kwargs))
130   
131   
132   def dumps(obj, *args, **kwargs):
133       return ujson.dumps(obj, *args, **kwargs)
134   
135   
136   def loader(path):
137       name = os.path.basename(path).split(".")[0]
138   
139       spec = importlib.util.spec_from_file_location(name, path)
140       module = importlib.util.module_from_spec(spec)
141       spec.loader.exec_module(module)
142   
143       return module
144   
145   
146   size = {}
147   
148   FLAGS = {
149       "not-view-version-update": False
150   }
151   
152   SYSTEM = platform.system()
153   RELEASE = platform.release()
154   
155   IMAGE_FORMATES = "jpeg jpg jpe jfif png ico tiff tif eps svg".split()
156   BLOCKED_FORMATES = "cfg obj objc func".split()
157   
158   DONT_OPEN_FORMATES = ()
159   
160   CODE_GRID_CELL_SIZE = 25
161   CODE_GRID_CELL_SIZE_TWO = 26
162   
163   CODE_POINT_PRECISION = 6
164   CODE_LINER_PRECISION = 0.25
165   CODE_CONNECTOR_NO_HAVE_INPUT_TYPES = ["path"]
166   
167   OBJECT_CURRECT_TEST = ["type", "type/name", "type/value", "type/type", "StaticObject", "StaticObject/pos", "StaticObject/hitbox", "StaticObject/sprite", "StaticObject/group", "StaticObject/layer"]
168   NODE_CURRECT_TEST = ["display", "id", "width", "height", "x", "y", "name", "inputs", "outputs", "type"]
169   
170   SOCKET_ID = random.randint(2**10, 2**16 - 1)
171   
172   SPRITES = {
173       "dir": "scr/files/sprites/dir.png",
174       "cfg": "scr/files/sprites/cfg.png",
175       "file": "scr/files/sprites/file.png",
176       "scene": "scr/files/sprites/scene.png",
177       "py": "scr/files/sprites/python.png",
178       "func": "scr/files/sprites/func.png",
179       "obj": "scr/files/sprites/obj.png",
180       "objc": "scr/files/sprites/obj.png",
181       "json": "scr/files/sprites/json.png",
182       "scene-light": "scr/files/sprites/scene-light.png",
183       "dir-light": "scr/files/sprites/dir-light.png"
184   }
185   
186   for element in IMAGE_FORMATES:
187       SPRITES[element] = "scr/files/sprites/image.png"
188   
189   for element in IMAGE_FORMATES:
190       SPRITES[f"{element}-light"] = "scr/files/sprites/image-light.png"
191   
192   BASE_SETTINGS = {
193       "language": "EN"
194   }
195   
196   LANGUAGES = {
197       "RU": "Русский",
198       "EN": "English"
199   }
200   
201   THEMES = {
202       "light": "Light",
203       "dark": "Dark"
204   }
205   
206   if SETTINGS["theme"] == "dark":
207       BUTTON_RED_STYLE = """
208       QPushButton {
209           color: red;
210       }
211       QPushButton:hover {
212           background-color: #3B2727;
213       }
214       QPushButton:pressed {
215           background-color: #F66060;
216           color: black;
217       }
218       """
219   
220       BUTTON_BLUE_STYLE = """
221       QPushButton {
222           color: #8ab4f7;
223       }
224       QPushButton:hover {
225           background-color: #272e3b;
226       }
227       QPushButton:pressed {
228           background-color: #5f9af4;
229           color: black;
230       }
231       """
232   
233   else:
234       BUTTON_RED_STYLE = """
235       QPushButton {
236           color: red;
237       }
238       QPushButton:hover {
239           background-color: #F0E0E0;
240       }
241       QPushButton:pressed {
242           background-color: #F66060;
243           color: black;
244       }
245       """
246   
247       BUTTON_BLUE_STYLE = """
248       QPushButton {
249           color: #1E90FF;
250       }
251       QPushButton:hover {
252           background-color: #E0E8F0;
253       }
254       QPushButton:pressed {
255           background-color: #ADD8E6;
256           color: black;
257       }
258       """
259   
##### Game Engine 3.py #####
1     from PyQt5.QtWidgets import QApplication
2     
3     from scr.main import Main
4     
5     from scr.variables import *
6     
7     import traceback
8     import sys
9     import os
10     
11    # SETTINGS
12    
13    FORCED = False
14    DEBUG = True if (os.getenv("PYCHARM_HOSTED") == "1" and not FORCED) else False
15    
16    
17    def application() -> None:
18        app = QApplication(sys.argv)
19        ex = Main(app)
20    
21        sys.exit(app.exec_())
22    
23    
24    def main() -> None:
25        with open("scr/files/logs/log.txt", "w+", encoding="utf-8", buffering=1) as file:
26            try:
27                if not DEBUG:
28                    sys.stdout = file
29                    sys.stderr = file
30    
31                print(f"LOG: debug mode = {DEBUG}")
32                print(f"LOG: program runned on \"{SYSTEM} {RELEASE}\"")
33    
34                application()
35    
36            except Exception as e:
37                traceback.print_exc(file=file)
38    
39                print("LOG: scr/files/logs/log.txt")
40    
41            finally:
42                sys.stdout = sys.__stdout__
43                sys.stderr = sys.__stderr__
44    
45    
46    if __name__ == "__main__":
47        main()
48    
49    